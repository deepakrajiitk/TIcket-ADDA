{"ast":null,"code":"/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nconst TYPE = 'User';\nconst Identity = require('./Identity');\nconst Signer = require('./Signer');\nconst SigningIdentity = require('./SigningIdentity');\nconst sdkUtils = require('./Utils');\nconst logger = sdkUtils.getLogger(TYPE);\nconst check = sdkUtils.checkParameter;\n\n/**\n * The User class represents users that have been enrolled and represented by\n * an enrollment certificate (ECert) and a signing key. The ECert must have\n * been signed by one of the CAs the blockchain network has been configured to trust.\n * An enrolled Admin user (having a signing key and ECert) can conduct chaincode instantiate,\n * transactions and queries with the Channel.\n *\n * User ECerts can be obtained from a CA beforehand as part of installing and instantiating\n * the application, or it can be obtained from the optional Fabric CA service via its\n * enrollment process.\n *\n * Sometimes User identities are confused with Peer identities. User identities represent\n * signing capability because it has access to the private key, while Peer identities in\n * the context of the application/SDK only has the certificate for verifying signatures.\n * An application cannot use the Peer identity to sign things because the application does not\n * have access to the Peer identity’s private key.\n *\n * @class\n */\nconst User = class {\n  /**\n   * Constructor for a member.\n   *\n   * @param {string|Object} cfg - The member name or an object with the following attributes:\n   *   - enrollmentID {string}: user name\n   *   - name {string}: user name, if \"enrollmentID\" is also specified, the \"name\" is ignored\n   *   - roles {string[]}: optional. array of roles\n   *   - affiliation {string}: optional. affiliation with a group or organization\n   */\n  constructor(cfg) {\n    this.type = TYPE;\n    if (typeof cfg === 'string') {\n      this._name = cfg;\n      this._roles = null; // string[]\n      this._affiliation = '';\n    } else if (cfg !== null && typeof cfg === 'object') {\n      const req = cfg;\n      this._name = req.enrollmentID || req.name;\n      this._roles = req.roles || ['fabric.user'];\n      this._affiliation = req.affiliation;\n    }\n    this._enrollmentSecret = '';\n    this._identity = null;\n    this._signingIdentity = null;\n    this._mspId = '';\n    this._cryptoSuite = null;\n  }\n\n  /**\n   * Get the member name.\n   * @returns {string} The member name.\n   */\n  getName() {\n    return this._name;\n  }\n\n  /**\n   * Get the MSP Id.\n   * @returns {string} The mspid.\n   */\n  getMspid() {\n    return this._mspId;\n  }\n\n  /**\n   * Get the roles.\n   * @returns {string[]} The roles.\n   */\n  getRoles() {\n    return this._roles;\n  }\n\n  /**\n   * Get the enrollment secret.\n   * @returns {string} The password.\n   */\n  getEnrollmentSecret() {\n    return this._enrollmentSecret;\n  }\n\n  /**\n   * Set the roles.\n   * @param roles {string[]} The roles.\n   */\n  setRoles(roles) {\n    this._roles = roles;\n  }\n\n  /**\n   * Get the affiliation.\n   * @returns {string} The affiliation.\n   */\n  getAffiliation() {\n    return this._affiliation;\n  }\n\n  /**\n   * Set the affiliation.\n   * @param {string} affiliation The affiliation.\n   */\n  setAffiliation(affiliation) {\n    this._affiliation = affiliation;\n  }\n\n  /**\n   * Get the {@link Identity} object for this User instance, used to verify signatures\n   * @returns {Identity} the identity object that encapsulates the user's enrollment certificate\n   */\n  getIdentity() {\n    return this._identity;\n  }\n\n  /**\n   * Get the {@link SigningIdentity} object for this User instance, used to generate signatures\n   * @returns {SigningIdentity} the identity object that encapsulates the user's private key for signing\n   */\n  getSigningIdentity() {\n    return this._signingIdentity;\n  }\n\n  /**\n   * Set the {@link SigningIdentity} object for this User instance, used to generate signatures\n   * @param {SigningIdentity} the identity object that encapsulates the user's private key for signing\n   */\n  setSigningIdentity(signingIdentity) {\n    this._signingIdentity = signingIdentity;\n    this._identity = signingIdentity;\n  }\n\n  /**\n   * Get the {@link module:api.CryptoSuite} cryptoSuite object for this User instance.\n   * @returns {module:api.CryptoSuite} the cryptoSuite used to store crypto and key store settings\n   */\n  getCryptoSuite() {\n    return this._cryptoSuite;\n  }\n\n  /**\n   * Set the cryptoSuite.\n   *\n   * When the application needs to use crypto settings or a key store other than the default,\n   * it needs to set a cryptoSuite instance that was created with the desired CryptoSuite\n   * settings and CryptoKeyStore options.\n   *\n   * @param {module:api.CryptoSuite} cryptoSuite The cryptoSuite.\n   */\n  setCryptoSuite(cryptoSuite) {\n    this._cryptoSuite = cryptoSuite;\n  }\n\n  /**\n   * This is a factory method. It returns a new instance of the CryptoSuite API implementation, based on the \"setting\"\n   * that is passed in, or if skipped, based on default values of the {@link CryptoSetting} properties.\n   *\n   * @param {CryptoSetting} setting Optional\n   * @returns {module:api.CryptoSuite} a new instance of the CryptoSuite API implementation\n   */\n  static newCryptoSuite(setting) {\n    return sdkUtils.newCryptoSuite(setting);\n  }\n\n  /**\n   * Set the enrollment object for this User instance\n   *\n   * @async\n   * @param {module:api.Key} privateKey the private key object\n   * @param {string} certificate the PEM-encoded string of certificate\n   * @param {string} mspId The Member Service Provider id for the local signing identity\n   * @returns {Promise} Promise for successful completion of creating the user's signing Identity\n   */\n  async setEnrollment(privateKey, certificate, mspId) {\n    if (typeof privateKey === 'undefined' || privateKey === null || privateKey === '') {\n      throw new Error('Invalid parameter. Must have a valid private key.');\n    }\n    if (typeof certificate === 'undefined' || certificate === null || certificate === '') {\n      throw new Error('Invalid parameter. Must have a valid certificate.');\n    }\n    if (typeof mspId === 'undefined' || mspId === null || mspId === '') {\n      throw new Error('Invalid parameter. Must have a valid mspId.');\n    }\n    this._mspId = mspId;\n    if (!this._cryptoSuite) {\n      this._cryptoSuite = sdkUtils.newCryptoSuite();\n      this._cryptoSuite.setCryptoKeyStore(sdkUtils.newCryptoKeyStore());\n    }\n    const pubKey = await this._cryptoSuite.createKeyFromRaw(certificate);\n    this._identity = new Identity(certificate, pubKey, mspId, this._cryptoSuite);\n    this._signingIdentity = new SigningIdentity(certificate, pubKey, mspId, this._cryptoSuite, new Signer(this._cryptoSuite, privateKey));\n  }\n\n  /**\n   * Determine if this name has been enrolled.\n   * @returns {boolean} True if enrolled; otherwise, false.\n   */\n  isEnrolled() {\n    return this._identity !== null && this._signingIdentity !== null;\n  }\n\n  /**\n   * Set the current state of this member from a string based JSON object\n   *\n   * @async\n   * @param {string} str - the member state serialized\n   * @return {Member} Promise of the unmarshalled Member object represented by the serialized string\n   */\n  async fromString(str) {\n    logger.debug('fromString --start');\n    const state = JSON.parse(str);\n    if (state.name !== this.getName()) {\n      throw new Error('name mismatch: \\'' + state.name + '\\' does not equal \\'' + this.getName() + '\\'');\n    }\n    this._name = state.name;\n    this._roles = state.roles;\n    this._affiliation = state.affiliation;\n    this._enrollmentSecret = state.enrollmentSecret;\n    if (typeof state.mspid === 'undefined' || state.mspid === null || state.mspid === '') {\n      throw new Error('Failed to find \"mspid\" in the deserialized state object for the user. Likely due to an outdated state store.');\n    }\n    this._mspId = state.mspid;\n    if (!this._cryptoSuite) {\n      this._cryptoSuite = sdkUtils.newCryptoSuite();\n      this._cryptoSuite.setCryptoKeyStore(sdkUtils.newCryptoKeyStore());\n    }\n    const pubKey = this._cryptoSuite.createKeyFromRaw(state.enrollment.identity.certificate);\n    this._identity = new Identity(state.enrollment.identity.certificate, pubKey, this._mspId, this._cryptoSuite);\n\n    // during serialization (see toString() below) only the key's SKI are saved\n    // swap out that for the real key from the crypto provider\n    const privateKey = await this._cryptoSuite.getKey(state.enrollment.signingIdentity);\n\n    // the key retrieved from the key store using the SKI could be a public key\n    // or a private key, check to make sure it's a private key\n    if (privateKey && privateKey.isPrivate()) {\n      this._signingIdentity = new SigningIdentity(state.enrollment.identity.certificate, pubKey, this._mspId, this._cryptoSuite, new Signer(this._cryptoSuite, privateKey));\n      return this;\n    } else {\n      throw new Error(`Private key missing from key store. Can not establish the signing identity for user ${state.name}`);\n    }\n  }\n\n  /**\n   * Returns a {@link User} object with signing identities based on the\n   * private key and the corresponding x509 certificate. This allows applications\n   * to use pre-existing crypto materials (private keys and certificates) to\n   * construct user objects with signing capabilities, as an alternative to\n   * dynamically enrolling users with [fabric-ca]{@link http://hyperledger-fabric-ca.readthedocs.io/en/latest/}\n   *\n   * @async\n   * @param {UserOpts} opts - Essential information about the user\n   * @returns {User} the user object.\n   */\n  static createUser() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : check('name');\n    let password = arguments.length > 1 ? arguments[1] : undefined;\n    let mspid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : check('mspid');\n    let signedCertPEM = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : check('signedCertPEM');\n    let privateKeyPEM = arguments.length > 4 ? arguments[4] : undefined;\n    logger.debug('createUser %s', name);\n    const cryptoSuite = sdkUtils.newCryptoSuite();\n    let privateKey = null;\n    if (privateKeyPEM) {\n      privateKey = cryptoSuite.createKeyFromRaw(privateKeyPEM.toString());\n    }\n    const pubKey = cryptoSuite.createKeyFromRaw(signedCertPEM.toString());\n    const user = new User(name);\n    user._enrollmentSecret = password;\n    user._cryptoSuite = cryptoSuite;\n    user._mspId = mspid;\n    user._identity = new Identity(signedCertPEM, pubKey, mspid, cryptoSuite);\n    if (privateKey) {\n      user._signingIdentity = new SigningIdentity(signedCertPEM, pubKey, mspid, cryptoSuite, new Signer(cryptoSuite, privateKey));\n    }\n    return user;\n  }\n\n  /**\n   * Save the current state of this member as a string\n   * @return {string} The state of this member as a string\n   */\n  toString() {\n    const serializedEnrollment = {};\n    if (this._signingIdentity) {\n      serializedEnrollment.signingIdentity = this._signingIdentity._signer._key.getSKI();\n    }\n    if (this._identity) {\n      serializedEnrollment.identity = {\n        certificate: this._identity._certificate\n      };\n    }\n    const state = {\n      name: this._name,\n      mspid: this._mspId,\n      roles: this._roles,\n      affiliation: this._affiliation,\n      enrollmentSecret: this._enrollmentSecret,\n      enrollment: serializedEnrollment\n    };\n    return JSON.stringify(state);\n  }\n  static isInstance(object) {\n    return typeof object._name !== 'undefined' && typeof object._roles !== 'undefined' && typeof object._affiliation !== 'undefined' && typeof object._enrollmentSecret !== 'undefined' && typeof object._identity !== 'undefined' && typeof object._signingIdentity !== 'undefined' && typeof object._mspId !== 'undefined' && typeof object._cryptoSuite !== 'undefined';\n  }\n};\nmodule.exports = User;","map":{"version":3,"names":["TYPE","Identity","require","Signer","SigningIdentity","sdkUtils","logger","getLogger","check","checkParameter","User","constructor","cfg","type","_name","_roles","_affiliation","req","enrollmentID","name","roles","affiliation","_enrollmentSecret","_identity","_signingIdentity","_mspId","_cryptoSuite","getName","getMspid","getRoles","getEnrollmentSecret","setRoles","getAffiliation","setAffiliation","getIdentity","getSigningIdentity","setSigningIdentity","signingIdentity","getCryptoSuite","setCryptoSuite","cryptoSuite","newCryptoSuite","setting","setEnrollment","privateKey","certificate","mspId","Error","setCryptoKeyStore","newCryptoKeyStore","pubKey","createKeyFromRaw","isEnrolled","fromString","str","debug","state","JSON","parse","enrollmentSecret","mspid","enrollment","identity","getKey","isPrivate","createUser","arguments","length","undefined","password","signedCertPEM","privateKeyPEM","toString","user","serializedEnrollment","_signer","_key","getSKI","_certificate","stringify","isInstance","object","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/User.js"],"sourcesContent":["/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nconst TYPE = 'User';\n\nconst Identity = require('./Identity');\nconst Signer = require('./Signer');\nconst SigningIdentity = require('./SigningIdentity');\nconst sdkUtils = require('./Utils');\nconst logger = sdkUtils.getLogger(TYPE);\nconst check = sdkUtils.checkParameter;\n\n\n/**\n * The User class represents users that have been enrolled and represented by\n * an enrollment certificate (ECert) and a signing key. The ECert must have\n * been signed by one of the CAs the blockchain network has been configured to trust.\n * An enrolled Admin user (having a signing key and ECert) can conduct chaincode instantiate,\n * transactions and queries with the Channel.\n *\n * User ECerts can be obtained from a CA beforehand as part of installing and instantiating\n * the application, or it can be obtained from the optional Fabric CA service via its\n * enrollment process.\n *\n * Sometimes User identities are confused with Peer identities. User identities represent\n * signing capability because it has access to the private key, while Peer identities in\n * the context of the application/SDK only has the certificate for verifying signatures.\n * An application cannot use the Peer identity to sign things because the application does not\n * have access to the Peer identity’s private key.\n *\n * @class\n */\nconst User = class {\n\n\t/**\n\t * Constructor for a member.\n\t *\n\t * @param {string|Object} cfg - The member name or an object with the following attributes:\n\t *   - enrollmentID {string}: user name\n\t *   - name {string}: user name, if \"enrollmentID\" is also specified, the \"name\" is ignored\n\t *   - roles {string[]}: optional. array of roles\n\t *   - affiliation {string}: optional. affiliation with a group or organization\n\t */\n\tconstructor(cfg) {\n\t\tthis.type = TYPE;\n\t\tif (typeof cfg === 'string') {\n\t\t\tthis._name = cfg;\n\t\t\tthis._roles = null; // string[]\n\t\t\tthis._affiliation = '';\n\t\t} else if (cfg !== null && typeof cfg === 'object') {\n\t\t\tconst req = cfg;\n\t\t\tthis._name = req.enrollmentID || req.name;\n\t\t\tthis._roles = req.roles || ['fabric.user'];\n\t\t\tthis._affiliation = req.affiliation;\n\t\t}\n\n\t\tthis._enrollmentSecret = '';\n\t\tthis._identity = null;\n\t\tthis._signingIdentity = null;\n\t\tthis._mspId = '';\n\t\tthis._cryptoSuite = null;\n\t}\n\n\t/**\n\t * Get the member name.\n\t * @returns {string} The member name.\n\t */\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Get the MSP Id.\n\t * @returns {string} The mspid.\n\t */\n\tgetMspid() {\n\t\treturn this._mspId;\n\t}\n\n\t/**\n\t * Get the roles.\n\t * @returns {string[]} The roles.\n\t */\n\tgetRoles() {\n\t\treturn this._roles;\n\t}\n\n\t/**\n\t * Get the enrollment secret.\n\t * @returns {string} The password.\n\t */\n\tgetEnrollmentSecret() {\n\t\treturn this._enrollmentSecret;\n\t}\n\n\t/**\n\t * Set the roles.\n\t * @param roles {string[]} The roles.\n\t */\n\tsetRoles(roles) {\n\t\tthis._roles = roles;\n\t}\n\n\t/**\n\t * Get the affiliation.\n\t * @returns {string} The affiliation.\n\t */\n\tgetAffiliation() {\n\t\treturn this._affiliation;\n\t}\n\n\t/**\n\t * Set the affiliation.\n\t * @param {string} affiliation The affiliation.\n\t */\n\tsetAffiliation(affiliation) {\n\t\tthis._affiliation = affiliation;\n\t}\n\n\t/**\n\t * Get the {@link Identity} object for this User instance, used to verify signatures\n\t * @returns {Identity} the identity object that encapsulates the user's enrollment certificate\n\t */\n\tgetIdentity() {\n\t\treturn this._identity;\n\t}\n\n\t/**\n\t * Get the {@link SigningIdentity} object for this User instance, used to generate signatures\n\t * @returns {SigningIdentity} the identity object that encapsulates the user's private key for signing\n\t */\n\tgetSigningIdentity() {\n\t\treturn this._signingIdentity;\n\t}\n\n\t/**\n\t * Set the {@link SigningIdentity} object for this User instance, used to generate signatures\n\t * @param {SigningIdentity} the identity object that encapsulates the user's private key for signing\n\t */\n\tsetSigningIdentity(signingIdentity) {\n\t\tthis._signingIdentity = signingIdentity;\n\t\tthis._identity = signingIdentity;\n\t}\n\n\t/**\n\t * Get the {@link module:api.CryptoSuite} cryptoSuite object for this User instance.\n\t * @returns {module:api.CryptoSuite} the cryptoSuite used to store crypto and key store settings\n\t */\n\tgetCryptoSuite() {\n\t\treturn this._cryptoSuite;\n\t}\n\n\t/**\n\t * Set the cryptoSuite.\n\t *\n\t * When the application needs to use crypto settings or a key store other than the default,\n\t * it needs to set a cryptoSuite instance that was created with the desired CryptoSuite\n\t * settings and CryptoKeyStore options.\n\t *\n\t * @param {module:api.CryptoSuite} cryptoSuite The cryptoSuite.\n\t */\n\tsetCryptoSuite(cryptoSuite) {\n\t\tthis._cryptoSuite = cryptoSuite;\n\t}\n\n\n\t/**\n\t * This is a factory method. It returns a new instance of the CryptoSuite API implementation, based on the \"setting\"\n\t * that is passed in, or if skipped, based on default values of the {@link CryptoSetting} properties.\n\t *\n\t * @param {CryptoSetting} setting Optional\n\t * @returns {module:api.CryptoSuite} a new instance of the CryptoSuite API implementation\n\t */\n\tstatic newCryptoSuite(setting) {\n\t\treturn sdkUtils.newCryptoSuite(setting);\n\t}\n\n\t/**\n\t * Set the enrollment object for this User instance\n\t *\n\t * @async\n\t * @param {module:api.Key} privateKey the private key object\n\t * @param {string} certificate the PEM-encoded string of certificate\n\t * @param {string} mspId The Member Service Provider id for the local signing identity\n\t * @returns {Promise} Promise for successful completion of creating the user's signing Identity\n\t */\n\tasync setEnrollment(privateKey, certificate, mspId) {\n\t\tif (typeof privateKey === 'undefined' || privateKey === null || privateKey === '') {\n\t\t\tthrow new Error('Invalid parameter. Must have a valid private key.');\n\t\t}\n\n\t\tif (typeof certificate === 'undefined' || certificate === null || certificate === '') {\n\t\t\tthrow new Error('Invalid parameter. Must have a valid certificate.');\n\t\t}\n\n\t\tif (typeof mspId === 'undefined' || mspId === null || mspId === '') {\n\t\t\tthrow new Error('Invalid parameter. Must have a valid mspId.');\n\t\t}\n\n\t\tthis._mspId = mspId;\n\n\t\tif (!this._cryptoSuite) {\n\t\t\tthis._cryptoSuite = sdkUtils.newCryptoSuite();\n\t\t\tthis._cryptoSuite.setCryptoKeyStore(sdkUtils.newCryptoKeyStore());\n\t\t}\n\n\t\tconst pubKey = await this._cryptoSuite.createKeyFromRaw(certificate);\n\t\tthis._identity = new Identity(certificate, pubKey, mspId, this._cryptoSuite);\n\t\tthis._signingIdentity = new SigningIdentity(certificate, pubKey, mspId, this._cryptoSuite, new Signer(this._cryptoSuite, privateKey));\n\t}\n\n\t/**\n\t * Determine if this name has been enrolled.\n\t * @returns {boolean} True if enrolled; otherwise, false.\n\t */\n\tisEnrolled() {\n\t\treturn this._identity !== null && this._signingIdentity !== null;\n\t}\n\n\t/**\n\t * Set the current state of this member from a string based JSON object\n\t *\n\t * @async\n\t * @param {string} str - the member state serialized\n\t * @return {Member} Promise of the unmarshalled Member object represented by the serialized string\n\t */\n\tasync fromString(str) {\n\t\tlogger.debug('fromString --start');\n\t\tconst state = JSON.parse(str);\n\n\t\tif (state.name !== this.getName()) {\n\t\t\tthrow new Error('name mismatch: \\'' + state.name + '\\' does not equal \\'' + this.getName() + '\\'');\n\t\t}\n\n\t\tthis._name = state.name;\n\t\tthis._roles = state.roles;\n\t\tthis._affiliation = state.affiliation;\n\t\tthis._enrollmentSecret = state.enrollmentSecret;\n\n\t\tif (typeof state.mspid === 'undefined' || state.mspid === null || state.mspid === '') {\n\t\t\tthrow new Error('Failed to find \"mspid\" in the deserialized state object for the user. Likely due to an outdated state store.');\n\t\t}\n\t\tthis._mspId = state.mspid;\n\n\t\tif (!this._cryptoSuite) {\n\t\t\tthis._cryptoSuite = sdkUtils.newCryptoSuite();\n\t\t\tthis._cryptoSuite.setCryptoKeyStore(sdkUtils.newCryptoKeyStore());\n\t\t}\n\n\t\tconst pubKey = this._cryptoSuite.createKeyFromRaw(state.enrollment.identity.certificate);\n\n\t\tthis._identity = new Identity(state.enrollment.identity.certificate, pubKey, this._mspId, this._cryptoSuite);\n\n\t\t// during serialization (see toString() below) only the key's SKI are saved\n\t\t// swap out that for the real key from the crypto provider\n\t\tconst privateKey = await this._cryptoSuite.getKey(state.enrollment.signingIdentity);\n\n\t\t// the key retrieved from the key store using the SKI could be a public key\n\t\t// or a private key, check to make sure it's a private key\n\t\tif (privateKey && privateKey.isPrivate()) {\n\t\t\tthis._signingIdentity = new SigningIdentity(\n\t\t\t\tstate.enrollment.identity.certificate,\n\t\t\t\tpubKey,\n\t\t\t\tthis._mspId,\n\t\t\t\tthis._cryptoSuite,\n\t\t\t\tnew Signer(this._cryptoSuite, privateKey));\n\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new Error(`Private key missing from key store. Can not establish the signing identity for user ${state.name}`);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a {@link User} object with signing identities based on the\n\t * private key and the corresponding x509 certificate. This allows applications\n\t * to use pre-existing crypto materials (private keys and certificates) to\n\t * construct user objects with signing capabilities, as an alternative to\n\t * dynamically enrolling users with [fabric-ca]{@link http://hyperledger-fabric-ca.readthedocs.io/en/latest/}\n\t *\n\t * @async\n\t * @param {UserOpts} opts - Essential information about the user\n\t * @returns {User} the user object.\n\t */\n\tstatic createUser(name = check('name'), password, mspid = check('mspid'), signedCertPEM = check('signedCertPEM'), privateKeyPEM) {\n\t\tlogger.debug('createUser %s', name);\n\t\tconst cryptoSuite = sdkUtils.newCryptoSuite();\n\t\tlet privateKey = null;\n\t\tif (privateKeyPEM) {\n\t\t\tprivateKey = cryptoSuite.createKeyFromRaw(privateKeyPEM.toString());\n\t\t}\n\t\tconst pubKey = cryptoSuite.createKeyFromRaw(signedCertPEM.toString());\n\t\tconst user = new User(name);\n\t\tuser._enrollmentSecret = password;\n\t\tuser._cryptoSuite = cryptoSuite;\n\t\tuser._mspId = mspid;\n\t\tuser._identity = new Identity(signedCertPEM, pubKey, mspid, cryptoSuite);\n\t\tif (privateKey) {\n\t\t\tuser._signingIdentity = new SigningIdentity(signedCertPEM, pubKey, mspid, cryptoSuite, new Signer(cryptoSuite, privateKey));\n\t\t}\n\n\t\treturn user;\n\t}\n\n\t/**\n\t * Save the current state of this member as a string\n\t * @return {string} The state of this member as a string\n\t */\n\ttoString() {\n\t\tconst serializedEnrollment = {};\n\t\tif (this._signingIdentity) {\n\t\t\tserializedEnrollment.signingIdentity = this._signingIdentity._signer._key.getSKI();\n\t\t}\n\n\t\tif (this._identity) {\n\t\t\tserializedEnrollment.identity = {\n\t\t\t\tcertificate: this._identity._certificate\n\t\t\t};\n\t\t}\n\n\t\tconst state = {\n\t\t\tname: this._name,\n\t\t\tmspid: this._mspId,\n\t\t\troles: this._roles,\n\t\t\taffiliation: this._affiliation,\n\t\t\tenrollmentSecret: this._enrollmentSecret,\n\t\t\tenrollment: serializedEnrollment\n\t\t};\n\n\t\treturn JSON.stringify(state);\n\t}\n\n\tstatic isInstance(object) {\n\t\treturn (typeof object._name !== 'undefined' &&\n\t\t\ttypeof object._roles !== 'undefined' &&\n\t\t\ttypeof object._affiliation !== 'undefined' &&\n\t\t\ttypeof object._enrollmentSecret !== 'undefined' &&\n\t\t\ttypeof object._identity !== 'undefined' &&\n\t\t\ttypeof object._signingIdentity !== 'undefined' &&\n\t\t\ttypeof object._mspId !== 'undefined' &&\n\t\t\ttypeof object._cryptoSuite !== 'undefined');\n\t}\n};\n\nmodule.exports = User;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}