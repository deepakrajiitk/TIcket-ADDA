{"ast":null,"code":"/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Abstract class for a suite of crypto algorithms used by the SDK to perform digital signing,\n * encryption/decryption and secure hashing. A complete suite includes support for asymmetric\n * keys (such as ECDSA or RSA), symmetric keys (such as AES) and secure hash (such as\n * SHA2/3).\n *\n * The SDK provides a default implementation based on ECDSA + SHA2/3. An alternative\n * implementation can be specified using the \"crypto-suite-software\" configuration setting, pointing\n * to a full require() path to the package for the module.\n *\n * @class\n */\nclass CryptoSuite {\n  /**\n   * Generate a key using the options in <code>opts</code> and persist it in the key store as PEM files that can be\n   * retrieved using the <code>getKey()</code> method\n   * @abstract\n   * @async\n   * @param {KeyOpts} opts Optional\n   * @returns {Promise<module:api.Key>} Promise for an instance of the Key class\n   */\n  generateKey(opts) {\n    throw new Error('Unimplemented abstract method');\n  }\n\n  /**\n   * Generate an ephemeral key.\n   * @abstract\n   * @returns {module:api.Key} An instance of the Key class\n   */\n  generateEphemeralKey() {\n    throw new Error('Unimplemented abstract method');\n  }\n\n  /**\n   * Derives the new private key from the source public key using the parameters passed in the <code>opts</code>.\n   * This operation is needed for deriving private keys corresponding to the Transaction Certificates.\n   * @abstract\n   * @param {module:api.Key} key The source key\n   * @param {KeyOpts} opts Optional\n   * @returns {module:api.Key} Derived key\n   */\n  deriveKey(key, opts) {}\n\n  /**\n   * Creates a {@link Key} from its raw representation\n   * @abstract\n   * @param {*} pem PEM string of the key to create\n   * @param {KeyOpts} opts Options for the concrete implementation\n   * @returns {module:api.Key} The created key\n   */\n  createKeyFromRaw(pem, opts) {\n    throw new Error('Unimplemented abstract method');\n  }\n\n  /**\n   * Imports a {@link Key} from its raw representation using <code>opts</code> to the key store as PEM files that can be\n   * retrieved using the 'getKey()' method\n   * @abstract\n   * @async\n   * @param {string} pem PEM string of the key to import\n   * @param {KeyOpts} opts Options for the concrete implementation\n   * @returns {Promise<module:api.Key>} returns an instance of the Key class that was persisted.\n   */\n  importKey(pem, opts) {\n    throw new Error('Unimplemented abstract method');\n  }\n\n  /**\n   * Returns the {@link Key} this implementation associates to the Subject Key Identifier ski.\n   * @abstract\n   * @param {string} ski Subject Key Identifier specific to a Crypto Suite implementation, as the\n   *    unique index to represent the key\n   * @returns {module:api.Key} Promise of an instance of the Key class corresponding to the ski\n   */\n  getKey(ski) {}\n\n  /**\n   * Returns the key size this implementation uses when generating new keys.\n   *\n   * @returns {number} key size\n   */\n  getKeySize() {\n    return this._keySize;\n  }\n\n  /**\n   * Produce a hash of the message <code>msg</code> using options <code>opts</code>\n   * @abstract\n   * @param {string} msg Source message to be hashed\n   * @param {Object} opts\n   *      algorithm: an identifier for the algorithm to be used, such as \"SHA3\"\n   * @returns {string} The hashed digest in hexidecimal string encoding\n   */\n  hash(msg, opts) {}\n\n  /**\n   * Signs digest using key. The opts argument should be appropriate for the algorithm used.\n   * @abstract\n   * @param {module:api.Key} key Signing key (private key)\n   * @param {byte[]} digest The message digest to be signed. Note that when a\n   * signature of a larger message is needed, the caller is responsible\n   * for hashing the larger message and passing the hash (as digest) to sign.\n   * @returns {byte[]} the resulting signature\n   */\n  sign(key, digest) {}\n\n  /**\n   * Verifies signature against key and digest\n   * @abstract\n   * @param {module:api.Key} key Signing verification key (public key)\n   * @param {byte[]} signature The signature to verify\n   * @param {byte[]} digest The digest that the signature was created for\n   * @returns {boolean} true if the signature verifies successfully\n   */\n  verify(key, signature, digest) {}\n\n  /**\n   * Encrypts plaintext using key.\n   * The opts argument should be appropriate for the algorithm used.\n   * @abstract\n   * @param {module:api.Key} key Encryption key (public key)\n   * @param {byte[]} plainText Plain text to encrypt\n   * @param {Object} opts Encryption options\n   * @returns {byte[]} Cipher text after encryption\n   */\n  encrypt(key, plaintext, opts) {}\n\n  /**\n   * Decrypts ciphertext using key.\n   * The opts argument should be appropriate for the algorithm used.\n   * @abstract\n   * @param {module:api.Key} key Decryption key (private key)\n   * @param {byte[]} cipherText Cipher text to decrypt\n   * @param {Object} opts Decrypt options\n   * @returns {byte[]} Plain text after decryption\n   */\n  decrypt(key, ciphertext, opts) {}\n\n  /**\n   * Set the cryptoKeyStore.\n   *\n   * When the application needs to use a key store other than the default,\n   * it should use the {@link Client} newCryptoKeyStore to create an instance and\n   * use this function to set the instance on the CryptoSuite.\n   * @abstract\n   * @param {CryptoKeyStore} cryptoKeyStore The cryptoKeyStore.\n   * @abstract\n   */\n  setCryptoKeyStore(cryptoKeyStore) {\n    throw new Error('Can\\'t call abstract method, must be implemented by sub-class!');\n  }\n}\nmodule.exports = CryptoSuite;","map":{"version":3,"names":["CryptoSuite","generateKey","opts","Error","generateEphemeralKey","deriveKey","key","createKeyFromRaw","pem","importKey","getKey","ski","getKeySize","_keySize","hash","msg","sign","digest","verify","signature","encrypt","plaintext","decrypt","ciphertext","setCryptoKeyStore","cryptoKeyStore","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/CryptoSuite.js"],"sourcesContent":["/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Abstract class for a suite of crypto algorithms used by the SDK to perform digital signing,\n * encryption/decryption and secure hashing. A complete suite includes support for asymmetric\n * keys (such as ECDSA or RSA), symmetric keys (such as AES) and secure hash (such as\n * SHA2/3).\n *\n * The SDK provides a default implementation based on ECDSA + SHA2/3. An alternative\n * implementation can be specified using the \"crypto-suite-software\" configuration setting, pointing\n * to a full require() path to the package for the module.\n *\n * @class\n */\nclass CryptoSuite {\n\n\t/**\n\t * Generate a key using the options in <code>opts</code> and persist it in the key store as PEM files that can be\n\t * retrieved using the <code>getKey()</code> method\n\t * @abstract\n\t * @async\n\t * @param {KeyOpts} opts Optional\n\t * @returns {Promise<module:api.Key>} Promise for an instance of the Key class\n\t */\n\tgenerateKey(opts) {\n\t\tthrow new Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Generate an ephemeral key.\n\t * @abstract\n\t * @returns {module:api.Key} An instance of the Key class\n\t */\n\tgenerateEphemeralKey() {\n\t\tthrow new Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Derives the new private key from the source public key using the parameters passed in the <code>opts</code>.\n\t * This operation is needed for deriving private keys corresponding to the Transaction Certificates.\n\t * @abstract\n\t * @param {module:api.Key} key The source key\n\t * @param {KeyOpts} opts Optional\n\t * @returns {module:api.Key} Derived key\n\t */\n\tderiveKey(key, opts) {\n\t}\n\n\t/**\n\t * Creates a {@link Key} from its raw representation\n\t * @abstract\n\t * @param {*} pem PEM string of the key to create\n\t * @param {KeyOpts} opts Options for the concrete implementation\n\t * @returns {module:api.Key} The created key\n\t */\n\tcreateKeyFromRaw(pem, opts) {\n\t\tthrow new Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Imports a {@link Key} from its raw representation using <code>opts</code> to the key store as PEM files that can be\n\t * retrieved using the 'getKey()' method\n\t * @abstract\n\t * @async\n\t * @param {string} pem PEM string of the key to import\n\t * @param {KeyOpts} opts Options for the concrete implementation\n\t * @returns {Promise<module:api.Key>} returns an instance of the Key class that was persisted.\n\t */\n\timportKey(pem, opts) {\n\t\tthrow new Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Returns the {@link Key} this implementation associates to the Subject Key Identifier ski.\n\t * @abstract\n\t * @param {string} ski Subject Key Identifier specific to a Crypto Suite implementation, as the\n\t *    unique index to represent the key\n\t * @returns {module:api.Key} Promise of an instance of the Key class corresponding to the ski\n\t */\n\tgetKey(ski) {\n\t}\n\n\t/**\n\t * Returns the key size this implementation uses when generating new keys.\n\t *\n\t * @returns {number} key size\n\t */\n\tgetKeySize() {\n\t\treturn this._keySize;\n\t}\n\n\t/**\n\t * Produce a hash of the message <code>msg</code> using options <code>opts</code>\n\t * @abstract\n\t * @param {string} msg Source message to be hashed\n\t * @param {Object} opts\n\t *      algorithm: an identifier for the algorithm to be used, such as \"SHA3\"\n\t * @returns {string} The hashed digest in hexidecimal string encoding\n\t */\n\thash(msg, opts) {\n\t}\n\n\t/**\n\t * Signs digest using key. The opts argument should be appropriate for the algorithm used.\n\t * @abstract\n\t * @param {module:api.Key} key Signing key (private key)\n\t * @param {byte[]} digest The message digest to be signed. Note that when a\n\t * signature of a larger message is needed, the caller is responsible\n\t * for hashing the larger message and passing the hash (as digest) to sign.\n\t * @returns {byte[]} the resulting signature\n\t */\n\tsign(key, digest) {\n\t}\n\n\t/**\n\t * Verifies signature against key and digest\n\t * @abstract\n\t * @param {module:api.Key} key Signing verification key (public key)\n\t * @param {byte[]} signature The signature to verify\n\t * @param {byte[]} digest The digest that the signature was created for\n\t * @returns {boolean} true if the signature verifies successfully\n\t */\n\tverify(key, signature, digest) {\n\t}\n\n\t/**\n\t * Encrypts plaintext using key.\n\t * The opts argument should be appropriate for the algorithm used.\n\t * @abstract\n\t * @param {module:api.Key} key Encryption key (public key)\n\t * @param {byte[]} plainText Plain text to encrypt\n\t * @param {Object} opts Encryption options\n\t * @returns {byte[]} Cipher text after encryption\n\t */\n\tencrypt(key, plaintext, opts) {\n\t}\n\n\t/**\n\t * Decrypts ciphertext using key.\n\t * The opts argument should be appropriate for the algorithm used.\n\t * @abstract\n\t * @param {module:api.Key} key Decryption key (private key)\n\t * @param {byte[]} cipherText Cipher text to decrypt\n\t * @param {Object} opts Decrypt options\n\t * @returns {byte[]} Plain text after decryption\n\t */\n\tdecrypt(key, ciphertext, opts) {\n\t}\n\n\t/**\n\t * Set the cryptoKeyStore.\n\t *\n\t * When the application needs to use a key store other than the default,\n\t * it should use the {@link Client} newCryptoKeyStore to create an instance and\n\t * use this function to set the instance on the CryptoSuite.\n\t * @abstract\n\t * @param {CryptoKeyStore} cryptoKeyStore The cryptoKeyStore.\n\t * @abstract\n\t */\n\tsetCryptoKeyStore(cryptoKeyStore) {\n\t\tthrow new Error('Can\\'t call abstract method, must be implemented by sub-class!');\n\t}\n}\n\nmodule.exports = CryptoSuite;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,WAAW,CAAC;EAEjB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAACC,IAAI,EAAE;IACjB,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;EACjD;;EAEA;AACD;AACA;AACA;AACA;EACCC,oBAAoBA,CAAA,EAAG;IACtB,MAAM,IAAID,KAAK,CAAC,+BAA+B,CAAC;EACjD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCE,SAASA,CAACC,GAAG,EAAEJ,IAAI,EAAE,CACrB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCK,gBAAgBA,CAACC,GAAG,EAAEN,IAAI,EAAE;IAC3B,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;EACjD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCM,SAASA,CAACD,GAAG,EAAEN,IAAI,EAAE;IACpB,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;EACjD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCO,MAAMA,CAACC,GAAG,EAAE,CACZ;;EAEA;AACD;AACA;AACA;AACA;EACCC,UAAUA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,QAAQ;EACrB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,IAAIA,CAACC,GAAG,EAAEb,IAAI,EAAE,CAChB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCc,IAAIA,CAACV,GAAG,EAAEW,MAAM,EAAE,CAClB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,MAAMA,CAACZ,GAAG,EAAEa,SAAS,EAAEF,MAAM,EAAE,CAC/B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCG,OAAOA,CAACd,GAAG,EAAEe,SAAS,EAAEnB,IAAI,EAAE,CAC9B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCoB,OAAOA,CAAChB,GAAG,EAAEiB,UAAU,EAAErB,IAAI,EAAE,CAC/B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCsB,iBAAiBA,CAACC,cAAc,EAAE;IACjC,MAAM,IAAItB,KAAK,CAAC,gEAAgE,CAAC;EAClF;AACD;AAEAuB,MAAM,CAACC,OAAO,GAAG3B,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}