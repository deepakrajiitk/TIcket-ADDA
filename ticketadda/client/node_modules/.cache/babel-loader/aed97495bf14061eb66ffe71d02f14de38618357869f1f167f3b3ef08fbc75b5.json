{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = require(\"os\");\nconst load_balancer_1 = require(\"./load-balancer\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n  if (!('service' in obj) || typeof obj.service !== 'string') {\n    throw new Error('Invalid method config name: invalid service');\n  }\n  const result = {\n    service: obj.service\n  };\n  if ('method' in obj) {\n    if (typeof obj.method === 'string') {\n      result.method = obj.method;\n    } else {\n      throw new Error('Invalid method config name: invalid method');\n    }\n  }\n  return result;\n}\nfunction validateMethodConfig(obj) {\n  var _a;\n  const result = {\n    name: []\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (!('seconds' in obj.timeout) || !(typeof obj.timeout.seconds === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (!('nanos' in obj.timeout) || !(typeof obj.timeout.nanos === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (typeof obj.timeout === 'string' && TIMEOUT_REGEX.test(obj.timeout)) {\n      const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  return result;\n}\nfunction validateServiceConfig(obj) {\n  const result = {\n    loadBalancingConfig: [],\n    methodConfig: []\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  // Validate method name uniqueness\n  const seenMethodNames = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (name.service === seenName.service && name.method === seenName.method) {\n          throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig)\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (typeof obj.percentage === 'number' && 0 <= obj.percentage && obj.percentage <= 100) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = ['clientLanguage', 'percentage', 'clientHostname', 'serviceConfig'];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(`Invalid service config choice: unexpected field ${field}`);\n    }\n  }\n  return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (typeof validatedConfig.percentage === 'number' && percentage > validatedConfig.percentage) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;","map":{"version":3,"names":["os","require","load_balancer_1","TIMEOUT_REGEX","CLIENT_LANGUAGE_STRING","validateName","obj","service","Error","result","method","validateMethodConfig","name","Array","isArray","push","waitForReady","timeout","seconds","nanos","test","timeoutParts","substring","length","split","_a","maxRequestBytes","maxResponseBytes","validateServiceConfig","loadBalancingConfig","methodConfig","loadBalancingPolicy","config","validateLoadBalancingConfig","seenMethodNames","seenName","exports","validateCanaryConfig","serviceConfig","clientLanguage","lang","clientHostname","percentage","allowedFields","field","includes","validateAndSelectCanaryConfig","validatedConfig","hostnameMatched","hostname","languageMatched","language","extractAndSelectServiceConfig","txtRecord","record","startsWith","recordString","join","recordJson","JSON","parse"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/service-config.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as os from 'os';\nimport { Duration } from './duration';\nimport {\n  LoadBalancingConfig,\n  validateLoadBalancingConfig,\n} from './load-balancer';\n\nexport interface MethodConfigName {\n  service: string;\n  method?: string;\n}\n\nexport interface MethodConfig {\n  name: MethodConfigName[];\n  waitForReady?: boolean;\n  timeout?: Duration;\n  maxRequestBytes?: number;\n  maxResponseBytes?: number;\n}\n\nexport interface ServiceConfig {\n  loadBalancingPolicy?: string;\n  loadBalancingConfig: LoadBalancingConfig[];\n  methodConfig: MethodConfig[];\n}\n\nexport interface ServiceConfigCanaryConfig {\n  clientLanguage?: string[];\n  percentage?: number;\n  clientHostname?: string[];\n  serviceConfig: ServiceConfig;\n}\n\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\n\nfunction validateName(obj: any): MethodConfigName {\n  if (!('service' in obj) || typeof obj.service !== 'string') {\n    throw new Error('Invalid method config name: invalid service');\n  }\n  const result: MethodConfigName = {\n    service: obj.service,\n  };\n  if ('method' in obj) {\n    if (typeof obj.method === 'string') {\n      result.method = obj.method;\n    } else {\n      throw new Error('Invalid method config name: invalid method');\n    }\n  }\n  return result;\n}\n\nfunction validateMethodConfig(obj: any): MethodConfig {\n  const result: MethodConfig = {\n    name: [],\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (\n        !('seconds' in obj.timeout) ||\n        !(typeof obj.timeout.seconds === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (\n        !('nanos' in obj.timeout) ||\n        !(typeof obj.timeout.nanos === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (\n      typeof obj.timeout === 'string' &&\n      TIMEOUT_REGEX.test(obj.timeout)\n    ) {\n      const timeoutParts = obj.timeout\n        .substring(0, obj.timeout.length - 1)\n        .split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: (timeoutParts[1] ?? 0) | 0,\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  return result;\n}\n\nexport function validateServiceConfig(obj: any): ServiceConfig {\n  const result: ServiceConfig = {\n    loadBalancingConfig: [],\n    methodConfig: [],\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  // Validate method name uniqueness\n  const seenMethodNames: MethodConfigName[] = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (\n          name.service === seenName.service &&\n          name.method === seenName.method\n        ) {\n          throw new Error(\n            `Invalid service config: duplicate name ${name.service}/${name.method}`\n          );\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\n\nfunction validateCanaryConfig(obj: any): ServiceConfigCanaryConfig {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result: ServiceConfigCanaryConfig = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig),\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientLanguage'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientHostname'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (\n      typeof obj.percentage === 'number' &&\n      0 <= obj.percentage &&\n      obj.percentage <= 100\n    ) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = [\n    'clientLanguage',\n    'percentage',\n    'clientHostname',\n    'serviceConfig',\n  ];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(\n        `Invalid service config choice: unexpected field ${field}`\n      );\n    }\n  }\n  return result;\n}\n\nfunction validateAndSelectCanaryConfig(\n  obj: any,\n  percentage: number\n): ServiceConfig {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (\n      typeof validatedConfig.percentage === 'number' &&\n      percentage > validatedConfig.percentage\n    ) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nexport function extractAndSelectServiceConfig(\n  txtRecord: string[][],\n  percentage: number\n): ServiceConfig | null {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson: any = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}