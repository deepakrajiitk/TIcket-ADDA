{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'EventListener';\nconst {\n  checkParameter,\n  getLogger,\n  convertToLong\n} = require('./Utils.js');\nconst logger = getLogger(TYPE);\nconst default_unregister = {\n  block: false,\n  tx: true,\n  chaincode: false\n};\n\n/**\n * The EventListener is used internally to the EventService to hold\n * an event registration callback and settings.\n * @private\n */\nclass EventListener {\n  /**\n   * @typedef {Object} RegistrationOpts\n   * @property {number|string|Long} [startBlock] - Optional. The starting block number\n   * for event checking. When included, the peer's event service\n   * will be asked to start sending blocks from this block number.\n   * This is how to resume or replay missed blocks that were added\n   * to the ledger.\n   * Default is the latest block on the ledger.\n   * @property {number|string|Long} [endBlock] - Optional. The ending block number\n   * for event checking.\n   * When included, the peer's event service will be asked to stop sending blocks once this block is delivered.\n   * This is how to replay missed blocks that were added to the ledger.\n   * When a startBlock is not included, the endBlock must be equal to or larger than the current channel block height.\n   * @property {boolean} unregister - Optional - This options setting indicates\n   * the registration should be removed (unregister) when the event\n   * is seen. When the application is using a timeout to wait a\n   * specified amount of time for the transaction to be seen, the timeout\n   * processing should included the manual 'unregister' of the transaction\n   * event listener to avoid the event callbacks being called unexpectedly.\n   * The default for this setting is different for the different types of\n   * event listeners. For block listeners the default is true, however\n   * the event listener is assumed to have seen the final event only if\n   * the end_block was set as a option and that end_block was seen by the\n   * the listener. For transaction listeners the default is true and the\n   * listener will be unregistered when a transaction with the id is\n   * seen by this listener. For chaincode listeners the default will be\n   * false as the match filter might be intended for many transactions\n   * rather than a specific transaction or block as in the other listeners.\n   * For all listeners if not set and the endBlock has been set, the listener\n   * will be automatically unregistered.\n   */\n\n  /**\n   * Constructs a Event Listener\n   * @param {EventService} eventService - The EventService where this listener is registered\n   * @param {string} listenerType - a string to indicate the type of event registration\n   *  \"block\", \"tx\", or \"chaincode\".\n   * @param {function} callback - Callback for event matches\n   * @param {RegistrationOpts} options - event registration options\n   * @param {RegExp|string} [event]\n   *  <br>- When this listener is of type \"block\" then this field is not used.\n   *  <br>- When this listener is of type \"chaincode\" then this\n   *  field will be the chaincode event name, used as a regular\n   *  expression match on the chaincode event name within the transactions.\n   *  <br>- When this listener is of type \"tx\" then this field will be the\n   *  transaction id string.\n   *  In both cases this field will be compared with data in the transaction.\n   *  And when there is a match the event will have taken place and the listener's callback will be called (notified).\n   * @param {string} [chaincodeId] - optional. Used to isolate chaincode events\n   *  to a specific chaincode.\n   * @private\n   */\n  constructor() {\n    let eventService = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('eventService');\n    let listenerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('listenerType');\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : checkParameter('callback');\n    let options = arguments.length > 3 ? arguments[3] : undefined;\n    let event = arguments.length > 4 ? arguments[4] : undefined;\n    let chaincodeId = arguments.length > 5 ? arguments[5] : undefined;\n    this.eventService = eventService;\n    this.type = TYPE;\n    this.listenerType = listenerType;\n    if (listenerType === EventListener.TX && !event) {\n      checkParameter('event');\n    } else if (listenerType === EventListener.CHAINCODE && !event) {\n      checkParameter('event');\n    }\n    this.callback = callback;\n    if (!options) {\n      options = {};\n    }\n    this.unregister = typeof options.unregister === 'boolean' ? options.unregister : default_unregister[listenerType];\n    this.endBlock = convertToLong(options.endBlock, false);\n    this.startBlock = convertToLong(options.startBlock, false);\n    this.event = event;\n    this.chaincodeId = chaincodeId;\n  }\n\n  /**\n   * This method will be called by the {@link EventService} when it finds a\n   * block that matches this event listener.\n   * This method will also be called by the {@link EventService} when the\n   * connection to the Peer's event service has received an error or\n   * shutdown. This method will call the defined callback with the\n   * event information or error instance.\n   * @param {Error} error - An Error object that was created as a result\n   *  of an error on the {@link EventService} connection to the Peer.\n   * @param {EventInfo} event - A {@link EventInfo} that contains event information.\n   * @private\n   */\n  onEvent(error, event) {\n    const method = 'onEvent';\n    try {\n      let notify = true;\n      if (event) {\n        if (this.endBlock && event.blockNumber.greaterThan(this.endBlock)) {\n          logger.debug(`${method} - skipping calling callback, event block num ${event.blockNumber} greater than listener's endBlock`);\n          notify = false;\n        }\n        if (this.startBlock && event.blockNumber.lessThan(this.startBlock)) {\n          logger.debug(`${method} - skipping calling callback, event block num ${event.blockNumber} less than listener's startBlock`);\n          notify = false;\n        }\n      }\n      // notify should be true unless the start and end have prevented\n      if (notify) {\n        this.callback(error, event);\n      }\n    } catch (err) {\n      logger.error('Event notification callback failed', err);\n    }\n  }\n\n  /**\n   * Convenience method to for users to unregister this listener\n   */\n  unregisterEventListener() {\n    this.eventService.unregisterEventListener(this);\n  }\n  toString() {\n    return `EventListener: { listenerType: ${this.listenerType}, startBlock: ${this.startBlock}, endBlock: ${this.endBlock}, unregister: ${this.unregister}, event: ${this.event}}`;\n  }\n}\nmodule.exports = EventListener;\nEventListener.BLOCK = 'block'; // for block type event listeners\nEventListener.TX = 'tx'; // for transaction type event listeners\nEventListener.CHAINCODE = 'chaincode'; // for chaincode event type event listeners","map":{"version":3,"names":["TYPE","checkParameter","getLogger","convertToLong","require","logger","default_unregister","block","tx","chaincode","EventListener","constructor","eventService","arguments","length","undefined","listenerType","callback","options","event","chaincodeId","type","TX","CHAINCODE","unregister","endBlock","startBlock","onEvent","error","method","notify","blockNumber","greaterThan","debug","lessThan","err","unregisterEventListener","toString","module","exports","BLOCK"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/EventListener.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'EventListener';\n\nconst {checkParameter, getLogger, convertToLong} = require('./Utils.js');\nconst logger = getLogger(TYPE);\n\nconst default_unregister = {\n\tblock: false,\n\ttx: true,\n\tchaincode: false\n};\n\n/**\n * The EventListener is used internally to the EventService to hold\n * an event registration callback and settings.\n * @private\n */\nclass EventListener {\n\t/**\n\t * @typedef {Object} RegistrationOpts\n\t * @property {number|string|Long} [startBlock] - Optional. The starting block number\n\t * for event checking. When included, the peer's event service\n\t * will be asked to start sending blocks from this block number.\n\t * This is how to resume or replay missed blocks that were added\n\t * to the ledger.\n\t * Default is the latest block on the ledger.\n\t * @property {number|string|Long} [endBlock] - Optional. The ending block number\n\t * for event checking.\n\t * When included, the peer's event service will be asked to stop sending blocks once this block is delivered.\n\t * This is how to replay missed blocks that were added to the ledger.\n\t * When a startBlock is not included, the endBlock must be equal to or larger than the current channel block height.\n\t * @property {boolean} unregister - Optional - This options setting indicates\n\t * the registration should be removed (unregister) when the event\n\t * is seen. When the application is using a timeout to wait a\n\t * specified amount of time for the transaction to be seen, the timeout\n\t * processing should included the manual 'unregister' of the transaction\n\t * event listener to avoid the event callbacks being called unexpectedly.\n\t * The default for this setting is different for the different types of\n\t * event listeners. For block listeners the default is true, however\n\t * the event listener is assumed to have seen the final event only if\n\t * the end_block was set as a option and that end_block was seen by the\n\t * the listener. For transaction listeners the default is true and the\n\t * listener will be unregistered when a transaction with the id is\n\t * seen by this listener. For chaincode listeners the default will be\n\t * false as the match filter might be intended for many transactions\n\t * rather than a specific transaction or block as in the other listeners.\n\t * For all listeners if not set and the endBlock has been set, the listener\n\t * will be automatically unregistered.\n\t */\n\n\t/**\n\t * Constructs a Event Listener\n\t * @param {EventService} eventService - The EventService where this listener is registered\n\t * @param {string} listenerType - a string to indicate the type of event registration\n\t *  \"block\", \"tx\", or \"chaincode\".\n\t * @param {function} callback - Callback for event matches\n\t * @param {RegistrationOpts} options - event registration options\n\t * @param {RegExp|string} [event]\n\t *  <br>- When this listener is of type \"block\" then this field is not used.\n\t *  <br>- When this listener is of type \"chaincode\" then this\n\t *  field will be the chaincode event name, used as a regular\n\t *  expression match on the chaincode event name within the transactions.\n\t *  <br>- When this listener is of type \"tx\" then this field will be the\n\t *  transaction id string.\n\t *  In both cases this field will be compared with data in the transaction.\n\t *  And when there is a match the event will have taken place and the listener's callback will be called (notified).\n\t * @param {string} [chaincodeId] - optional. Used to isolate chaincode events\n\t *  to a specific chaincode.\n\t * @private\n\t */\n\tconstructor(eventService = checkParameter('eventService'), listenerType = checkParameter('listenerType'), callback = checkParameter('callback'), options, event, chaincodeId) {\n\t\tthis.eventService = eventService;\n\t\tthis.type = TYPE;\n\t\tthis.listenerType = listenerType;\n\t\tif (listenerType === EventListener.TX && !event) {\n\t\t\tcheckParameter('event');\n\t\t} else if (listenerType === EventListener.CHAINCODE && !event) {\n\t\t\tcheckParameter('event');\n\t\t}\n\t\tthis.callback = callback;\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\tthis.unregister = typeof options.unregister === 'boolean' ? options.unregister : default_unregister[listenerType];\n\t\tthis.endBlock = convertToLong(options.endBlock, false);\n\t\tthis.startBlock = convertToLong(options.startBlock, false);\n\t\tthis.event = event;\n\t\tthis.chaincodeId = chaincodeId;\n\t}\n\n\t/**\n\t * This method will be called by the {@link EventService} when it finds a\n\t * block that matches this event listener.\n\t * This method will also be called by the {@link EventService} when the\n\t * connection to the Peer's event service has received an error or\n\t * shutdown. This method will call the defined callback with the\n\t * event information or error instance.\n\t * @param {Error} error - An Error object that was created as a result\n\t *  of an error on the {@link EventService} connection to the Peer.\n\t * @param {EventInfo} event - A {@link EventInfo} that contains event information.\n\t * @private\n\t */\n\tonEvent(error, event) {\n\t\tconst method = 'onEvent';\n\t\ttry {\n\t\t\tlet notify = true;\n\t\t\tif (event) {\n\t\t\t\tif (this.endBlock && event.blockNumber.greaterThan(this.endBlock)) {\n\t\t\t\t\tlogger.debug(`${method} - skipping calling callback, event block num ${event.blockNumber} greater than listener's endBlock`);\n\t\t\t\t\tnotify = false;\n\t\t\t\t}\n\t\t\t\tif (this.startBlock && event.blockNumber.lessThan(this.startBlock)) {\n\t\t\t\t\tlogger.debug(`${method} - skipping calling callback, event block num ${event.blockNumber} less than listener's startBlock`);\n\t\t\t\t\tnotify = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// notify should be true unless the start and end have prevented\n\t\t\tif (notify) {\n\t\t\t\tthis.callback(error, event);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.error('Event notification callback failed', err);\n\t\t}\n\t}\n\n\t/**\n\t * Convenience method to for users to unregister this listener\n\t */\n\tunregisterEventListener() {\n\t\tthis.eventService.unregisterEventListener(this);\n\t}\n\n\ttoString() {\n\t\treturn `EventListener: { listenerType: ${this.listenerType}, startBlock: ${\n\t\t\tthis.startBlock}, endBlock: ${this.endBlock}, unregister: ${\n\t\t\tthis.unregister}, event: ${this.event}}`;\n\t}\n}\n\nmodule.exports = EventListener;\nEventListener.BLOCK = 'block'; // for block type event listeners\nEventListener.TX = 'tx'; // for transaction type event listeners\nEventListener.CHAINCODE = 'chaincode'; // for chaincode event type event listeners\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}