{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'EventService';\nconst Long = require('long');\nconst BlockDecoder = require('./BlockDecoder.js');\nconst {\n  checkParameter,\n  convertToLong,\n  getLogger\n} = require('./Utils.js');\nconst ServiceAction = require('./ServiceAction.js');\nconst EventListener = require('./EventListener.js');\nconst logger = getLogger(TYPE);\nconst fabproto6 = require('fabric-protos');\nconst {\n  common: {\n    Status: {\n      SUCCESS,\n      NOT_FOUND\n    }\n  }\n} = fabproto6;\n\n// Special transaction id to indicate that the transaction listener will be\n// notified of all transactions\nconst ALL = 'all';\n\n// Special values for block numbers\nconst NEWEST = 'newest'; // what fabric peer sees as newest on the ledger at time of connect\nconst OLDEST = 'oldest'; // what fabric peer sees as oldest on the ledger at time of connect\n\nconst BLOCK = EventListener.BLOCK; // for block type event listeners\nconst TX = EventListener.TX; // for transaction type event listeners\nconst CHAINCODE = EventListener.CHAINCODE; // for chaincode event type event listeners\n\n// block type is a NodeSDK concept to understand what type of gRPC message data we\n// need to work with, both in how we set up the stream and the data returned\nconst FULL_BLOCK = 'full'; // to receive full blocks\nconst FILTERED_BLOCK = 'filtered'; // to receive filtered blocks\nconst PRIVATE_BLOCK = 'private'; // to receive full blocks and private data\n\n// some info to help with debug when there are multiple eventservices running\nlet count = 1;\nlet streamCount = 1;\n\n/**\n * EventService is used to monitor for new blocks on a peer's ledger.\n * The class allows the user to register a listener to be notified when a\n * new block is added to the ledger, when a new block is added that has a\n * specific transaction ID, or to be notified when a transaction contains a\n * chaincode event name of interest.\n * The class also allows the monitoring to start and end at any specific location.\n *\n * @class\n * @extends ServiceAction\n */\n\nclass EventService extends ServiceAction {\n  /**\n   * Constructs a EventService object\n   *\n   * @param {string} name\n   * @param {Channel} channel - An instance of the Channel class\n   * were this EventService will receive blocks\n   * @returns {EventService} An instance of this class\n   */\n\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('name');\n    let channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('channel');\n    logger.debug(`${TYPE}.constructor[${name}] - start `);\n    super(name);\n    this.type = TYPE;\n    this.channel = channel;\n\n    // the last block number received\n    this.lastBlockNumber = null;\n    this.startBlock = NEWEST;\n    this.endBlock = undefined;\n    this._endBlockSeen = false;\n    this._eventListenerRegistrations = new Map();\n    this._haveBlockListeners = false;\n    this._haveTxListeners = false;\n    this._haveChaincodeListeners = false;\n\n    // peer's event service\n    this.targets = null;\n    this._currentEventer = null;\n    // closing state to case of multiple calls\n    this._closeRunning = false;\n\n    // remember the blockType this EventService is listening\n    // will be set during the .build call\n    this.blockType = FILTERED_BLOCK;\n    this.replay = false;\n    this.startSpecified = false;\n    this.myNumber = count++;\n    this.inUse = false;\n  }\n\n  /**\n   * Use this method to set the ServiceEndpoint for this ServiceAction class\n   * The {@link Eventer} a ServiceEndpoint must be connected before making\n   * this assignment.\n   * @property {Eventer[]} targets - The connected Eventer instances to\n   *  be used when no targets are provided on the send.\n   */\n  setTargets() {\n    let targets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('targets');\n    const method = `setTargets[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    if (!Array.isArray(targets)) {\n      throw Error('targets parameter is not an array');\n    }\n    if (targets.length < 1) {\n      throw Error('No targets provided');\n    }\n    for (const eventer of targets) {\n      if (eventer.isConnectable()) {\n        logger.debug('%s - target is connectable %s', method, eventer.name);\n      } else {\n        throw Error(`Eventer ${eventer.name} is not connectable`);\n      }\n    }\n    // must be all targets are connectable\n    this.targets = targets;\n    return this;\n  }\n\n  /*\n   * The block number of the last block seen\n   *\n   * @returns {Long} The block number of the last block seen\n   */\n  getLastBlockNumber() {\n    return this.lastBlockNumber;\n  }\n\n  /**\n   * Disconnects the EventService from the fabric peer service and\n   * closes all services.\n   * Will close all event listeners and send an Error to all active listeners.\n   */\n  close() {\n    const method = `close[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - hub', method);\n    this._close(new Error('EventService has been shutdown by \"close()\" call'));\n  }\n\n  /*\n   * Internal method\n   * Disconnects the connection to the fabric peer service.\n   * Will close all event listeners and send the provided `Error` to\n   * all listeners on the event callback.\n   */\n  _close() {\n    let reasonError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('reasonError');\n    const method = `_close[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - called due to %s', method, reasonError.message);\n    if (this._closeRunning) {\n      logger.debug('%s - close is running - exiting', method);\n      return;\n    }\n    this._closeRunning = true;\n    this._closeAllCallbacks(reasonError);\n    if (this._currentEventer) {\n      logger.debug('%s - have currentEventer close stream %s', method, this.currentStreamNumber);\n      this._currentEventer.disconnect();\n      this._currentEventer = null;\n    } else {\n      logger.debug('%s - no current eventer - not shutting down stream', method);\n    }\n    this._closeRunning = false;\n    this.inUse = false;\n    logger.debug('%s - end', method);\n  }\n\n  /**\n   * @typedef {Object} StartRequestOptions\n   * @property {string} [blockType] - Optional. To indicate that the event service\n   *  on the peer will be sending full blocks, filtered blocks or private data\n   *  blocks to this EventService.\n   *  The default will be 'filtered' with 'full' for full blocks and 'private'\n   *  for blocks with private data.\n   *  Filtered blocks have the required information to provided transaction\n   *  status and chaincode event names, however no chaincode event payload.\n   *  When using the non filtered blocks (full blocks or private data) the user\n   *  will be required to have access to receive full blocks and the private data.\n   *  Registering a block listener when listening for filtered blocks may not\n   *  provide sufficient information in the blocks received.\n   * @property {Number | string} [startBlock] - Optional. This will have the service\n   *  setup to start sending blocks back to the event hub at the block\n   *  with this number.\n   *  If the service should start with the last block this instance\n   *  has seen use the string 'last_seen'.\n   *  If the service should start with the oldest block on the\n   *  ledger use the string 'oldest'.\n   *  If the service should start with the latest block on the ledger,\n   *  use the string 'latest' or do not include a 'startBlock'.\n   *  Default is to start with the latest block on the ledger.\n   * @property {Number | string} [endBlock] - Optional. This will have the service\n   *  setup to end sending blocks back to the event hub at the block\n   *  with this number.\n   *  If the service should end with the last block it has seen\n   *  use the string 'last_seen'.\n   *  If the service should end with the current block on the\n   *  ledger use the string 'newest'.\n   *  Default is to continue to send.\n   */\n\n  /**\n   * This method is used to build the protobuf objects of the start request.\n   * The start request must next be signed before being sent to the peer's event service.\n   * The {@link Proposal#buildAndSignStartRequest} method should be used if the\n   * signing will be done by the application.\n   *\n   * @param {IdentityContext} idContext - The transaction context to use for\n   *  Identity, transaction ID, and nonce values\n   * @param {StartRequestOptions} options - The build\n   * @returns {byte[]} The start request bytes that need to be\n   *  signed.\n   */\n  build() {\n    let idContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('idContext');\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = `build[${this.name}] - #${this.myNumber}`;\n    logger.debug(`${method} - start`);\n    this.inUse = true;\n    const {\n      startBlock,\n      endBlock,\n      blockType = FILTERED_BLOCK\n    } = options;\n    this.startBlock = this._checkBlockNum(startBlock);\n    this.endBlock = this._checkBlockNum(endBlock);\n\n    // when they are both Longs\n    if (this.startBlock && this.endBlock && this.endBlock.greaterThan && this.startBlock.greaterThan) {\n      if (this.startBlock.greaterThan(this.endBlock)) {\n        throw Error('\"startBlock\" must not be greater than \"endBlock\"');\n      }\n    }\n    if (typeof blockType === 'string') {\n      if (blockType === FULL_BLOCK || blockType === FILTERED_BLOCK || blockType === PRIVATE_BLOCK) {\n        this.blockType = blockType;\n      } else {\n        throw Error(`Invalid blockType ${blockType}`);\n      }\n    } else {\n      throw Error('\"blockType must be a string');\n    }\n    this._payload = null;\n    idContext.calculateTransactionId();\n\n    // BLOCK_UNTIL_READY will mean hold the stream open and keep sending as\n    //    the blocks come in\n    // FAIL_IF_NOT_READY will mean if the block is not there throw an error\n    let behavior = fabproto6.orderer.SeekInfo.SeekBehavior.BLOCK_UNTIL_READY;\n\n    // build start proto\n    const seekStart = fabproto6.orderer.SeekPosition.create();\n    if (!this.startBlock || this.startBlock === NEWEST) {\n      if (this.endBlock === OLDEST) {\n        throw Error('\"startBlock\" must not be greater than \"endBlock\"');\n      }\n      seekStart.newest = fabproto6.orderer.SeekNewest.create();\n    } else if (this.startBlock === OLDEST) {\n      seekStart.oldest = fabproto6.orderer.SeekOldest.create();\n      this.replay = true;\n    } else if (this.startBlock) {\n      seekStart.specified = fabproto6.orderer.SeekSpecified.create({\n        number: this.startBlock\n      });\n      this.replay = true;\n      this.startSpecified = true;\n    }\n\n    // build stop proto\n    const seekStop = fabproto6.orderer.SeekPosition.create();\n    if (this.endBlock === NEWEST) {\n      seekStop.newest = fabproto6.orderer.SeekNewest.create();\n      behavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n      this.replay = true;\n    } else if (this.endBlock === OLDEST) {\n      seekStop.oldest = fabproto6.orderer.SeekOldest.create();\n      behavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n      this.replay = true;\n    } else {\n      const seekSpecifiedStop = fabproto6.orderer.SeekSpecified.create();\n      if (this.endBlock) {\n        seekSpecifiedStop.number = this.endBlock;\n        // user should be told that the block does not exist\n        behavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n        this.replay = true;\n      } else {\n        seekSpecifiedStop.number = Long.MAX_VALUE;\n      }\n      seekStop.specified = seekSpecifiedStop;\n    }\n\n    // seek info with all parts\n    const seekInfo = fabproto6.orderer.SeekInfo.create({\n      start: seekStart,\n      stop: seekStop,\n      behavior: behavior\n    });\n    const seekInfoBuf = fabproto6.orderer.SeekInfo.encode(seekInfo).finish();\n\n    // build the header for use with the seekInfo payload\n    const channelHeaderBuf = this.channel.buildChannelHeader(fabproto6.common.HeaderType.DELIVER_SEEK_INFO, '', idContext.transactionId);\n    const seekPayload = fabproto6.common.Payload.create({\n      header: this.buildHeader(idContext, channelHeaderBuf),\n      data: seekInfoBuf\n    });\n    this._payload = fabproto6.common.Payload.encode(seekPayload).finish();\n    logger.debug(`${method} - end`);\n    return this._payload;\n  }\n\n  /**\n   * @typedef {Object} StartEventRequest\n   * @property {Eventer[]} targets - The Eventers to send the start stream request.\n   * @property {Number} [requestTimeout] - Optional. The request timeout\n   */\n\n  /**\n   * This method will have this events start listening for blocks from the\n   * Peer's event service. It will send a Deliver request to the peer\n   * event service and start the grpc streams. The received blocks will\n   * be checked to see if there is a match to any of the registered\n   * listeners.\n   *\n   * @param {StartEventRequest} request - The request options to start the\n   *  stream to the event service.\n   */\n  async send() {\n    let request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const method = `send[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    const {\n      targets,\n      requestTimeout\n    } = request;\n    if (targets && Array.isArray(targets) && targets.length > 0) {\n      this.targets = targets;\n      logger.debug('%s - using user assigned targets', method);\n    } else if (this.targets) {\n      logger.debug('%s - using preassigned targets', method);\n    } else {\n      checkParameter('targets');\n    }\n    const envelope = this.getSignedEnvelope();\n    this._currentEventer = null;\n    let startError = null;\n    this._endBlockSeen = false;\n    for (const target of this.targets) {\n      try {\n        if (target.stream) {\n          logger.debug('%s - target has a stream, is already listening %s', method, target.toString());\n          startError = Error(`Event service ${target.name} is currently listening`);\n        } else {\n          const isConnected = await target.checkConnection();\n          if (!isConnected) {\n            startError = Error(`Event service ${target.name} is not connected`);\n            logger.debug('%s - target is not connected %s', method, target.toString());\n          } else {\n            this._currentEventer = await this._startService(target, envelope, requestTimeout);\n            logger.debug('%s - set current eventer %s', method, this._currentEventer.toString());\n          }\n        }\n      } catch (error) {\n        logger.error('%s - Starting stream to %s failed', method, target.name);\n        startError = error;\n      }\n\n      // let see how we did with this target\n      if (this._currentEventer) {\n        // great, it will be the one we use, stop looking\n        startError = null;\n        break;\n      }\n    }\n\n    // if we ran through the all targets and have startError then we\n    // have not found a working target endpoint, so tell user error\n    if (startError) {\n      logger.error('%s - no targets started - %s', method, startError);\n      throw startError;\n    }\n    logger.debug('%s - end', method);\n  }\n\n  /*\n   * internal method to startup a stream and bind this event hub's callbacks\n   * to a specific target's gRPC stream\n   */\n  _startService(eventer, envelope, requestTimeout) {\n    const me = `[${this.name}] - #${this.myNumber}`;\n    const method = `_startService${me}`;\n    logger.debug('%s - start', method);\n    return new Promise((resolve, reject) => {\n      if (!requestTimeout) {\n        requestTimeout = eventer.endpoint.options.requestTimeout;\n      }\n      logger.debug('%s - setup timer %s', method, requestTimeout);\n      logger.debug('%s - create stream setup timeout', method);\n      const connectionSetupTimeout = setTimeout(() => {\n        // this service may be waiting for a start block that has not happened\n        if (this.startSpecified) {\n          logger.debug(`EventService[${this.name}] timed out after:${requestTimeout}`);\n          logger.debug(`EventService[${this.name}] not stopping service, wait indefinitely`);\n          // resolve the promise as if we did get a good response from the peer, since we did\n          // not get an \"end\" or \"error\" back indicating that the request was invalid\n          // application should have a timer just in case this peer never gets this block\n          resolve(eventer);\n        } else {\n          logger.error(`EventService[${this.name}] timed out after:${requestTimeout}`);\n          reject(Error('Event service timed out - Unable to start listening'));\n        }\n      }, requestTimeout);\n      eventer.setStreamByType(this.blockType);\n\n      // the promise and streams live on and we need\n      // to check at times to be sure we are working with the\n      // correct one if the target gets restarted\n      const stream = eventer.stream;\n      const mystreamCount = streamCount++;\n      this.currentStreamNumber = mystreamCount;\n      logger.debug('%s - created stream % based on blockType %s', method, this.currentStreamNumber, this.blockType);\n      eventer.stream.on('data', deliverResponse => {\n        logger.debug('on.data %s- peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n        if (stream !== eventer.stream) {\n          logger.debug('on.data %s- incoming block was from a cancelled stream', me);\n          return;\n        }\n        clearTimeout(connectionSetupTimeout);\n        logger.debug('on.data %s- resolve the promise', me);\n        resolve(eventer);\n        if (deliverResponse.Type === 'block' || deliverResponse.Type === 'filtered_block' || deliverResponse.Type === 'block_and_private_data') {\n          try {\n            let full_block = null;\n            let filtered_block = null;\n            let private_data_map = null;\n            let blockNumber = null;\n            if (deliverResponse.Type === 'block') {\n              full_block = BlockDecoder.decodeBlock(deliverResponse.block);\n              logger.debug('on.data %s- have full block data', me);\n              blockNumber = convertToLong(full_block.header.number);\n            } else if (deliverResponse.Type === 'filtered_block') {\n              filtered_block = BlockDecoder.decodeFilteredBlock(deliverResponse.filtered_block);\n              logger.debug('on.data %s- have filtered block data', me);\n              blockNumber = convertToLong(filtered_block.number);\n            } else if (deliverResponse.Type === 'block_and_private_data') {\n              const privateBlock = BlockDecoder.decodeBlockWithPrivateData(deliverResponse.block_and_private_data);\n              private_data_map = privateBlock.private_data_map;\n              full_block = privateBlock.block;\n              logger.debug('on.data %s- have full block data with private data', me);\n              blockNumber = convertToLong(full_block.header.number);\n            } else {\n              throw Error(`Unknown block type \"${deliverResponse.Type}`);\n            }\n            this.lastBlockNumber = blockNumber;\n            logger.debug('on.data %s- incoming block number %s', me, this.lastBlockNumber);\n            this._processBlockEvents(full_block, filtered_block, private_data_map, blockNumber);\n            this._processTxEvents(full_block, filtered_block);\n            this._processChaincodeEvents(full_block, filtered_block);\n            this._processEndBlock(blockNumber);\n\n            // check to see if we should shut things down\n            if (this.endBlock && this.endBlock.lessThanOrEqual && this.endBlock.lessThanOrEqual(this.lastBlockNumber)) {\n              this._endBlockSeen = true;\n              this._close(new Error(`Shutdown due to end block number has been seen: ${this.lastBlockNumber.toNumber()}`));\n            }\n          } catch (error) {\n            logger.error('on.data %s- EventService - ::%s', me, error.stack);\n            logger.error('on.data %s- EventService has detected an error %s', me, error);\n            // report error to all callbacks and shutdown this EventService\n            this._close(error);\n          }\n        } else if (deliverResponse.Type === 'status') {\n          if (deliverResponse.status === SUCCESS) {\n            logger.debug('on.data %s- received type status of SUCCESS', me);\n            if (this._endBlockSeen) {\n              // this is normal after the last block comes in when we set an ending block\n              logger.debug('on.data %s- status received after last block seen: %s blockNumber: %s', me, deliverResponse.status, this.lastBlockNumber.toNumber());\n            } else if (this.endBlock === NEWEST) {\n              // this is normal after the last block comes in when we set to newest as an ending block\n              logger.debug('on.data %s- status received when newest block seen: %s blockNumber: %s', me, deliverResponse.status, this.lastBlockNumber.toNumber());\n              this._close(new Error(`Newest block received:${this.lastBlockNumber.toNumber()} status:${deliverResponse.status}`));\n            } else if (this.endBlock && this.endBlock.greaterThan(this.lastBlockNumber)) {\n              logger.error('on.data %s- status SUCCESS received before the configured endblock has been seen', me);\n              this._close(new Error(`Connection Shutdown. End block of ${this.endBlock.toNumber()}` + `not received. Last block received ${this.lastBlockNumber.toNumber()}`));\n            } else {\n              logger.error('on.data %s- status SUCCESS received while blocks are required', me);\n              this._close(new Error('Event Service connection has been shutdown. ' + `Last block received ${this.lastBlockNumber.toNumber()}`));\n            }\n          } else if (deliverResponse.status === NOT_FOUND) {\n            logger.debug('on.data %s- received type status of NOT_FOUND', me);\n            if (this.endBlock) {\n              logger.error('on.data %s- Configured endblock does not exist', me);\n              this._close(new Error(`End block of ${this.endBlock.toNumber()}` + ` does not exist. Last block received ${this.lastBlockNumber.toNumber()}`));\n            } else {\n              logger.error('on.data %s- NOT_FOUND status received - last block received %s', me, this.lastBlockNumber.toNumber());\n              this._close(new Error(`Event stream has received an unexpected status message. status:${deliverResponse.status}`));\n            }\n          } else {\n            // tell all registered users that something is wrong and shutting down\n            logger.error('on.data %s- unexpected deliverResponse status received - %s', me, deliverResponse.status);\n            this._close(new Error(`Event stream has received an unexpected status message. status:${deliverResponse.status}`));\n          }\n        } else {\n          logger.error('on.data %s- unknown deliverResponse type %s', me, deliverResponse.Type);\n          this._close(new Error(`Event stream has received an unknown response type ${deliverResponse.Type}`));\n        }\n      });\n      eventer.stream.on('status', response => {\n        logger.debug('on status %s- status received: %j  peer:%s - stream:%s', me, response, eventer.endpoint.url, mystreamCount);\n      });\n      eventer.stream.on('end', () => {\n        logger.debug('on.end %s- peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n        if (stream !== eventer.stream) {\n          logger.debug('on.end %s- incoming message was from a cancelled stream', me);\n          return;\n        }\n        clearTimeout(connectionSetupTimeout);\n        const end_error = new Error('fabric peer service has closed due to an \"end\" event');\n\n        // tell all registered users that something is wrong and shutting\n        // down only if this event service has been started, which means\n        // that event service has an eventer endpoint assigned and this\n        // service is actively listening\n        if (this._currentEventer) {\n          logger.debug('on.end %s- close all application listeners', me);\n          this._close(end_error);\n        } else {\n          // must be we got the end while still trying to set up the\n          // listening stream, do not close the application listeners,\n          // we may try another target on the list or the application\n          // will try with another targets list\n          logger.error('on.end %s- reject the promise', me);\n          reject(end_error);\n        }\n      });\n      eventer.stream.on('error', err => {\n        logger.debug('on.error %s- block peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n        if (stream !== eventer.stream) {\n          logger.debug('on.error %s- incoming error was from a cancelled stream - %s', me, err);\n          return;\n        }\n        clearTimeout(connectionSetupTimeout);\n        let out_error = err;\n        if (err instanceof Error) {\n          logger.debug('on.error %s- is an Error - %s', me, err);\n        } else {\n          logger.debug('on.error %s- is not an Error - %s', me, err);\n          out_error = new Error(err);\n        }\n\n        // tell all registered users that something is wrong and shutting\n        // down only if this event service has been started, which means\n        // that event service has an eventer endpoint assigned and this\n        // service is actively listening\n        if (this._currentEventer) {\n          logger.debug('on.error %s- close all application listeners - %s', me, out_error);\n          this._close(out_error);\n        } else {\n          // must be we got the end while still trying to set up the\n          // listening stream, do not close the application listeners,\n          // we may try another target on the list or the application\n          // will try with another targets list\n          logger.error('on.error %s- reject the promise - %s', me, out_error);\n        }\n        reject(out_error);\n      });\n      try {\n        eventer.stream.write(envelope);\n        logger.debug('%s - stream write complete', method);\n      } catch (error) {\n        clearTimeout(connectionSetupTimeout);\n        reject(error);\n        logger.error('%s - write failed %s', method, error.stack);\n      }\n    });\n  }\n\n  /**\n   * Use this method to indicate if application has already started using this\n   * service. The service will have been asked to build the service request\n   * and will not have commpleted the service startup.\n   */\n  isInUse() {\n    const method = `isInUse[${this.name}]  - #${this.myNumber}`;\n    logger.debug('%s inUse - %s', method, this.inUse);\n    return this.inUse;\n  }\n\n  /**\n   * Use this method to indicate if this event service has an event endpoint\n   * {@link Eventer} assigned and the event endpoint has a listening stream\n   * connected and active.\n   */\n  isStarted() {\n    const method = `isStarted[${this.name}]  - #${this.myNumber}`;\n    if (this._currentEventer && this._currentEventer.isStreamReady()) {\n      logger.debug('%s - true', method);\n      return true;\n    } else {\n      logger.debug('%s - false', method);\n      return false;\n    }\n  }\n\n  /**\n   * Use this method to indicate if this event service has event listeners\n   * {@link EventListener} assigned and waiting for an event.\n   */\n  hasListeners() {\n    const method = `hasListeners[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    if (this._eventListenerRegistrations.size > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /*\n   * Internal method\n   * Will close out all callbacks\n   * Sends an error to all registered event callbacks\n   */\n  _closeAllCallbacks(err) {\n    const method = `_closeAllCallbacks[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    logger.debug('%s - event registrations %s', method, this._eventListenerRegistrations.size);\n    for (const event_reg of this._eventListenerRegistrations.values()) {\n      logger.debug('%s - tell listener of the error:%s', method, event_reg);\n      try {\n        event_reg.onEvent(err);\n      } catch (error) {\n        logger.error('%s - %s', method, error);\n      }\n    }\n    logger.debug('%s - clear out the listener list', method);\n    this._eventListenerRegistrations.clear();\n\n    // all done\n    logger.debug('%s - end', method);\n  }\n  _checkBlockNum(blockNumber) {\n    let _blockNumber = null;\n    if (typeof blockNumber === 'string') {\n      if (blockNumber.toLowerCase() === OLDEST) {\n        _blockNumber = OLDEST;\n      } else if (blockNumber.toLowerCase() === NEWEST) {\n        _blockNumber = NEWEST;\n      } else {\n        // maybe it is a string number\n        _blockNumber = convertToLong(blockNumber);\n      }\n    } else {\n      // only check if they give us something, these are optional parameters\n      if (typeof blockNumber !== 'undefined' && blockNumber !== null) {\n        _blockNumber = convertToLong(blockNumber);\n      }\n    }\n    return _blockNumber;\n  }\n\n  /**\n   * @typedef {Object} EventRegistrationOptions\n   * @property {boolean} unregister - Optional - This options setting indicates\n   *  the registration should be removed (unregister) when the event\n   *  is seen or the endBlock seen. When the application is using a timeout\n   *  to only wait a\n   *  specified amount of time for the transaction to be seen, the timeout\n   *  processing should included the manual 'unregister' of the transaction\n   *  event listener to avoid the event callbacks being called unexpectedly.\n   *  The default for this setting is different for the different types of\n   *  event listeners. For block listeners the default is false.\n   *  For transaction listeners the default is true and the\n   *  listener will be unregistered when a transaction with the id is\n   *  seen by this listener or the endBlock is seen. For chaincode listeners\n   *  the default will be false as the match filter might be intended for\n   *  many transactions rather than a specific transaction.\n   * @property {Number | string} [startBlock] - Optional. This will have this\n   *  registered listener look for this event within the block.\n   *  Blocks that have block numbers less than the startBlock will be\n   *  ignored by this listener.\n   *  Note: This EventService must be setup to listen for blocks in this\n   *  range.\n   * @property {Number | string} [endBlock] - Optional. This will have the\n   *  registered listener stop looking at blocks when the block number is\n   *  equal to or greater than the endBlock of this listener. The registered\n   * listener will be unregistered if the unregister option is set to true.\n   *  Note: This EventService must be setup to listen for blocks in this\n   *  range.\n   */\n\n  /**\n   * Unregister the event listener returned by\n   * the register listener methods.\n   *\n   * @param {EventListener} eventListener - The registered listener.\n   * @param {boolean} [notThrow] - When the listener is not found an error\n   *  will be thrown when not included or false\n   */\n  unregisterEventListener() {\n    let eventListener = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('eventListener');\n    let notThrow = arguments.length > 1 ? arguments[1] : undefined;\n    const method = `unregisterEventListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - eventListener:%s', method, eventListener);\n    if (this._eventListenerRegistrations.has(eventListener)) {\n      this._eventListenerRegistrations.delete(eventListener);\n    } else {\n      if (!notThrow) {\n        logger.error('%s - event listener was not found', method);\n        throw Error('eventListener not found');\n      } else {\n        logger.debug('%s - event listener was not found', method);\n        return; // nothing to do\n      }\n    }\n\n    let foundBlock = false;\n    let foundTx = false;\n    let foundChaincode = false;\n    for (const event_reg of this._eventListenerRegistrations.values()) {\n      if (event_reg.listenerType === BLOCK) {\n        foundBlock = true;\n      } else if (event_reg.listenerType === TX) {\n        foundTx = true;\n      } else if (event_reg.listenerType === CHAINCODE) {\n        foundChaincode = true;\n      }\n    }\n    this._haveBlockListeners = foundBlock;\n    this._haveTxListeners = foundTx;\n    this._haveChaincodeListeners = foundChaincode;\n    logger.debug('%s - end', method);\n    return this;\n  }\n\n  /**\n   * Callback function that takes two parameters\n   * @callback EventCallback\n   * @param {Error} error - The \"error\" will be null unless this EventService has been shutdown.\n   *  The shutdown may be caused by a network, connection error,\n   *  by a call to the \"disconnect()\" method\n   *  or when the fabric event service ends the connection to this EventService.\n   *  This callback will also be called with an Error when the EventService is shutdown\n   *  due to the last block being received if the service has been setup with an endBlock to be 'newest'\n   *  or a specific block number that has been seen.\n   * @param {EventInfo} event - The \"event\" will be the {@link EventInfo} object.\n   */\n\n  /**\n   * Register a listener to receive chaincode events.\n   * @param {string|RegExp} eventName - The exact name of the chaincode event or\n   *  regular expression that will be matched against the name given to\n   *  the target chaincode's call\n   *  <code>stub.SetEvent(name, payload)</code>)\n   * @param {EventCallback} callback\n   * @param {EventRegistrationOptions} options - Options on the registrations to allow\n   *  for start and end block numbers, automatically unregister.\n   * @returns {EventListener} The EventListener instance to be used to\n   *  remove this registration using {@link EventService#unregisterEvent})\n   */\n  registerChaincodeListener() {\n    let chaincodeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('chaincodeId');\n    let eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('eventName');\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : checkParameter('callback');\n    let options = arguments.length > 3 ? arguments[3] : undefined;\n    const method = `registerChaincodeListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - %s - %s', method, chaincodeId, eventName);\n    const eventListener = new EventListener(this, CHAINCODE, callback, options, new RegExp(eventName), chaincodeId);\n    this._eventListenerRegistrations.set(eventListener, eventListener);\n    this._haveChaincodeListeners = true;\n    return eventListener;\n  }\n\n  /**\n   * Register a listener to receive all blocks committed to this channel.\n   * The listener's \"callback\" function gets called on the arrival of every\n   * block.\n   *\n   * @param {EventCallback} callback\n   * @param {EventRegistrationOptions} options - Options on the registrations to allow\n   *  for start and end block numbers or to automatically unregister\n   * @returns {EventListener} The EventListener instance to be used to\n   *  remove this registration using {@link EventService#unregisterEvent})\n   */\n  registerBlockListener() {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('callback');\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    const method = `registerBlockListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    const eventListener = new EventListener(this, BLOCK, callback, options, null);\n    this._eventListenerRegistrations.set(eventListener, eventListener);\n    this._haveBlockListeners = true;\n    return eventListener;\n  }\n\n  /**\n   * Register a callback function to receive a notification when the transaction\n   * by the given id has been committed into a block. Using the special string\n   * 'all' will indicate that this listener will notify (call) the callback\n   * for every transaction written to the ledger.\n   *\n   * @param {string} txid - Transaction id string or 'all'\n   * @param {EventCallback} callback\n   * @param {EventRegistrationOptions} options - Options on the registrations to allow\n   *  for start and end block numbers or to automatically unregister.\n   * @returns {EventListener} The EventListener instance to be used to\n   *  remove this registration using {@link EventService#unregisterEvent})\n   */\n  registerTransactionListener() {\n    let txid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('txid');\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('callback');\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    const method = `registerTransactionListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s start - txid:%s', method, txid);\n    const send_options = Object.assign({}, options);\n    let _txid = txid;\n    // special case with 'all' transaction match\n    // need to not unregister automatically\n    if (txid.toLowerCase() === ALL) {\n      logger.debug('%s - listening for all transactions', method);\n      _txid = ALL;\n      if (typeof send_options.unregister === 'boolean') {\n        logger.debug('%s - unregister options is %s', method, send_options.unregister);\n      } else {\n        send_options.unregister = false;\n      }\n    }\n    const eventListener = new EventListener(this, TX, callback, send_options, _txid);\n    this._eventListenerRegistrations.set(eventListener, eventListener);\n    this._haveTxListeners = true;\n    return eventListener;\n  }\n\n  /**\n   * Utility method to find an event listener for a specific transaction ID\n   *\n   * @param {string} txid - the transaction ID of the event listener\n   *  being searched.\n   * @return {EventListener} The EventListener for the transaction ID provided\n   */\n  getTransactionListener() {\n    let txid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('txid');\n    const method = `getTransactionListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    let result = null;\n    for (const eventListener of this._eventListenerRegistrations.values()) {\n      // check each listener to see if this transaction ID matches\n      if (eventListener.listenerType === TX) {\n        if (eventListener.event === txid) {\n          logger.debug(`${method} - found the listener for ${txid}`);\n          result = eventListener;\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  /*\n   * private internal method to check each registered listener\n   * to see if it has requested to stop listening on a specific\n   * blocknum\n   */\n  _processEndBlock() {\n    let blockNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('blockNumber');\n    const method = `_processEndBlock[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    for (const listener of this._eventListenerRegistrations.values()) {\n      if (listener.endBlock) {\n        if (listener.endBlock.equals(blockNumber)) {\n          logger.debug('%s - listener endblock seen %s', method, blockNumber.toString());\n          const event = new EventInfo(this);\n          event.endBlockReceived = true;\n          event.blockNumber = blockNumber;\n          try {\n            listener.onEvent(null, event);\n          } catch (error) {\n            logger.error('%s - %s', method, error);\n          }\n          this.unregisterEventListener(listener, true);\n          logger.debug('%s - automatically unregister %s, end block: %s has been seen', method, listener, blockNumber);\n        } else {\n          logger.debug('%s - %s, end block: %s not seen', method, listener, blockNumber);\n        }\n      } else {\n        logger.debug('%s - %s, no end block defined', method, listener, blockNumber);\n      }\n    }\n    logger.debug('%s - end', method);\n  }\n\n  /*\n   * private internal method for processing block events\n   * @param {Object} block protobuf object\n   */\n  _processBlockEvents(full_block, filtered_block, private_data_map, blockNumber) {\n    const method = `_processBlockEvents[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - %s', method, this.blockType);\n    if (!this._haveBlockListeners) {\n      logger.debug('%s - no block listeners', method);\n      return;\n    }\n    if (full_block) {\n      logger.debug('%s - have full block', method);\n    } else if (filtered_block) {\n      logger.debug('%s - have filtered block', method);\n    } else {\n      logger.debug('%s - missing block data', method);\n    }\n    if (private_data_map) {\n      logger.debug('%s - have private data', method);\n    }\n    for (const blockReg of this._eventListenerRegistrations.values()) {\n      if (blockReg.listenerType === BLOCK) {\n        logger.debug('%s - calling block listener callback', method);\n        const event = new EventInfo(this);\n        event.block = full_block;\n        event.filteredBlock = filtered_block;\n        event.privateData = private_data_map;\n        event.blockNumber = blockNumber;\n        try {\n          blockReg.onEvent(null, event);\n        } catch (error) {\n          logger.error('%s - %s', method, error);\n        }\n\n        // check to see if we should automatically unregister\n        if (blockReg.unregister) {\n          logger.debug('%s - automatically unregister block listener for %s', method, blockReg);\n          this.unregisterEventListener(blockReg, true);\n        }\n      }\n    }\n  }\n\n  /*\n   * private internal method for processing tx events\n   * @param {Object} block protobuf object which might contain transactions\n   */\n  _processTxEvents(full_block, filtered_block) {\n    const method = `_processTxEvents[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    if (!this._haveTxListeners) {\n      logger.debug('%s - no tx listeners', method);\n      return;\n    }\n    if (filtered_block) {\n      logger.debug('%s filtered block number=%s', method, filtered_block.number);\n      if (filtered_block.filtered_transactions) {\n        logger.debug('%s filtered filtered_transactions=%j', method, filtered_block.filtered_transactions);\n        for (const filtered_transaction of filtered_block.filtered_transactions) {\n          if (filtered_transaction.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n            this._callTransactionListener(filtered_transaction.txid, filtered_transaction.tx_validation_code, filtered_block.number, undefined, filtered_block);\n          }\n        }\n      }\n    } else {\n      logger.debug('%s full block number=%s', method, full_block.header.number);\n      const txStatusCodes = full_block.metadata.metadata[fabproto6.common.BlockMetadataIndex.TRANSACTIONS_FILTER];\n      for (let index = 0; index < full_block.data.data.length; index++) {\n        const channel_header = full_block.data.data[index].payload.header.channel_header;\n        if (channel_header.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n          this._callTransactionListener(channel_header.tx_id, txStatusCodes[index], full_block.header.number, full_block);\n        }\n      }\n    }\n  }\n\n  /* internal utility method */\n  _callTransactionListener(txId, validationCode, blockNumber, full_block, filtered_block) {\n    const method = `_callTransactionListener[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    for (const transReg of this._eventListenerRegistrations.values()) {\n      // check each listener to see if this transaction ID matches\n      if (transReg.listenerType === TX) {\n        if (transReg.event === txId || transReg.event === ALL) {\n          logger.debug('%s - about to call the transaction call back with code=%s tx=%s', method, validationCode, txId);\n          const event = new EventInfo(this);\n          event.blockNumber = blockNumber;\n          event.transactionId = txId;\n          event.status = convertValidationCode(validationCode);\n          event.block = full_block;\n          event.filteredBlock = filtered_block;\n          try {\n            transReg.onEvent(null, event);\n          } catch (error) {\n            logger.error('%s - %s', method, error);\n          }\n\n          // check to see if we should automatically unregister\n          if (transReg.unregister) {\n            logger.debug('%s - automatically unregister tx listener for %s', method, txId);\n            this.unregisterEventListener(transReg, true);\n          }\n        } else {\n          logger.debug('%s - tx listener for %s - not called', method, transReg.event);\n        }\n      }\n    }\n  }\n\n  /*\n   * private internal method for processing chaincode events\n   * @param {Object} block protobuf object which might contain the chaincode event from the fabric\n   */\n  _processChaincodeEvents(full_block, filtered_block) {\n    const method = `_processChaincodeEvents[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start', method);\n    if (!this._haveChaincodeListeners) {\n      logger.debug('%s - no registered chaincode event \"listeners\"', method);\n      return;\n    }\n    const allEvents = new Map();\n    if (filtered_block) {\n      if (filtered_block.filtered_transactions) {\n        for (const filtered_transaction of filtered_block.filtered_transactions) {\n          if (filtered_transaction.transaction_actions) {\n            if (filtered_transaction.transaction_actions.chaincode_actions) {\n              for (const chaincode_action of filtered_transaction.transaction_actions.chaincode_actions) {\n                logger.debug('%s - filtered block chaincode_event %j', method, chaincode_action);\n                this._queueChaincodeEvent(chaincode_action.chaincode_event, filtered_block.number, filtered_transaction.txid, filtered_transaction.tx_validation_code, allEvents);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      logger.debug('%s - have full block %j', method, full_block);\n      for (let index = 0; index < full_block.data.data.length; index++) {\n        logger.debug('%s - trans index=%s', method, index);\n        try {\n          const env = full_block.data.data[index];\n          const channel_header = env.payload.header.channel_header;\n          // only ENDORSER_TRANSACTION have chaincode events\n          if (channel_header.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n            const tx = env.payload.data;\n            if (tx && tx.actions) {\n              for (const {\n                payload\n              } of tx.actions) {\n                const chaincode_event = payload.action.proposal_response_payload.extension.events;\n                logger.debug('%s - full block chaincode_event %j', method, chaincode_event);\n                const txStatusCodes = full_block.metadata.metadata[fabproto6.common.BlockMetadataIndex.TRANSACTIONS_FILTER];\n                const val_code = txStatusCodes[index];\n                this._queueChaincodeEvent(chaincode_event, full_block.header.number, channel_header.tx_id, val_code, allEvents);\n              }\n            } else {\n              logger.debug('%s - no transactions or transaction actions', method);\n            }\n          } else {\n            logger.debug('%s - full_block is not endorser transaction type', method);\n          }\n        } catch (err) {\n          logger.error('%s - Error with chaincode event processing :: %s', method, err);\n        }\n      }\n    }\n\n    // send all events for each listener\n    for (const [chaincodeListener, event] of allEvents.entries()) {\n      logger.debug('%s - calling callback - %s', method, chaincodeListener.event);\n      try {\n        chaincodeListener.onEvent(null, event);\n      } catch (error) {\n        logger.error('%s - %s', method, error);\n      }\n\n      // see if we should automatically unregister this event listener\n      if (chaincodeListener.unregister) {\n        logger.debug('%s - automatically unregister chaincode event listener setting', method);\n        this.unregisterEventListener(chaincodeListener, true);\n      }\n    }\n    logger.debug('%s - end', method);\n  }\n  _queueChaincodeEvent(chaincode_event, blockNumber, txId, val_code, allEvents) {\n    const method = `_queueChaincodeEvent[${this.name}] - #${this.myNumber}`;\n    logger.debug('%s - start - chaincode_event %j', method, chaincode_event);\n    const status = convertValidationCode(val_code);\n    logger.debug('%s - txid=%s  val_code=%s', method, txId, status);\n    for (const chaincodeListener of this._eventListenerRegistrations.values()) {\n      logger.debug('%s - checking regisistered chaincode event %s %s', method, chaincodeListener.event, chaincodeListener.chaincodeId);\n      // check each listener to see if this chaincode event matches\n      if (chaincodeListener.listenerType === CHAINCODE && chaincodeListener.chaincodeId === chaincode_event.chaincode_id && chaincodeListener.event.test(chaincode_event.event_name)) {\n        // we have a match - save it to be sent later\n        logger.debug('%s - queuing chaincode event: %s', method, chaincode_event.event_name);\n        let event = allEvents.get(chaincodeListener);\n        if (!event) {\n          event = new EventInfo(this);\n          event.blockNumber = blockNumber;\n          event.chaincodeEvents = [];\n          allEvents.set(chaincodeListener, event);\n        }\n        event.chaincodeEvents.push(new ChaincodeEvent(chaincode_event.chaincode_id, txId, status, chaincode_event.event_name, chaincode_event.payload));\n      } else {\n        logger.debug('%s - NOT queuing chaincode event: %s', method, chaincode_event.event_name);\n      }\n    }\n  }\n}\nmodule.exports = EventService;\n\n// convert to a string of the enum\nfunction convertValidationCode(code) {\n  if (typeof code === 'string') {\n    logger.debug('convertValidationCode - code %s', code);\n    return code;\n  }\n  const status = fabproto6.protos.TxValidationCode[code];\n  logger.debug('convertValidationCode - status %s', status);\n  return status;\n}\n\n/**\n * @typedef {Object} ChaincodeEvent\n * @property {string} chaincode_id - The name of chaincode that sourced this\n *  event.\n * @property {string} transactionId - The transaction ID of this event.\n * @property {string} status - The transaction status of the transaction.\n * @property {string} eventName - The string that is the eventName of this\n *  event as set by the chaincode during endorsement.\n *  <code>stub.SetEvent(eventName, payload)</code>\n * @property {byte[]} payload - Application-specific byte array that the chaincode\n *  set when it called <code>stub.SetEvent(eventName, payload)</code>\n */\n\nclass ChaincodeEvent {\n  /**\n   * Constructs an object that contains all information from the chaincode event.\n   * message ChaincodeEvent {\n   *   string chaincode_id = 1;\n   *   string tx_id = 2;\n   *   string event_name = 3;\n   *   bytes payload = 4;\n   */\n  constructor(chaincodeId, transactionId, status, eventName, payload) {\n    this.chaincodeId = chaincodeId;\n    this.transactionId = transactionId;\n    this.status = status;\n    this.eventName = eventName;\n    this.payload = payload;\n  }\n}\n\n/**\n * @typedef {Object} EventInfo\n * @property {EventService} eventService - This EventService.\n * @property {Long} blockNumber - The block number that contains this event.\n * @property {string} [transactionId] - The transaction ID of this event\n * @property {string} [transactionStatus] - The transaction status of this\n *  event.\n * @property {boolean} endBlockReceived - Indicates if the endBlock as\n *  defined by the listener has been seen.\n * @property {ChaincodeEvent[]} chaincodeEvents - An array of {@link ChaincodeEvent}.\n * @property {object} [block] - The decode of the full block received\n * @property {object} [filteredBlock] - The decode of the filtered block received\n * @property {object} [privateData] -A data map of any included private data.\n */\n\nclass EventInfo {\n  /**\n   * Constructs a {@link EventInfo} object that contains all information about an Event.\n   */\n  constructor(eventService) {\n    this.eventService = eventService;\n    this.blockNumber;\n    this.transactionId;\n    this.transactionStatus;\n    this.endBlockReceived = false;\n    this.chaincodeEvents = [];\n    this.block;\n    this.filteredBlock;\n    this.privateData;\n  }\n}","map":{"version":3,"names":["TYPE","Long","require","BlockDecoder","checkParameter","convertToLong","getLogger","ServiceAction","EventListener","logger","fabproto6","common","Status","SUCCESS","NOT_FOUND","ALL","NEWEST","OLDEST","BLOCK","TX","CHAINCODE","FULL_BLOCK","FILTERED_BLOCK","PRIVATE_BLOCK","count","streamCount","EventService","constructor","name","arguments","length","undefined","channel","debug","type","lastBlockNumber","startBlock","endBlock","_endBlockSeen","_eventListenerRegistrations","Map","_haveBlockListeners","_haveTxListeners","_haveChaincodeListeners","targets","_currentEventer","_closeRunning","blockType","replay","startSpecified","myNumber","inUse","setTargets","method","Array","isArray","Error","eventer","isConnectable","getLastBlockNumber","close","_close","reasonError","message","_closeAllCallbacks","currentStreamNumber","disconnect","build","idContext","options","_checkBlockNum","greaterThan","_payload","calculateTransactionId","behavior","orderer","SeekInfo","SeekBehavior","BLOCK_UNTIL_READY","seekStart","SeekPosition","create","newest","SeekNewest","oldest","SeekOldest","specified","SeekSpecified","number","seekStop","FAIL_IF_NOT_READY","seekSpecifiedStop","MAX_VALUE","seekInfo","start","stop","seekInfoBuf","encode","finish","channelHeaderBuf","buildChannelHeader","HeaderType","DELIVER_SEEK_INFO","transactionId","seekPayload","Payload","header","buildHeader","data","send","request","requestTimeout","envelope","getSignedEnvelope","startError","target","stream","toString","isConnected","checkConnection","_startService","error","me","Promise","resolve","reject","endpoint","connectionSetupTimeout","setTimeout","setStreamByType","mystreamCount","on","deliverResponse","url","clearTimeout","Type","full_block","filtered_block","private_data_map","blockNumber","decodeBlock","block","decodeFilteredBlock","privateBlock","decodeBlockWithPrivateData","block_and_private_data","_processBlockEvents","_processTxEvents","_processChaincodeEvents","_processEndBlock","lessThanOrEqual","toNumber","stack","status","response","end_error","err","out_error","write","isInUse","isStarted","isStreamReady","hasListeners","size","event_reg","values","onEvent","clear","_blockNumber","toLowerCase","unregisterEventListener","eventListener","notThrow","has","delete","foundBlock","foundTx","foundChaincode","listenerType","registerChaincodeListener","chaincodeId","eventName","callback","RegExp","set","registerBlockListener","registerTransactionListener","txid","send_options","Object","assign","_txid","unregister","getTransactionListener","result","event","listener","equals","EventInfo","endBlockReceived","blockReg","filteredBlock","privateData","filtered_transactions","filtered_transaction","ENDORSER_TRANSACTION","_callTransactionListener","tx_validation_code","txStatusCodes","metadata","BlockMetadataIndex","TRANSACTIONS_FILTER","index","channel_header","payload","tx_id","txId","validationCode","transReg","convertValidationCode","allEvents","transaction_actions","chaincode_actions","chaincode_action","_queueChaincodeEvent","chaincode_event","env","tx","actions","action","proposal_response_payload","extension","events","val_code","chaincodeListener","entries","chaincode_id","test","event_name","get","chaincodeEvents","push","ChaincodeEvent","module","exports","code","protos","TxValidationCode","eventService","transactionStatus"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/EventService.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'EventService';\n\nconst Long = require('long');\nconst BlockDecoder = require('./BlockDecoder.js');\nconst {checkParameter, convertToLong, getLogger} = require('./Utils.js');\nconst ServiceAction = require('./ServiceAction.js');\nconst EventListener = require('./EventListener.js');\n\nconst logger = getLogger(TYPE);\n\nconst fabproto6 = require('fabric-protos');\nconst {common: {Status: {SUCCESS, NOT_FOUND}}} = fabproto6;\n\n// Special transaction id to indicate that the transaction listener will be\n// notified of all transactions\nconst ALL = 'all';\n\n// Special values for block numbers\nconst NEWEST = 'newest'; // what fabric peer sees as newest on the ledger at time of connect\nconst OLDEST = 'oldest'; // what fabric peer sees as oldest on the ledger at time of connect\n\nconst BLOCK = EventListener.BLOCK; // for block type event listeners\nconst TX = EventListener.TX; // for transaction type event listeners\nconst CHAINCODE = EventListener.CHAINCODE; // for chaincode event type event listeners\n\n// block type is a NodeSDK concept to understand what type of gRPC message data we\n// need to work with, both in how we set up the stream and the data returned\nconst FULL_BLOCK = 'full'; // to receive full blocks\nconst FILTERED_BLOCK = 'filtered'; // to receive filtered blocks\nconst PRIVATE_BLOCK = 'private'; // to receive full blocks and private data\n\n// some info to help with debug when there are multiple eventservices running\nlet count = 1;\nlet streamCount = 1;\n\n/**\n * EventService is used to monitor for new blocks on a peer's ledger.\n * The class allows the user to register a listener to be notified when a\n * new block is added to the ledger, when a new block is added that has a\n * specific transaction ID, or to be notified when a transaction contains a\n * chaincode event name of interest.\n * The class also allows the monitoring to start and end at any specific location.\n *\n * @class\n * @extends ServiceAction\n */\n\nclass EventService extends ServiceAction {\n\n\t/**\n\t * Constructs a EventService object\n\t *\n\t * @param {string} name\n\t * @param {Channel} channel - An instance of the Channel class\n\t * were this EventService will receive blocks\n\t * @returns {EventService} An instance of this class\n\t */\n\n\tconstructor(name = checkParameter('name'), channel = checkParameter('channel')) {\n\t\tlogger.debug(`${TYPE}.constructor[${name}] - start `);\n\t\tsuper(name);\n\t\tthis.type = TYPE;\n\t\tthis.channel = channel;\n\n\t\t// the last block number received\n\t\tthis.lastBlockNumber = null;\n\n\t\tthis.startBlock = NEWEST;\n\t\tthis.endBlock = undefined;\n\t\tthis._endBlockSeen = false;\n\n\t\tthis._eventListenerRegistrations = new Map();\n\t\tthis._haveBlockListeners = false;\n\t\tthis._haveTxListeners = false;\n\t\tthis._haveChaincodeListeners = false;\n\n\t\t// peer's event service\n\t\tthis.targets = null;\n\t\tthis._currentEventer = null;\n\t\t// closing state to case of multiple calls\n\t\tthis._closeRunning = false;\n\n\t\t// remember the blockType this EventService is listening\n\t\t// will be set during the .build call\n\t\tthis.blockType = FILTERED_BLOCK;\n\t\tthis.replay = false;\n\t\tthis.startSpecified = false;\n\n\t\tthis.myNumber = count++;\n\n\t\tthis.inUse = false;\n\t}\n\n\t/**\n\t * Use this method to set the ServiceEndpoint for this ServiceAction class\n\t * The {@link Eventer} a ServiceEndpoint must be connected before making\n\t * this assignment.\n\t * @property {Eventer[]} targets - The connected Eventer instances to\n\t *  be used when no targets are provided on the send.\n\t */\n\tsetTargets(targets = checkParameter('targets')) {\n\t\tconst method = `setTargets[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (!Array.isArray(targets)) {\n\t\t\tthrow Error('targets parameter is not an array');\n\t\t}\n\n\t\tif (targets.length < 1) {\n\t\t\tthrow Error('No targets provided');\n\t\t}\n\n\t\tfor (const eventer of targets) {\n\t\t\tif (eventer.isConnectable()) {\n\t\t\t\tlogger.debug('%s - target is connectable %s', method, eventer.name);\n\t\t\t} else {\n\t\t\t\tthrow Error(`Eventer ${eventer.name} is not connectable`);\n\t\t\t}\n\t\t}\n\t\t// must be all targets are connectable\n\t\tthis.targets = targets;\n\n\t\treturn this;\n\t}\n\n\t/*\n\t * The block number of the last block seen\n\t *\n\t * @returns {Long} The block number of the last block seen\n\t */\n\tgetLastBlockNumber() {\n\t\treturn this.lastBlockNumber;\n\t}\n\n\t/**\n\t * Disconnects the EventService from the fabric peer service and\n\t * closes all services.\n\t * Will close all event listeners and send an Error to all active listeners.\n\t */\n\tclose() {\n\t\tconst method = `close[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - hub', method);\n\t\tthis._close(new Error('EventService has been shutdown by \"close()\" call'));\n\t}\n\n\t/*\n\t * Internal method\n\t * Disconnects the connection to the fabric peer service.\n\t * Will close all event listeners and send the provided `Error` to\n\t * all listeners on the event callback.\n\t */\n\t_close(reasonError = checkParameter('reasonError')) {\n\t\tconst method = `_close[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - called due to %s', method, reasonError.message);\n\n\t\tif (this._closeRunning) {\n\t\t\tlogger.debug('%s - close is running - exiting', method);\n\t\t\treturn;\n\t\t}\n\t\tthis._closeRunning = true;\n\t\tthis._closeAllCallbacks(reasonError);\n\t\tif (this._currentEventer) {\n\t\t\tlogger.debug('%s - have currentEventer close stream %s', method, this.currentStreamNumber);\n\t\t\tthis._currentEventer.disconnect();\n\t\t\tthis._currentEventer = null;\n\t\t} else {\n\t\t\tlogger.debug('%s - no current eventer - not shutting down stream', method);\n\t\t}\n\n\t\tthis._closeRunning = false;\n\t\tthis.inUse = false;\n\n\t\tlogger.debug('%s - end', method);\n\t}\n\n\t/**\n\t * @typedef {Object} StartRequestOptions\n\t * @property {string} [blockType] - Optional. To indicate that the event service\n\t *  on the peer will be sending full blocks, filtered blocks or private data\n\t *  blocks to this EventService.\n\t *  The default will be 'filtered' with 'full' for full blocks and 'private'\n\t *  for blocks with private data.\n\t *  Filtered blocks have the required information to provided transaction\n\t *  status and chaincode event names, however no chaincode event payload.\n\t *  When using the non filtered blocks (full blocks or private data) the user\n\t *  will be required to have access to receive full blocks and the private data.\n\t *  Registering a block listener when listening for filtered blocks may not\n\t *  provide sufficient information in the blocks received.\n\t * @property {Number | string} [startBlock] - Optional. This will have the service\n\t *  setup to start sending blocks back to the event hub at the block\n\t *  with this number.\n\t *  If the service should start with the last block this instance\n\t *  has seen use the string 'last_seen'.\n\t *  If the service should start with the oldest block on the\n\t *  ledger use the string 'oldest'.\n\t *  If the service should start with the latest block on the ledger,\n\t *  use the string 'latest' or do not include a 'startBlock'.\n\t *  Default is to start with the latest block on the ledger.\n\t * @property {Number | string} [endBlock] - Optional. This will have the service\n\t *  setup to end sending blocks back to the event hub at the block\n\t *  with this number.\n\t *  If the service should end with the last block it has seen\n\t *  use the string 'last_seen'.\n\t *  If the service should end with the current block on the\n\t *  ledger use the string 'newest'.\n\t *  Default is to continue to send.\n\t */\n\n\t/**\n\t * This method is used to build the protobuf objects of the start request.\n\t * The start request must next be signed before being sent to the peer's event service.\n\t * The {@link Proposal#buildAndSignStartRequest} method should be used if the\n\t * signing will be done by the application.\n\t *\n\t * @param {IdentityContext} idContext - The transaction context to use for\n\t *  Identity, transaction ID, and nonce values\n\t * @param {StartRequestOptions} options - The build\n\t * @returns {byte[]} The start request bytes that need to be\n\t *  signed.\n\t */\n\tbuild(idContext = checkParameter('idContext'), options = {}) {\n\t\tconst method = `build[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tthis.inUse = true;\n\t\tconst {startBlock, endBlock, blockType = FILTERED_BLOCK} = options;\n\t\tthis.startBlock = this._checkBlockNum(startBlock);\n\t\tthis.endBlock = this._checkBlockNum(endBlock);\n\n\t\t// when they are both Longs\n\t\tif (this.startBlock && this.endBlock && this.endBlock.greaterThan && this.startBlock.greaterThan) {\n\t\t\tif (this.startBlock.greaterThan(this.endBlock)) {\n\t\t\t\tthrow Error('\"startBlock\" must not be greater than \"endBlock\"');\n\t\t\t}\n\t\t}\n\n\t\tif (typeof blockType === 'string') {\n\t\t\tif (blockType === FULL_BLOCK || blockType === FILTERED_BLOCK || blockType === PRIVATE_BLOCK) {\n\t\t\t\tthis.blockType = blockType;\n\t\t\t} else {\n\t\t\t\tthrow Error(`Invalid blockType ${blockType}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow Error('\"blockType must be a string');\n\t\t}\n\n\t\tthis._payload = null;\n\t\tidContext.calculateTransactionId();\n\n\t\t// BLOCK_UNTIL_READY will mean hold the stream open and keep sending as\n\t\t//    the blocks come in\n\t\t// FAIL_IF_NOT_READY will mean if the block is not there throw an error\n\t\tlet behavior = fabproto6.orderer.SeekInfo.SeekBehavior.BLOCK_UNTIL_READY;\n\n\t\t// build start proto\n\t\tconst seekStart = fabproto6.orderer.SeekPosition.create();\n\t\tif (!this.startBlock || this.startBlock === NEWEST) {\n\t\t\tif (this.endBlock === OLDEST) {\n\t\t\t\tthrow Error('\"startBlock\" must not be greater than \"endBlock\"');\n\t\t\t}\n\t\t\tseekStart.newest = fabproto6.orderer.SeekNewest.create();\n\t\t} else if (this.startBlock === OLDEST) {\n\t\t\tseekStart.oldest = fabproto6.orderer.SeekOldest.create();\n\t\t\tthis.replay = true;\n\t\t} else if (this.startBlock) {\n\t\t\tseekStart.specified = fabproto6.orderer.SeekSpecified.create({\n\t\t\t\tnumber: this.startBlock\n\t\t\t});\n\t\t\tthis.replay = true;\n\t\t\tthis.startSpecified = true;\n\t\t}\n\n\t\t// build stop proto\n\t\tconst seekStop = fabproto6.orderer.SeekPosition.create();\n\t\tif (this.endBlock === NEWEST) {\n\t\t\tseekStop.newest = fabproto6.orderer.SeekNewest.create();\n\t\t\tbehavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n\t\t\tthis.replay = true;\n\t\t} else if (this.endBlock === OLDEST) {\n\t\t\tseekStop.oldest = fabproto6.orderer.SeekOldest.create();\n\t\t\tbehavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n\t\t\tthis.replay = true;\n\t\t} else {\n\t\t\tconst seekSpecifiedStop = fabproto6.orderer.SeekSpecified.create();\n\t\t\tif (this.endBlock) {\n\t\t\t\tseekSpecifiedStop.number = this.endBlock;\n\t\t\t\t// user should be told that the block does not exist\n\t\t\t\tbehavior = fabproto6.orderer.SeekInfo.SeekBehavior.FAIL_IF_NOT_READY;\n\t\t\t\tthis.replay = true;\n\t\t\t} else {\n\t\t\t\tseekSpecifiedStop.number = Long.MAX_VALUE;\n\t\t\t}\n\t\t\tseekStop.specified = seekSpecifiedStop;\n\t\t}\n\n\t\t// seek info with all parts\n\t\tconst seekInfo = fabproto6.orderer.SeekInfo.create({\n\t\t\tstart: seekStart,\n\t\t\tstop: seekStop,\n\t\t\tbehavior: behavior\n\t\t});\n\t\tconst seekInfoBuf = fabproto6.orderer.SeekInfo.encode(seekInfo).finish();\n\n\t\t// build the header for use with the seekInfo payload\n\t\tconst channelHeaderBuf = this.channel.buildChannelHeader(\n\t\t\tfabproto6.common.HeaderType.DELIVER_SEEK_INFO,\n\t\t\t'',\n\t\t\tidContext.transactionId\n\t\t);\n\n\t\tconst seekPayload = fabproto6.common.Payload.create({\n\t\t\theader: this.buildHeader(idContext, channelHeaderBuf),\n\t\t\tdata: seekInfoBuf\n\t\t});\n\t\tthis._payload = fabproto6.common.Payload.encode(seekPayload).finish();\n\n\t\tlogger.debug(`${method} - end`);\n\t\treturn this._payload;\n\t}\n\n\t/**\n\t * @typedef {Object} StartEventRequest\n\t * @property {Eventer[]} targets - The Eventers to send the start stream request.\n\t * @property {Number} [requestTimeout] - Optional. The request timeout\n\t */\n\n\t/**\n\t * This method will have this events start listening for blocks from the\n\t * Peer's event service. It will send a Deliver request to the peer\n\t * event service and start the grpc streams. The received blocks will\n\t * be checked to see if there is a match to any of the registered\n\t * listeners.\n\t *\n\t * @param {StartEventRequest} request - The request options to start the\n\t *  stream to the event service.\n\t */\n\tasync send(request = {}) {\n\t\tconst method = `send[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst {targets, requestTimeout} = request;\n\t\tif (targets && Array.isArray(targets) && targets.length > 0) {\n\t\t\tthis.targets = targets;\n\t\t\tlogger.debug('%s - using user assigned targets', method);\n\t\t} else if (this.targets) {\n\t\t\tlogger.debug('%s - using preassigned targets', method);\n\t\t} else {\n\t\t\tcheckParameter('targets');\n\t\t}\n\t\tconst envelope = this.getSignedEnvelope();\n\t\tthis._currentEventer = null;\n\t\tlet startError = null;\n\t\tthis._endBlockSeen = false;\n\n\t\tfor (const target of this.targets) {\n\t\t\ttry {\n\t\t\t\tif (target.stream) {\n\t\t\t\t\tlogger.debug('%s - target has a stream, is already listening %s', method, target.toString());\n\t\t\t\t\tstartError = Error(`Event service ${target.name} is currently listening`);\n\t\t\t\t} else {\n\t\t\t\t\tconst isConnected = await target.checkConnection();\n\t\t\t\t\tif (!isConnected) {\n\t\t\t\t\t\tstartError = Error(`Event service ${target.name} is not connected`);\n\t\t\t\t\t\tlogger.debug('%s - target is not connected %s', method, target.toString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._currentEventer = await this._startService(target, envelope, requestTimeout);\n\t\t\t\t\t\tlogger.debug('%s - set current eventer %s', method, this._currentEventer.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('%s - Starting stream to %s failed', method, target.name);\n\t\t\t\tstartError = error;\n\t\t\t}\n\n\t\t\t// let see how we did with this target\n\t\t\tif (this._currentEventer) {\n\t\t\t\t// great, it will be the one we use, stop looking\n\t\t\t\tstartError = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// if we ran through the all targets and have startError then we\n\t\t// have not found a working target endpoint, so tell user error\n\t\tif (startError) {\n\t\t\tlogger.error('%s - no targets started - %s', method, startError);\n\t\t\tthrow startError;\n\t\t}\n\n\t\tlogger.debug('%s - end', method);\n\t}\n\n\t/*\n\t * internal method to startup a stream and bind this event hub's callbacks\n\t * to a specific target's gRPC stream\n\t */\n\t_startService(eventer, envelope, requestTimeout) {\n\t\tconst me = `[${this.name}] - #${this.myNumber}`;\n\t\tconst method = `_startService${me}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (!requestTimeout) {\n\t\t\t\trequestTimeout = eventer.endpoint.options.requestTimeout;\n\t\t\t}\n\t\t\tlogger.debug('%s - setup timer %s', method, requestTimeout);\n\n\t\t\tlogger.debug('%s - create stream setup timeout', method);\n\t\t\tconst connectionSetupTimeout = setTimeout(() => {\n\t\t\t\t// this service may be waiting for a start block that has not happened\n\t\t\t\tif (this.startSpecified) {\n\t\t\t\t\tlogger.debug(`EventService[${this.name}] timed out after:${requestTimeout}`);\n\t\t\t\t\tlogger.debug(`EventService[${this.name}] not stopping service, wait indefinitely`);\n\t\t\t\t\t// resolve the promise as if we did get a good response from the peer, since we did\n\t\t\t\t\t// not get an \"end\" or \"error\" back indicating that the request was invalid\n\t\t\t\t\t// application should have a timer just in case this peer never gets this block\n\t\t\t\t\tresolve(eventer);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.error(`EventService[${this.name}] timed out after:${requestTimeout}`);\n\t\t\t\t\treject(Error('Event service timed out - Unable to start listening'));\n\t\t\t\t}\n\n\t\t\t}, requestTimeout);\n\n\t\t\teventer.setStreamByType(this.blockType);\n\n\t\t\t// the promise and streams live on and we need\n\t\t\t// to check at times to be sure we are working with the\n\t\t\t// correct one if the target gets restarted\n\t\t\tconst stream = eventer.stream;\n\t\t\tconst mystreamCount = streamCount++;\n\t\t\tthis.currentStreamNumber = mystreamCount;\n\n\t\t\tlogger.debug('%s - created stream % based on blockType %s', method, this.currentStreamNumber, this.blockType);\n\n\t\t\teventer.stream.on('data', (deliverResponse) => {\n\t\t\t\tlogger.debug('on.data %s- peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n\t\t\t\tif (stream !== eventer.stream) {\n\t\t\t\t\tlogger.debug('on.data %s- incoming block was from a cancelled stream', me);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tclearTimeout(connectionSetupTimeout);\n\n\t\t\t\tlogger.debug('on.data %s- resolve the promise', me);\n\t\t\t\tresolve(eventer);\n\n\t\t\t\tif (deliverResponse.Type === 'block' || deliverResponse.Type === 'filtered_block' || deliverResponse.Type === 'block_and_private_data') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet full_block = null;\n\t\t\t\t\t\tlet filtered_block = null;\n\t\t\t\t\t\tlet private_data_map = null;\n\t\t\t\t\t\tlet blockNumber = null;\n\t\t\t\t\t\tif (deliverResponse.Type === 'block') {\n\t\t\t\t\t\t\tfull_block = BlockDecoder.decodeBlock(deliverResponse.block);\n\t\t\t\t\t\t\tlogger.debug('on.data %s- have full block data', me);\n\t\t\t\t\t\t\tblockNumber = convertToLong(full_block.header.number);\n\t\t\t\t\t\t} else if (deliverResponse.Type === 'filtered_block') {\n\t\t\t\t\t\t\tfiltered_block = BlockDecoder.decodeFilteredBlock(deliverResponse.filtered_block);\n\t\t\t\t\t\t\tlogger.debug('on.data %s- have filtered block data', me);\n\t\t\t\t\t\t\tblockNumber = convertToLong(filtered_block.number);\n\t\t\t\t\t\t} else if (deliverResponse.Type === 'block_and_private_data') {\n\t\t\t\t\t\t\tconst privateBlock = BlockDecoder.decodeBlockWithPrivateData(deliverResponse.block_and_private_data);\n\t\t\t\t\t\t\tprivate_data_map = privateBlock.private_data_map;\n\t\t\t\t\t\t\tfull_block = privateBlock.block;\n\t\t\t\t\t\t\tlogger.debug('on.data %s- have full block data with private data', me);\n\t\t\t\t\t\t\tblockNumber = convertToLong(full_block.header.number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow Error(`Unknown block type \"${deliverResponse.Type}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.lastBlockNumber = blockNumber;\n\t\t\t\t\t\tlogger.debug('on.data %s- incoming block number %s', me, this.lastBlockNumber);\n\t\t\t\t\t\tthis._processBlockEvents(full_block, filtered_block, private_data_map, blockNumber);\n\t\t\t\t\t\tthis._processTxEvents(full_block, filtered_block);\n\t\t\t\t\t\tthis._processChaincodeEvents(full_block, filtered_block);\n\t\t\t\t\t\tthis._processEndBlock(blockNumber);\n\n\t\t\t\t\t\t// check to see if we should shut things down\n\t\t\t\t\t\tif (this.endBlock && this.endBlock.lessThanOrEqual && this.endBlock.lessThanOrEqual(this.lastBlockNumber)) {\n\t\t\t\t\t\t\tthis._endBlockSeen = true;\n\t\t\t\t\t\t\tthis._close(new Error(`Shutdown due to end block number has been seen: ${this.lastBlockNumber.toNumber()}`));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error('on.data %s- EventService - ::%s', me, error.stack);\n\t\t\t\t\t\tlogger.error('on.data %s- EventService has detected an error %s', me, error);\n\t\t\t\t\t\t// report error to all callbacks and shutdown this EventService\n\t\t\t\t\t\tthis._close(error);\n\t\t\t\t\t}\n\t\t\t\t} else if (deliverResponse.Type === 'status') {\n\t\t\t\t\tif (deliverResponse.status === SUCCESS) {\n\t\t\t\t\t\tlogger.debug('on.data %s- received type status of SUCCESS', me);\n\t\t\t\t\t\tif (this._endBlockSeen) {\n\t\t\t\t\t\t\t// this is normal after the last block comes in when we set an ending block\n\t\t\t\t\t\t\tlogger.debug('on.data %s- status received after last block seen: %s blockNumber: %s',\n\t\t\t\t\t\t\t\tme, deliverResponse.status, this.lastBlockNumber.toNumber());\n\t\t\t\t\t\t} else if (this.endBlock === NEWEST) {\n\t\t\t\t\t\t\t// this is normal after the last block comes in when we set to newest as an ending block\n\t\t\t\t\t\t\tlogger.debug('on.data %s- status received when newest block seen: %s blockNumber: %s',\n\t\t\t\t\t\t\t\tme, deliverResponse.status, this.lastBlockNumber.toNumber());\n\t\t\t\t\t\t\tthis._close(new Error(`Newest block received:${this.lastBlockNumber.toNumber()} status:${deliverResponse.status}`));\n\t\t\t\t\t\t} else if (this.endBlock && this.endBlock.greaterThan(this.lastBlockNumber)) {\n\t\t\t\t\t\t\tlogger.error('on.data %s- status SUCCESS received before the configured endblock has been seen', me);\n\t\t\t\t\t\t\tthis._close(new Error(`Connection Shutdown. End block of ${this.endBlock.toNumber()}` +\n\t\t\t\t\t\t\t\t`not received. Last block received ${this.lastBlockNumber.toNumber()}`));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error('on.data %s- status SUCCESS received while blocks are required', me);\n\t\t\t\t\t\t\tthis._close(new Error('Event Service connection has been shutdown. ' +\n\t\t\t\t\t\t\t\t`Last block received ${this.lastBlockNumber.toNumber()}`));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (deliverResponse.status === NOT_FOUND) {\n\t\t\t\t\t\tlogger.debug('on.data %s- received type status of NOT_FOUND', me);\n\t\t\t\t\t\tif (this.endBlock) {\n\t\t\t\t\t\t\tlogger.error('on.data %s- Configured endblock does not exist', me);\n\t\t\t\t\t\t\tthis._close(new Error(`End block of ${this.endBlock.toNumber()}` +\n\t\t\t\t\t\t\t\t` does not exist. Last block received ${this.lastBlockNumber.toNumber()}`));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error('on.data %s- NOT_FOUND status received - last block received %s', me, this.lastBlockNumber.toNumber());\n\t\t\t\t\t\t\tthis._close(new Error(`Event stream has received an unexpected status message. status:${deliverResponse.status}`));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// tell all registered users that something is wrong and shutting down\n\t\t\t\t\t\tlogger.error('on.data %s- unexpected deliverResponse status received - %s', me, deliverResponse.status);\n\t\t\t\t\t\tthis._close(new Error(`Event stream has received an unexpected status message. status:${deliverResponse.status}`));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.error('on.data %s- unknown deliverResponse type %s', me, deliverResponse.Type);\n\t\t\t\t\tthis._close(new Error(`Event stream has received an unknown response type ${deliverResponse.Type}`));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\teventer.stream.on('status', (response) => {\n\t\t\t\tlogger.debug('on status %s- status received: %j  peer:%s - stream:%s', me, response, eventer.endpoint.url, mystreamCount);\n\t\t\t});\n\n\t\t\teventer.stream.on('end', () => {\n\t\t\t\tlogger.debug('on.end %s- peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n\t\t\t\tif (stream !== eventer.stream) {\n\t\t\t\t\tlogger.debug('on.end %s- incoming message was from a cancelled stream', me);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tclearTimeout(connectionSetupTimeout);\n\n\t\t\t\tconst end_error = new Error('fabric peer service has closed due to an \"end\" event');\n\n\t\t\t\t// tell all registered users that something is wrong and shutting\n\t\t\t\t// down only if this event service has been started, which means\n\t\t\t\t// that event service has an eventer endpoint assigned and this\n\t\t\t\t// service is actively listening\n\t\t\t\tif (this._currentEventer) {\n\t\t\t\t\tlogger.debug('on.end %s- close all application listeners', me);\n\t\t\t\t\tthis._close(end_error);\n\t\t\t\t} else {\n\t\t\t\t\t// must be we got the end while still trying to set up the\n\t\t\t\t\t// listening stream, do not close the application listeners,\n\t\t\t\t\t// we may try another target on the list or the application\n\t\t\t\t\t// will try with another targets list\n\t\t\t\t\tlogger.error('on.end %s- reject the promise', me);\n\t\t\t\t\treject(end_error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\teventer.stream.on('error', (err) => {\n\t\t\t\tlogger.debug('on.error %s- block peer:%s - stream:%s', me, eventer.endpoint.url, mystreamCount);\n\t\t\t\tif (stream !== eventer.stream) {\n\t\t\t\t\tlogger.debug('on.error %s- incoming error was from a cancelled stream - %s', me, err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tclearTimeout(connectionSetupTimeout);\n\n\t\t\t\tlet out_error = err;\n\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\tlogger.debug('on.error %s- is an Error - %s', me, err);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('on.error %s- is not an Error - %s', me, err);\n\t\t\t\t\tout_error = new Error(err);\n\t\t\t\t}\n\n\t\t\t\t// tell all registered users that something is wrong and shutting\n\t\t\t\t// down only if this event service has been started, which means\n\t\t\t\t// that event service has an eventer endpoint assigned and this\n\t\t\t\t// service is actively listening\n\t\t\t\tif (this._currentEventer) {\n\t\t\t\t\tlogger.debug('on.error %s- close all application listeners - %s', me, out_error);\n\t\t\t\t\tthis._close(out_error);\n\t\t\t\t} else {\n\t\t\t\t\t// must be we got the end while still trying to set up the\n\t\t\t\t\t// listening stream, do not close the application listeners,\n\t\t\t\t\t// we may try another target on the list or the application\n\t\t\t\t\t// will try with another targets list\n\t\t\t\t\tlogger.error('on.error %s- reject the promise - %s', me, out_error);\n\t\t\t\t}\n\t\t\t\treject(out_error);\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\teventer.stream.write(envelope);\n\t\t\t\tlogger.debug('%s - stream write complete', method);\n\t\t\t} catch (error) {\n\t\t\t\tclearTimeout(connectionSetupTimeout);\n\t\t\t\treject(error);\n\t\t\t\tlogger.error('%s - write failed %s', method, error.stack);\n\t\t\t}\n\t\t});\n\n\t}\n\n\t/**\n\t * Use this method to indicate if application has already started using this\n\t * service. The service will have been asked to build the service request\n\t * and will not have commpleted the service startup.\n\t */\n\tisInUse() {\n\t\tconst method = `isInUse[${this.name}]  - #${this.myNumber}`;\n\t\tlogger.debug('%s inUse - %s', method, this.inUse);\n\n\t\treturn this.inUse;\n\t}\n\n\t/**\n\t * Use this method to indicate if this event service has an event endpoint\n\t * {@link Eventer} assigned and the event endpoint has a listening stream\n\t * connected and active.\n\t */\n\tisStarted() {\n\t\tconst method = `isStarted[${this.name}]  - #${this.myNumber}`;\n\n\t\tif (this._currentEventer && this._currentEventer.isStreamReady()) {\n\t\t\tlogger.debug('%s - true', method);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tlogger.debug('%s - false', method);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Use this method to indicate if this event service has event listeners\n\t * {@link EventListener} assigned and waiting for an event.\n\t */\n\thasListeners() {\n\t\tconst method = `hasListeners[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (this._eventListenerRegistrations.size > 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Internal method\n\t * Will close out all callbacks\n\t * Sends an error to all registered event callbacks\n\t */\n\t_closeAllCallbacks(err) {\n\t\tconst method = `_closeAllCallbacks[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tlogger.debug('%s - event registrations %s', method, this._eventListenerRegistrations.size);\n\t\tfor (const event_reg of this._eventListenerRegistrations.values()) {\n\t\t\tlogger.debug('%s - tell listener of the error:%s', method, event_reg);\n\t\t\ttry {\n\t\t\t\tevent_reg.onEvent(err);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('%s - %s', method, error);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - clear out the listener list', method);\n\t\tthis._eventListenerRegistrations.clear();\n\n\t\t// all done\n\t\tlogger.debug('%s - end', method);\n\t}\n\n\t_checkBlockNum(blockNumber) {\n\t\tlet _blockNumber = null;\n\t\tif (typeof blockNumber === 'string') {\n\t\t\tif (blockNumber.toLowerCase() === OLDEST) {\n\t\t\t\t_blockNumber = OLDEST;\n\t\t\t} else if (blockNumber.toLowerCase() === NEWEST) {\n\t\t\t\t_blockNumber = NEWEST;\n\t\t\t} else {\n\t\t\t\t// maybe it is a string number\n\t\t\t\t_blockNumber = convertToLong(blockNumber);\n\t\t\t}\n\t\t} else {\n\t\t\t// only check if they give us something, these are optional parameters\n\t\t\tif (typeof blockNumber !== 'undefined' && blockNumber !== null) {\n\t\t\t\t_blockNumber = convertToLong(blockNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn _blockNumber;\n\t}\n\n\t/**\n\t * @typedef {Object} EventRegistrationOptions\n\t * @property {boolean} unregister - Optional - This options setting indicates\n\t *  the registration should be removed (unregister) when the event\n\t *  is seen or the endBlock seen. When the application is using a timeout\n\t *  to only wait a\n\t *  specified amount of time for the transaction to be seen, the timeout\n\t *  processing should included the manual 'unregister' of the transaction\n\t *  event listener to avoid the event callbacks being called unexpectedly.\n\t *  The default for this setting is different for the different types of\n\t *  event listeners. For block listeners the default is false.\n\t *  For transaction listeners the default is true and the\n\t *  listener will be unregistered when a transaction with the id is\n\t *  seen by this listener or the endBlock is seen. For chaincode listeners\n\t *  the default will be false as the match filter might be intended for\n\t *  many transactions rather than a specific transaction.\n\t * @property {Number | string} [startBlock] - Optional. This will have this\n\t *  registered listener look for this event within the block.\n\t *  Blocks that have block numbers less than the startBlock will be\n\t *  ignored by this listener.\n\t *  Note: This EventService must be setup to listen for blocks in this\n\t *  range.\n\t * @property {Number | string} [endBlock] - Optional. This will have the\n\t *  registered listener stop looking at blocks when the block number is\n\t *  equal to or greater than the endBlock of this listener. The registered\n\t * listener will be unregistered if the unregister option is set to true.\n\t *  Note: This EventService must be setup to listen for blocks in this\n\t *  range.\n\t */\n\n\t/**\n\t * Unregister the event listener returned by\n\t * the register listener methods.\n\t *\n\t * @param {EventListener} eventListener - The registered listener.\n\t * @param {boolean} [notThrow] - When the listener is not found an error\n\t *  will be thrown when not included or false\n\t */\n\tunregisterEventListener(eventListener = checkParameter('eventListener'), notThrow) {\n\t\tconst method = `unregisterEventListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - eventListener:%s', method, eventListener);\n\t\tif (this._eventListenerRegistrations.has(eventListener)) {\n\t\t\tthis._eventListenerRegistrations.delete(eventListener);\n\t\t} else {\n\t\t\tif (!notThrow) {\n\t\t\t\tlogger.error('%s - event listener was not found', method);\n\t\t\t\tthrow Error('eventListener not found');\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - event listener was not found', method);\n\t\t\t\treturn; // nothing to do\n\t\t\t}\n\t\t}\n\n\t\tlet foundBlock = false;\n\t\tlet foundTx = false;\n\t\tlet foundChaincode = false;\n\t\tfor (const event_reg of this._eventListenerRegistrations.values()) {\n\t\t\tif (event_reg.listenerType === BLOCK) {\n\t\t\t\tfoundBlock = true;\n\t\t\t} else if (event_reg.listenerType === TX) {\n\t\t\t\tfoundTx = true;\n\t\t\t} else if (event_reg.listenerType === CHAINCODE) {\n\t\t\t\tfoundChaincode = true;\n\t\t\t}\n\t\t}\n\t\tthis._haveBlockListeners = foundBlock;\n\t\tthis._haveTxListeners = foundTx;\n\t\tthis._haveChaincodeListeners = foundChaincode;\n\n\t\tlogger.debug('%s - end', method);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Callback function that takes two parameters\n\t * @callback EventCallback\n\t * @param {Error} error - The \"error\" will be null unless this EventService has been shutdown.\n\t *  The shutdown may be caused by a network, connection error,\n\t *  by a call to the \"disconnect()\" method\n\t *  or when the fabric event service ends the connection to this EventService.\n\t *  This callback will also be called with an Error when the EventService is shutdown\n\t *  due to the last block being received if the service has been setup with an endBlock to be 'newest'\n\t *  or a specific block number that has been seen.\n\t * @param {EventInfo} event - The \"event\" will be the {@link EventInfo} object.\n\t */\n\n\n\t/**\n\t * Register a listener to receive chaincode events.\n\t * @param {string|RegExp} eventName - The exact name of the chaincode event or\n\t *  regular expression that will be matched against the name given to\n\t *  the target chaincode's call\n\t *  <code>stub.SetEvent(name, payload)</code>)\n\t * @param {EventCallback} callback\n\t * @param {EventRegistrationOptions} options - Options on the registrations to allow\n\t *  for start and end block numbers, automatically unregister.\n\t * @returns {EventListener} The EventListener instance to be used to\n\t *  remove this registration using {@link EventService#unregisterEvent})\n\t */\n\tregisterChaincodeListener(chaincodeId = checkParameter('chaincodeId'), eventName = checkParameter('eventName'), callback = checkParameter('callback'), options) {\n\t\tconst method = `registerChaincodeListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - %s - %s', method, chaincodeId, eventName);\n\n\t\tconst eventListener = new EventListener(this, CHAINCODE, callback, options, new RegExp(eventName), chaincodeId);\n\t\tthis._eventListenerRegistrations.set(eventListener, eventListener);\n\t\tthis._haveChaincodeListeners = true;\n\n\t\treturn eventListener;\n\t}\n\n\n\t/**\n\t * Register a listener to receive all blocks committed to this channel.\n\t * The listener's \"callback\" function gets called on the arrival of every\n\t * block.\n\t *\n\t * @param {EventCallback} callback\n\t * @param {EventRegistrationOptions} options - Options on the registrations to allow\n\t *  for start and end block numbers or to automatically unregister\n\t * @returns {EventListener} The EventListener instance to be used to\n\t *  remove this registration using {@link EventService#unregisterEvent})\n\t */\n\tregisterBlockListener(callback = checkParameter('callback'), options) {\n\t\tconst method = `registerBlockListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst eventListener = new EventListener(this, BLOCK, callback, options, null);\n\t\tthis._eventListenerRegistrations.set(eventListener, eventListener);\n\t\tthis._haveBlockListeners = true;\n\n\t\treturn eventListener;\n\t}\n\n\t/**\n\t * Register a callback function to receive a notification when the transaction\n\t * by the given id has been committed into a block. Using the special string\n\t * 'all' will indicate that this listener will notify (call) the callback\n\t * for every transaction written to the ledger.\n\t *\n\t * @param {string} txid - Transaction id string or 'all'\n\t * @param {EventCallback} callback\n\t * @param {EventRegistrationOptions} options - Options on the registrations to allow\n\t *  for start and end block numbers or to automatically unregister.\n\t * @returns {EventListener} The EventListener instance to be used to\n\t *  remove this registration using {@link EventService#unregisterEvent})\n\t */\n\tregisterTransactionListener(txid = checkParameter('txid'), callback = checkParameter('callback'), options) {\n\t\tconst method = `registerTransactionListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s start - txid:%s', method, txid);\n\n\t\tconst send_options = Object.assign({}, options);\n\t\tlet _txid = txid;\n\t\t// special case with 'all' transaction match\n\t\t// need to not unregister automatically\n\t\tif (txid.toLowerCase() === ALL) {\n\t\t\tlogger.debug('%s - listening for all transactions', method);\n\t\t\t_txid = ALL;\n\t\t\tif (typeof send_options.unregister === 'boolean') {\n\t\t\t\tlogger.debug('%s - unregister options is %s', method, send_options.unregister);\n\t\t\t} else {\n\t\t\t\tsend_options.unregister = false;\n\t\t\t}\n\t\t}\n\n\t\tconst eventListener = new EventListener(this, TX, callback, send_options, _txid);\n\t\tthis._eventListenerRegistrations.set(eventListener, eventListener);\n\t\tthis._haveTxListeners = true;\n\n\t\treturn eventListener;\n\t}\n\n\t/**\n\t * Utility method to find an event listener for a specific transaction ID\n\t *\n\t * @param {string} txid - the transaction ID of the event listener\n\t *  being searched.\n\t * @return {EventListener} The EventListener for the transaction ID provided\n\t */\n\tgetTransactionListener(txid = checkParameter('txid')) {\n\t\tconst method = `getTransactionListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\t\tlet result = null;\n\n\t\tfor (const eventListener of this._eventListenerRegistrations.values()) {\n\t\t\t// check each listener to see if this transaction ID matches\n\t\t\tif (eventListener.listenerType === TX) {\n\t\t\t\tif (eventListener.event === txid) {\n\t\t\t\t\tlogger.debug(`${method} - found the listener for ${txid}`);\n\t\t\t\t\tresult = eventListener;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * private internal method to check each registered listener\n\t * to see if it has requested to stop listening on a specific\n\t * blocknum\n\t */\n\t_processEndBlock(blockNumber = checkParameter('blockNumber')) {\n\t\tconst method = `_processEndBlock[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tfor (const listener of this._eventListenerRegistrations.values()) {\n\t\t\tif (listener.endBlock) {\n\t\t\t\tif (listener.endBlock.equals(blockNumber)) {\n\t\t\t\t\tlogger.debug('%s - listener endblock seen %s', method, blockNumber.toString());\n\t\t\t\t\tconst event = new EventInfo(this);\n\t\t\t\t\tevent.endBlockReceived = true;\n\t\t\t\t\tevent.blockNumber = blockNumber;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.onEvent(null, event);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error('%s - %s', method, error);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.unregisterEventListener(listener, true);\n\t\t\t\t\tlogger.debug('%s - automatically unregister %s, end block: %s has been seen', method, listener, blockNumber);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('%s - %s, end block: %s not seen', method, listener, blockNumber);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - %s, no end block defined', method, listener, blockNumber);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - end', method);\n\t}\n\n\t/*\n\t * private internal method for processing block events\n\t * @param {Object} block protobuf object\n\t */\n\t_processBlockEvents(full_block, filtered_block, private_data_map, blockNumber) {\n\t\tconst method = `_processBlockEvents[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - %s', method, this.blockType);\n\n\t\tif (!this._haveBlockListeners) {\n\t\t\tlogger.debug('%s - no block listeners', method);\n\t\t\treturn;\n\t\t}\n\n\t\tif (full_block) {\n\t\t\tlogger.debug('%s - have full block', method);\n\t\t} else if (filtered_block) {\n\t\t\tlogger.debug('%s - have filtered block', method);\n\t\t} else {\n\t\t\tlogger.debug('%s - missing block data', method);\n\t\t}\n\n\t\tif (private_data_map) {\n\t\t\tlogger.debug('%s - have private data', method);\n\t\t}\n\n\t\tfor (const blockReg of this._eventListenerRegistrations.values()) {\n\t\t\tif (blockReg.listenerType === BLOCK) {\n\t\t\t\tlogger.debug('%s - calling block listener callback', method);\n\t\t\t\tconst event = new EventInfo(this);\n\t\t\t\tevent.block = full_block;\n\t\t\t\tevent.filteredBlock = filtered_block;\n\t\t\t\tevent.privateData = private_data_map;\n\t\t\t\tevent.blockNumber = blockNumber;\n\n\t\t\t\ttry {\n\t\t\t\t\tblockReg.onEvent(null, event);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error('%s - %s', method, error);\n\t\t\t\t}\n\n\t\t\t\t// check to see if we should automatically unregister\n\t\t\t\tif (blockReg.unregister) {\n\t\t\t\t\tlogger.debug('%s - automatically unregister block listener for %s', method, blockReg);\n\t\t\t\t\tthis.unregisterEventListener(blockReg, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * private internal method for processing tx events\n\t * @param {Object} block protobuf object which might contain transactions\n\t */\n\t_processTxEvents(full_block, filtered_block) {\n\t\tconst method = `_processTxEvents[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (!this._haveTxListeners) {\n\t\t\tlogger.debug('%s - no tx listeners', method);\n\t\t\treturn;\n\t\t}\n\n\t\tif (filtered_block) {\n\t\t\tlogger.debug('%s filtered block number=%s', method, filtered_block.number);\n\t\t\tif (filtered_block.filtered_transactions) {\n\t\t\t\tlogger.debug('%s filtered filtered_transactions=%j', method, filtered_block.filtered_transactions);\n\t\t\t\tfor (const filtered_transaction of filtered_block.filtered_transactions) {\n\t\t\t\t\tif (filtered_transaction.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n\t\t\t\t\t\tthis._callTransactionListener(\n\t\t\t\t\t\t\tfiltered_transaction.txid,\n\t\t\t\t\t\t\tfiltered_transaction.tx_validation_code,\n\t\t\t\t\t\t\tfiltered_block.number,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tfiltered_block\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('%s full block number=%s', method, full_block.header.number);\n\t\t\tconst txStatusCodes = full_block.metadata.metadata[fabproto6.common.BlockMetadataIndex.TRANSACTIONS_FILTER];\n\t\t\tfor (let index = 0; index < full_block.data.data.length; index++) {\n\t\t\t\tconst channel_header = full_block.data.data[index].payload.header.channel_header;\n\t\t\t\tif (channel_header.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n\t\t\t\t\tthis._callTransactionListener(\n\t\t\t\t\t\tchannel_header.tx_id,\n\t\t\t\t\t\ttxStatusCodes[index],\n\t\t\t\t\t\tfull_block.header.number,\n\t\t\t\t\t\tfull_block\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* internal utility method */\n\t_callTransactionListener(txId, validationCode, blockNumber, full_block, filtered_block) {\n\t\tconst method = `_callTransactionListener[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tfor (const transReg of this._eventListenerRegistrations.values()) {\n\t\t\t// check each listener to see if this transaction ID matches\n\t\t\tif (transReg.listenerType === TX) {\n\t\t\t\tif (transReg.event === txId || transReg.event === ALL) {\n\t\t\t\t\tlogger.debug('%s - about to call the transaction call back with code=%s tx=%s', method, validationCode, txId);\n\t\t\t\t\tconst event = new EventInfo(this);\n\t\t\t\t\tevent.blockNumber = blockNumber;\n\t\t\t\t\tevent.transactionId = txId;\n\t\t\t\t\tevent.status = convertValidationCode(validationCode);\n\t\t\t\t\tevent.block = full_block;\n\t\t\t\t\tevent.filteredBlock = filtered_block;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransReg.onEvent(null, event);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error('%s - %s', method, error);\n\t\t\t\t\t}\n\n\t\t\t\t\t// check to see if we should automatically unregister\n\t\t\t\t\tif (transReg.unregister) {\n\t\t\t\t\t\tlogger.debug('%s - automatically unregister tx listener for %s', method, txId);\n\t\t\t\t\t\tthis.unregisterEventListener(transReg, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('%s - tx listener for %s - not called', method, transReg.event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * private internal method for processing chaincode events\n\t * @param {Object} block protobuf object which might contain the chaincode event from the fabric\n\t */\n\t_processChaincodeEvents(full_block, filtered_block) {\n\t\tconst method = `_processChaincodeEvents[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (!this._haveChaincodeListeners) {\n\t\t\tlogger.debug('%s - no registered chaincode event \"listeners\"', method);\n\t\t\treturn;\n\t\t}\n\t\tconst allEvents = new Map();\n\t\tif (filtered_block) {\n\t\t\tif (filtered_block.filtered_transactions) {\n\t\t\t\tfor (const filtered_transaction of filtered_block.filtered_transactions) {\n\t\t\t\t\tif (filtered_transaction.transaction_actions) {\n\t\t\t\t\t\tif (filtered_transaction.transaction_actions.chaincode_actions) {\n\t\t\t\t\t\t\tfor (const chaincode_action of filtered_transaction.transaction_actions.chaincode_actions) {\n\t\t\t\t\t\t\t\tlogger.debug('%s - filtered block chaincode_event %j', method, chaincode_action);\n\t\t\t\t\t\t\t\tthis._queueChaincodeEvent(\n\t\t\t\t\t\t\t\t\tchaincode_action.chaincode_event,\n\t\t\t\t\t\t\t\t\tfiltered_block.number,\n\t\t\t\t\t\t\t\t\tfiltered_transaction.txid,\n\t\t\t\t\t\t\t\t\tfiltered_transaction.tx_validation_code,\n\t\t\t\t\t\t\t\t\tallEvents\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('%s - have full block %j', method, full_block);\n\n\t\t\tfor (let index = 0; index < full_block.data.data.length; index++) {\n\t\t\t\tlogger.debug('%s - trans index=%s', method, index);\n\t\t\t\ttry {\n\t\t\t\t\tconst env = full_block.data.data[index];\n\t\t\t\t\tconst channel_header = env.payload.header.channel_header;\n\t\t\t\t\t// only ENDORSER_TRANSACTION have chaincode events\n\t\t\t\t\tif (channel_header.type === fabproto6.common.HeaderType.ENDORSER_TRANSACTION) {\n\t\t\t\t\t\tconst tx = env.payload.data;\n\t\t\t\t\t\tif (tx && tx.actions) {\n\t\t\t\t\t\t\tfor (const {payload} of tx.actions) {\n\t\t\t\t\t\t\t\tconst chaincode_event = payload.action.proposal_response_payload.extension.events;\n\t\t\t\t\t\t\t\tlogger.debug('%s - full block chaincode_event %j', method, chaincode_event);\n\n\t\t\t\t\t\t\t\tconst txStatusCodes = full_block.metadata.metadata[fabproto6.common.BlockMetadataIndex.TRANSACTIONS_FILTER];\n\t\t\t\t\t\t\t\tconst val_code = txStatusCodes[index];\n\n\t\t\t\t\t\t\t\tthis._queueChaincodeEvent(\n\t\t\t\t\t\t\t\t\tchaincode_event,\n\t\t\t\t\t\t\t\t\tfull_block.header.number,\n\t\t\t\t\t\t\t\t\tchannel_header.tx_id,\n\t\t\t\t\t\t\t\t\tval_code,\n\t\t\t\t\t\t\t\t\tallEvents);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug('%s - no transactions or transaction actions', method);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug('%s - full_block is not endorser transaction type', method);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('%s - Error with chaincode event processing :: %s', method, err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send all events for each listener\n\t\tfor (const [chaincodeListener, event] of allEvents.entries()) {\n\t\t\tlogger.debug('%s - calling callback - %s', method, chaincodeListener.event);\n\n\t\t\ttry {\n\t\t\t\tchaincodeListener.onEvent(null, event);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('%s - %s', method, error);\n\t\t\t}\n\n\t\t\t// see if we should automatically unregister this event listener\n\t\t\tif (chaincodeListener.unregister) {\n\t\t\t\tlogger.debug('%s - automatically unregister chaincode event listener setting', method);\n\t\t\t\tthis.unregisterEventListener(chaincodeListener, true);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - end', method);\n\t}\n\n\t_queueChaincodeEvent(chaincode_event, blockNumber, txId, val_code, allEvents) {\n\t\tconst method = `_queueChaincodeEvent[${this.name}] - #${this.myNumber}`;\n\t\tlogger.debug('%s - start - chaincode_event %j', method, chaincode_event);\n\n\t\tconst status = convertValidationCode(val_code);\n\n\t\tlogger.debug('%s - txid=%s  val_code=%s', method, txId, status);\n\n\t\tfor (const chaincodeListener of this._eventListenerRegistrations.values()) {\n\t\t\tlogger.debug('%s - checking regisistered chaincode event %s %s', method, chaincodeListener.event, chaincodeListener.chaincodeId);\n\t\t\t// check each listener to see if this chaincode event matches\n\t\t\tif (chaincodeListener.listenerType === CHAINCODE &&\n\t\t\t\tchaincodeListener.chaincodeId === chaincode_event.chaincode_id &&\n\t\t\t\tchaincodeListener.event.test(chaincode_event.event_name)) {\n\t\t\t\t// we have a match - save it to be sent later\n\t\t\t\tlogger.debug('%s - queuing chaincode event: %s', method, chaincode_event.event_name);\n\t\t\t\tlet event = allEvents.get(chaincodeListener);\n\t\t\t\tif (!event) {\n\t\t\t\t\tevent = new EventInfo(this);\n\t\t\t\t\tevent.blockNumber = blockNumber;\n\t\t\t\t\tevent.chaincodeEvents = [];\n\t\t\t\t\tallEvents.set(chaincodeListener, event);\n\t\t\t\t}\n\t\t\t\tevent.chaincodeEvents.push(new ChaincodeEvent(\n\t\t\t\t\tchaincode_event.chaincode_id,\n\t\t\t\t\ttxId,\n\t\t\t\t\tstatus,\n\t\t\t\t\tchaincode_event.event_name,\n\t\t\t\t\tchaincode_event.payload\n\t\t\t\t));\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - NOT queuing chaincode event: %s', method, chaincode_event.event_name);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = EventService;\n\n// convert to a string of the enum\nfunction convertValidationCode(code) {\n\tif (typeof code === 'string') {\n\t\tlogger.debug('convertValidationCode - code %s', code);\n\n\t\treturn code;\n\t}\n\tconst status = fabproto6.protos.TxValidationCode[code];\n\tlogger.debug('convertValidationCode - status %s', status);\n\n\treturn status;\n}\n\n/**\n * @typedef {Object} ChaincodeEvent\n * @property {string} chaincode_id - The name of chaincode that sourced this\n *  event.\n * @property {string} transactionId - The transaction ID of this event.\n * @property {string} status - The transaction status of the transaction.\n * @property {string} eventName - The string that is the eventName of this\n *  event as set by the chaincode during endorsement.\n *  <code>stub.SetEvent(eventName, payload)</code>\n * @property {byte[]} payload - Application-specific byte array that the chaincode\n *  set when it called <code>stub.SetEvent(eventName, payload)</code>\n */\n\nclass ChaincodeEvent {\n\t/**\n\t * Constructs an object that contains all information from the chaincode event.\n\t * message ChaincodeEvent {\n\t *   string chaincode_id = 1;\n\t *   string tx_id = 2;\n\t *   string event_name = 3;\n\t *   bytes payload = 4;\n\t */\n\tconstructor(chaincodeId, transactionId, status, eventName, payload) {\n\t\tthis.chaincodeId = chaincodeId;\n\t\tthis.transactionId = transactionId;\n\t\tthis.status = status;\n\t\tthis.eventName = eventName;\n\t\tthis.payload = payload;\n\t}\n}\n\n/**\n * @typedef {Object} EventInfo\n * @property {EventService} eventService - This EventService.\n * @property {Long} blockNumber - The block number that contains this event.\n * @property {string} [transactionId] - The transaction ID of this event\n * @property {string} [transactionStatus] - The transaction status of this\n *  event.\n * @property {boolean} endBlockReceived - Indicates if the endBlock as\n *  defined by the listener has been seen.\n * @property {ChaincodeEvent[]} chaincodeEvents - An array of {@link ChaincodeEvent}.\n * @property {object} [block] - The decode of the full block received\n * @property {object} [filteredBlock] - The decode of the filtered block received\n * @property {object} [privateData] -A data map of any included private data.\n */\n\nclass EventInfo {\n\t/**\n\t * Constructs a {@link EventInfo} object that contains all information about an Event.\n\t */\n\tconstructor(eventService) {\n\t\tthis.eventService = eventService;\n\t\tthis.blockNumber;\n\t\tthis.transactionId;\n\t\tthis.transactionStatus;\n\t\tthis.endBlockReceived = false;\n\t\tthis.chaincodeEvents = [];\n\t\tthis.block;\n\t\tthis.filteredBlock;\n\t\tthis.privateData;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}