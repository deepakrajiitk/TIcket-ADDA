{"ast":null,"code":"/*\n Copyright 2019 IBM All Rights Reserved.\n\n SPDX-License-Identifier: Apache-2.0\n\n*/\n\nconst TYPE = 'DiscoveryHandler';\nconst Long = require('long');\nconst settle = require('promise-settle');\nconst ServiceHandler = require('./ServiceHandler.js');\nconst fabproto6 = require('fabric-protos');\nconst {\n  randomize,\n  checkParameter,\n  getLogger,\n  getConfigSetting,\n  convertToLong\n} = require('./Utils.js');\nconst logger = getLogger(TYPE);\nconst BLOCK_HEIGHT = 'ledgerHeight';\nconst RANDOM = 'random';\n\n/**\n * This is an implementation for a handler.\n *\n * @class\n * @extends ServiceHandler\n */\nclass DiscoveryHandler extends ServiceHandler {\n  /**\n   * constructor\n   *\n   * @param {DiscoveryService} discoveryService - The discovery service for this handler.\n   */\n  constructor(discoveryService) {\n    logger.debug('DiscoveryHandler.constructor - start');\n    super();\n    this.discoveryService = discoveryService;\n    this.type = TYPE;\n  }\n\n  /**\n   * This will send transactions to all peers found by discovery.\n   * @param {*} signedProposal\n   * @param {Object} request - Include a 'mspid' when just peers from\n   *  an organization are required\n   */\n  async query() {\n    let signedProposal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('signedProposal');\n    let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'query';\n    logger.debug('%s - start', method);\n    const {\n      requestTimeout,\n      mspid\n    } = request;\n    let results;\n    let timeout = getConfigSetting('requestTimeout');\n    if (requestTimeout) {\n      timeout = requestTimeout;\n    }\n\n    // forces a refresh if needed\n    await this.discoveryService.getDiscoveryResults(true);\n    const responses = [];\n    const endorsers = this.discoveryService.channel.getEndorsers(mspid);\n    if (endorsers && endorsers.length > 0) {\n      logger.debug('%s - found %s endorsers assigned to channel', method, endorsers.length);\n      const promises = endorsers.map(async endorser => {\n        return endorser.sendProposal(signedProposal, timeout);\n      });\n      results = await settle(promises);\n      results.forEach(result => {\n        if (result.isFulfilled()) {\n          logger.debug(`query - Promise is fulfilled: ${result.value()}`);\n          responses.push(result.value());\n        } else {\n          logger.debug(`query - Promise is rejected: ${result.reason()}`);\n          responses.push(result.reason());\n        }\n      });\n    } else {\n      throw new Error('No endorsers assigned to the channel');\n    }\n    return responses;\n  }\n\n  /**\n   * This will submit transactions to be committed to one committer at a\n   * time from a list currently assigned to the channel.\n   * @param {*} signedProposal\n   * @param {Object} request\n   */\n  async commit() {\n    let signedEnvelope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('signedEnvelope');\n    let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'commit';\n    logger.debug('%s - start', method);\n    const {\n      requestTimeout,\n      mspid\n    } = request;\n    let timeout = getConfigSetting('requestTimeout');\n    if (requestTimeout) {\n      timeout = requestTimeout;\n    }\n\n    // force a refresh if needed\n    await this.discoveryService.getDiscoveryResults(true);\n    const committers = this.discoveryService.channel.getCommitters(mspid);\n    if (committers && committers.length > 0) {\n      logger.debug('%s - found %s committers assigned to channel', method, committers.length);\n      randomize(committers);\n      let results;\n      // first pass only try a committer that is in good standing\n      results = await this._commitSend(committers, signedEnvelope, timeout, false);\n      if (results.error) {\n        // since we did not get a good result, try another pass, this time try to\n        // have the orderers reconnect\n        results = await this._commitSend(committers, signedEnvelope, timeout, true);\n      }\n      if (results.commit) {\n        logger.debug('%s - return commit status %s ', method, results.commit);\n        return results.commit;\n      }\n      logger.debug('%s - return error %s ', method, results.error);\n      throw results.error;\n    } else {\n      throw new Error('No committers assigned to the channel');\n    }\n  }\n  async _commitSend(committers, signedEnvelope, timeout, reconnect) {\n    const method = 'commit';\n    logger.debug('%s - start', method);\n    let return_error;\n    // loop through the committers trying to complete one successfully\n    for (const committer of committers) {\n      logger.debug('%s - sending to committer %s', method, committer.name);\n      try {\n        const isConnected = await committer.checkConnection(reconnect);\n        if (isConnected) {\n          const commit = await committer.sendBroadcast(signedEnvelope, timeout);\n          if (commit) {\n            if (commit.status === 'SUCCESS') {\n              logger.debug('%s - Successfully sent transaction to the committer %s', method, committer.name);\n              return {\n                error: undefined,\n                commit\n              };\n            } else {\n              logger.debug('%s - Failed, status was not \"success\" from the send transaction to the committer. status:%s', method, commit.status);\n              return_error = new Error('Failed to send transaction successfully to the committer. status:' + commit.status);\n            }\n          } else {\n            return_error = new Error('Failed to receive committer status');\n            logger.debug('%s - Failed, no status received on the send transaction to the committer %s', method, committer.name);\n          }\n        } else {\n          let error_message = `Failed, committer ${committer.name} is not connected`;\n          if (reconnect) {\n            error_message = `Failed, not able to reconnect to committer ${committer.name}`;\n          }\n          return_error = new Error(error_message);\n        }\n      } catch (error) {\n        logger.debug('%s - Caught: %s', method, error.toString());\n        return_error = error;\n      }\n    }\n    logger.debug('%s - return error %s ', method, return_error.toString());\n    return {\n      error: return_error\n    };\n  }\n\n  /**\n   * This method will submit transactions to be endorsed to endorsers as\n   * determined by the endorser's discovery service\n   * @param {*} signedProposal\n   * @param {*} request\n   */\n  async endorse() {\n    let signedProposal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('signedProposal');\n    let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'endorse';\n    logger.debug('%s - start', method);\n    let timeout = getConfigSetting('requestTimeout');\n    if (request.requestTimeout) {\n      timeout = request.requestTimeout;\n    }\n    const results = await this.discoveryService.getDiscoveryResults(true);\n    if (results && results.peers_by_org && request.requiredOrgs) {\n      // special case when user knows which organizations to send the endorsement\n      // let's build our own endorsement plan so that we can use the sorting and sending code\n      const endorsement_plan = this._buildRequiredOrgPlan(results.peers_by_org, request.requiredOrgs);\n\n      // remove conflicting settings\n      const orgs_request = {\n        sort: request.sort,\n        preferredHeightGap: request.preferredHeightGap\n      };\n      return this._endorse(endorsement_plan, orgs_request, signedProposal, timeout);\n    } else if (results && results.endorsement_plan) {\n      // normal processing of the discovery results\n      const working_discovery = JSON.parse(JSON.stringify(results.endorsement_plan));\n      return this._endorse(working_discovery, request, signedProposal, timeout);\n    } else if (results && results.peers_by_org) {\n      // special case when the chaincode is system chaincode without an endorsement policy\n      const endorsement_plan = this._buildAllOrgPlan(results.peers_by_org);\n      return this._endorse(endorsement_plan, request, signedProposal, timeout);\n    } else {\n      throw Error('No endorsement plan available');\n    }\n  }\n  async _endorse() {\n    let endorsement_plan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('endorsement_plan');\n    let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let proposal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : checkParameter('proposal');\n    let timeout = arguments.length > 3 ? arguments[3] : undefined;\n    const method = '_endorse';\n    logger.debug('%s - starting', method);\n    endorsement_plan.endorsements = {};\n    const results = {};\n    results.endorsements = null; // will be from just one layout\n    results.failed_endorsements = []; // from all failed layouts\n    results.success = false;\n    const required = this._create_map(request.required, 'endpoint');\n    const preferred = this._create_map(request.preferred, 'endpoint');\n    const ignored = this._create_map(request.ignored, 'endpoint');\n    const required_orgs = this._create_map(request.requiredOrgs, 'mspid');\n    const preferred_orgs = this._create_map(request.preferredOrgs, 'mspid');\n    const ignored_orgs = this._create_map(request.ignoredOrgs, 'mspid');\n    let preferred_height_gap = Long.fromInt(1); // default of one block\n    try {\n      if (Number.isInteger(request.preferredHeightGap) || request.preferredHeightGap) {\n        preferred_height_gap = convertToLong(request.preferredHeightGap, true);\n      }\n    } catch (error) {\n      throw Error('preferred_height_gap setting is not a number');\n    }\n    let sort = BLOCK_HEIGHT;\n    if (request.sort) {\n      if (request.sort === BLOCK_HEIGHT) {\n        sort = BLOCK_HEIGHT;\n      } else if (request.sort === RANDOM) {\n        sort = RANDOM;\n      } else {\n        throw Error('sort parameter is not valid');\n      }\n    }\n\n    // fix the peer group lists to reflect the options the user has provided\n    this._modify_groups(required, preferred, ignored, required_orgs, preferred_orgs, ignored_orgs, preferred_height_gap, sort, endorsement_plan);\n\n    // always randomize the layouts\n    endorsement_plan.layouts = this._getRandom(endorsement_plan.layouts);\n    let matchError = false;\n\n    // loop through the layouts trying to complete one successfully\n    for (const layout_index in endorsement_plan.layouts) {\n      logger.debug('%s - starting layout plan %s', method, layout_index);\n      const layout_results = await this._endorse_layout(layout_index, endorsement_plan, proposal, timeout);\n      // if this layout is successful then we are done\n      if (layout_results.success) {\n        // make sure all responses have the same endorsement read/write set\n        if (this.compareProposalResponseResults(layout_results.endorsements)) {\n          logger.debug('%s - layout plan %s completed successfully', method, layout_index);\n          results.endorsements = layout_results.endorsements;\n          results.success = true;\n          break;\n        } else {\n          matchError = true;\n        }\n      }\n      logger.debug('%s - layout plan %s did not complete successfully', method, layout_index);\n      results.failed_endorsements = results.failed_endorsements.concat(layout_results.endorsements);\n    }\n    if (!results.success) {\n      let error;\n      if (matchError) {\n        error = new Error('Peer endorsements do not match');\n      } else {\n        error = new Error('Endorsement has failed');\n      }\n      error.endorsements = results.failed_endorsements;\n      return [error];\n    }\n    return results.endorsements;\n  }\n  async _endorse_layout(layout_index, endorsement_plan, proposal, timeout) {\n    const method = '_endorse_layout';\n    logger.debug('%s - start', method);\n    const results = {};\n    results.endorsements = [];\n    results.success = true;\n    const layout = endorsement_plan.layouts[layout_index];\n    let endorser_process_index = 0;\n    const endorsers = [];\n    for (const group_name in layout) {\n      const required = layout[group_name];\n      const group = endorsement_plan.groups[group_name];\n      // make sure there are enough peers in the group to satisfy required\n      if (required > group.peers.length) {\n        results.success = false;\n        const error = new Error(`Endorsement plan group does not contain enough peers (${group.peers.length}) to satisfy policy (required:${required})`);\n        logger.debug(error.message);\n        results.endorsements.push(error);\n        break; // no need to look at other groups, this layout failed\n      }\n\n      for (let x = 0; x < required; x++) {\n        const endorser_process = this._build_endorse_group_member(endorsement_plan, group, proposal, timeout, endorser_process_index++, group_name);\n        endorsers.push(endorser_process);\n      }\n    }\n    if (results.success) {\n      results.endorsements = await this._execute_endorsements(endorsers);\n      for (const endorsement of results.endorsements) {\n        if (endorsement instanceof Error) {\n          results.success = false;\n        } else if (typeof endorsement.success === 'boolean' && endorsement.success === false) {\n          results.success = false;\n        }\n      }\n    }\n    return results;\n  }\n  async _execute_endorsements(endorser_processes) {\n    const method = '_execute_endorsements';\n    logger.debug('%s - start', method);\n    const results = await Promise.all(endorser_processes);\n    const responses = [];\n    for (const result of results) {\n      if (result instanceof Error) {\n        logger.debug('%s - endorsement failed: %s', method, result);\n      } else {\n        logger.debug('%s - endorsement is complete', method);\n      }\n      responses.push(result);\n    }\n    return responses;\n  }\n  _buildRequiredOrgPlan(peers_by_org, required_orgs) {\n    const method = '_buildRequiredOrgPlan';\n    logger.debug('%s - starting', method);\n    const endorsement_plan = {\n      plan_id: 'required organizations'\n    };\n    endorsement_plan.groups = {};\n    endorsement_plan.layouts = [{}]; // only one layout which will have all organizations\n\n    const notFound = [];\n    for (const mspid of required_orgs) {\n      logger.debug(`${method} - found org:${mspid}`);\n      endorsement_plan.groups[mspid] = {}; // make a group for each\n      if (peers_by_org[mspid] && peers_by_org[mspid].peers && peers_by_org[mspid].peers.length > 0) {\n        endorsement_plan.groups[mspid].peers = JSON.parse(JSON.stringify(peers_by_org[mspid].peers)); // now put in all peers from that organization\n        endorsement_plan.layouts[0][mspid] = 1; // add this org to the one layout and require one peer to endorse\n      } else {\n        logger.debug('%s - discovery plan does not have peers for %', method, mspid);\n        notFound.push(mspid);\n      }\n    }\n    if (notFound.length > 0) {\n      throw Error(`The discovery service did not find any peers active for ${notFound} organizations`);\n    }\n    return endorsement_plan;\n  }\n  _buildAllOrgPlan(peers_by_org) {\n    const method = '_buildAllOrgPlan';\n    logger.debug('%s - starting', method);\n    const endorsement_plan = {\n      plan_id: 'all organizations'\n    };\n    endorsement_plan.groups = {};\n    endorsement_plan.layouts = [{}]; // only one layout which will have all organizations\n    let notFound = true;\n    Object.keys(peers_by_org).forEach(mspid => {\n      const org = peers_by_org[mspid];\n      if (org.peers && org.peers.length > 0) {\n        endorsement_plan.groups[mspid] = {}; // make a group for each\n        endorsement_plan.groups[mspid].peers = JSON.parse(JSON.stringify(org.peers)); // now put in all peers from that organization\n        endorsement_plan.layouts[0][mspid] = 1; // add this org to the one layout and require one peer to endorse\n        notFound = false;\n      } else {\n        logger.debug('%s - discovery plan does not have peers for %', method, mspid);\n      }\n    });\n    if (notFound) {\n      throw Error('The discovery service did not find any peers active');\n    }\n    return endorsement_plan;\n  }\n\n  /*\n   * utility method to build a promise that will return one of the required\n   * endorsements or an error object\n   */\n  _build_endorse_group_member(endorsement_plan, group, proposal, timeout, endorser_process_index, group_name) {\n    const method = '_build_endorse_group_member >> ' + group_name + ':' + endorser_process_index;\n    logger.debug('%s - start', method);\n\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async resolve => {\n      let endorsement = null;\n      for (const peer_info of group.peers) {\n        endorsement = endorsement_plan.endorsements[peer_info.name];\n        if (endorsement) {\n          logger.debug('%s - existing peer %s endorsement will be used', method, peer_info.name);\n        } else {\n          if (peer_info.in_use) {\n            logger.debug('%s - peer in use %s, skipping', method, peer_info.name);\n          } else {\n            const peer = this._getPeer(peer_info.endpoint);\n            if (peer) {\n              logger.debug('%s - send endorsement to %s', method, peer_info.name);\n              peer_info.in_use = true;\n              try {\n                const isConnected = await peer.checkConnection();\n                if (isConnected) {\n                  endorsement = await peer.sendProposal(proposal, timeout);\n                  // save this endorsement results in case we try this peer again\n                  logger.debug('%s - endorsement completed to %s', method, peer_info.name);\n                } else {\n                  endorsement = peer.getCharacteristics(new Error(`Peer ${peer.name} is not connected`));\n                }\n              } catch (error) {\n                endorsement = peer.getCharacteristics(error);\n                logger.error('%s - error on endorsement to %s error %s', method, peer_info.name, error);\n              }\n              // save this endorsement results in case we try this peer again\n              // eslint-disable-next-line require-atomic-updates\n              endorsement_plan.endorsements[peer_info.name] = endorsement;\n            } else {\n              logger.debug('%s - peer %s not assigned to this channel', method, peer_info.name);\n            }\n          }\n        }\n        if (endorsement && !(endorsement instanceof Error)) {\n          logger.debug('%s - peer %s endorsement will be used', method, peer_info.name);\n          break;\n        }\n      }\n      if (endorsement) {\n        logger.debug('%s - returning endorsement', method);\n        resolve(endorsement);\n      } else {\n        logger.error('%s - returning an error endorsement, no endorsement made', method);\n        resolve(new Error('No endorsement available'));\n      }\n    });\n  }\n\n  /*\n   * utility method that will take a group of peers and modify the order\n   * of the peers within the group based on the user's requirements\n   *\n   * for each group\n   *  - remove the ignored and all non required\n   *  - sort group list by ledger height (larger on top) or randomly\n   *  - walk sorted list\n   *      -- put the preferred peers & organizations in the priority bucket if ledger height acceptable\n   *      -- put others in non priority bucket\n   *  - build final modified group (this will maintain how they were sorted)\n   *      -- pull peers from priority bucket\n   *      -- pull peers from non priority bucket\n   *  - return modified group\n   */\n  _modify_groups(required, preferred, ignored, required_orgs, preferred_orgs, ignored_orgs, preferred_height_gap, sort, endorsement_plan) {\n    const method = '_modify_groups';\n    logger.debug('%s - start', method);\n    logger.debug('%s - required:%j', method, required);\n    logger.debug('%s - preferred:%j', method, preferred);\n    logger.debug('%s - ignored:%j', method, ignored);\n    logger.debug('%s - required_orgs:%j', method, required_orgs);\n    logger.debug('%s - preferred_orgs:%j', method, preferred_orgs);\n    logger.debug('%s - ignored_orgs:%j', method, ignored_orgs);\n    logger.debug('%s - preferred_height_gap:%s', method, preferred_height_gap);\n    logger.debug('%s - sort: %s', method, sort);\n    logger.debug('%s - endorsement_plan:%j', method, endorsement_plan);\n    for (const group_name in endorsement_plan.groups) {\n      const group = endorsement_plan.groups[group_name];\n      for (const peer of group.peers) {\n        peer.ledgerHeight = Long.fromBits(peer.ledgerHeight.low, peer.ledgerHeight.high, true);\n      }\n\n      // remove ignored and non-required\n      const clean_list = this._removePeers(ignored, ignored_orgs, required, required_orgs, group.peers);\n\n      // get the highest ledger height if needed\n      let highest = null;\n      if (sort === BLOCK_HEIGHT) {\n        highest = this._findHighest(clean_list);\n      }\n\n      // sort based on ledger height or randomly\n      const sorted_list = this._sortPeerList(sort, clean_list);\n      // pop the priority peers off the sorted list\n      const split_lists = this._splitList(preferred, preferred_orgs, preferred_height_gap, highest, sorted_list);\n      // put the priorities on top\n      const reordered_list = split_lists.priority.concat(split_lists.non_priority);\n      // set the rebuilt peer list into the group\n      group.peers = reordered_list;\n    }\n    logger.debug('%s - updated endorsement_plan:%j', method, endorsement_plan);\n  }\n  _create_map(array) {\n    const map = new Map();\n    if (array && Array.isArray(array)) {\n      array.forEach(item => {\n        map.set(item, item);\n      });\n    }\n    return map;\n  }\n\n  /*\n   * utility method to remove peers that are ignored or not on the required list\n   */\n  _removePeers(ignored_peers, ignored_orgs, required_peers, required_orgs, peers) {\n    const method = '_removePeers';\n    logger.debug('%s - start', method);\n    const keep_list = [];\n    for (const peer of peers) {\n      let found = ignored_peers.has(peer.name);\n      if (!found) {\n        found = ignored_orgs.has(peer.mspid);\n        if (!found) {\n          // if the user has requested required peers/orgs\n          // then all peers that stay on the list must be\n          // one of those peers or in one of those orgs\n          if (required_peers.size || required_orgs.size) {\n            found = required_peers.has(peer.name);\n            if (!found) {\n              found = required_orgs.has(peer.mspid);\n            }\n            // if we did not find it on a either list then\n            // this peer will not be added to the keep list\n            if (!found) {\n              continue; // do not add this peer to the keep list\n            }\n          }\n\n          // looks like this peer is not on the ignored list and\n          // is on the required list (if being used);\n          keep_list.push(peer);\n        }\n      }\n    }\n    return keep_list;\n  }\n  _findHighest(peers) {\n    let highest = Long.fromValue(0);\n    for (const peer of peers) {\n      try {\n        if (peer.ledgerHeight.greaterThan(highest)) {\n          highest = peer.ledgerHeight;\n        }\n      } catch (error) {\n        logger.error('problem finding highest block with %s', error);\n        throw Error(`Unable to find highest block value :: ${error.toString()}`);\n      }\n    }\n    return highest;\n  }\n  _sortPeerList(sort, peers) {\n    const method = '_sortList';\n    logger.debug('%s - start - %s', method, sort);\n    let sorted = null;\n    if (sort === BLOCK_HEIGHT) {\n      sorted = peers.sort((a, b) => {\n        logger.debug('%s - sorting descending', method);\n        if (a.ledgerHeight && !b.ledgerHeight) {\n          logger.debug('%s - a exist (%s) - b does not exist', method, a.ledgerHeight);\n          return -1;\n        } else if (!a.ledgerHeight && b.ledgerHeight) {\n          logger.debug('%s - a does not exist - b exist (%s)', method, b.ledgerHeight);\n          return 1;\n        } else {\n          const result = -1 * a.ledgerHeight.compare(b.ledgerHeight);\n          logger.debug('%s - compare result: %s for a:(%s) b:(%s) ', method, result, a.ledgerHeight.toString(), b.ledgerHeight.toString());\n          return result;\n        }\n      });\n    } else {\n      // must be random\n      sorted = this._getRandom(peers);\n    }\n    return sorted;\n  }\n  _splitList(preferred_peers, preferred_orgs, preferred_height_gap, highest, sorted_list) {\n    const method = '_splitList';\n    logger.debug('%s - start', method);\n    const priority = [];\n    const non_priority = [];\n    for (const peer of sorted_list) {\n      // first see if on the preferred lists\n      let found = preferred_peers.has(peer.name);\n      if (!found) {\n        logger.debug('%s - peer %s not found on the preferred peer list', method, peer.name);\n        found = preferred_orgs.has(peer.mspid);\n        if (found) {\n          logger.debug('%s - peer %s found on preferred org list', method, peer.name);\n        } else {\n          logger.debug('%s - peer %s not found on preferred org list', method, peer.name);\n        }\n      } else {\n        logger.debug('%s - peer %s found on the preferred peer list', method, peer.name);\n      }\n\n      // if not on the preferred lists and we are sorting by block hieght\n      // check the gap that indicates that it will be up to date shortly and it should be used\n      if (!found && highest) {\n        if (peer.ledgerHeight) {\n          logger.debug('%s - checking preferred gap of %s', method, preferred_height_gap);\n          logger.debug('%s - peer.ledgerHeight %s', method, peer.ledgerHeight);\n          if (highest.subtract(peer.ledgerHeight).greaterThan(preferred_height_gap)) {\n            found = false; // this peer should not be on the priority list\n            logger.debug('%s -gap too big, peer should not be on priority list', method, peer.name);\n          } else {\n            found = true; // this peer should not be on the priority list\n            logger.debug('%s - gap is OK, peer should be on priority list', method, peer.name);\n          }\n        } else {\n          logger.debug('%s - peer has no ledgerHeight, not a priority peer');\n          found = false;\n        }\n      } else {\n        logger.debug('%s - not checking the preferred height gap', method);\n      }\n      if (found) {\n        priority.push(peer);\n      } else {\n        non_priority.push(peer);\n      }\n    }\n\n    // priority peers are all the same, try not to use the same\n    // one everytime\n    const randomized_priority = this._getRandom(priority);\n    return {\n      priority: randomized_priority,\n      non_priority\n    };\n  }\n\n  /*\n   * utility function to return a random list\n   */\n  _getRandom(start_list) {\n    let len = start_list.length;\n    const result_list = new Array(len);\n    const taken = new Array(len);\n    let n = len;\n    while (n--) {\n      const x = Math.floor(Math.random() * len);\n      result_list[n] = start_list[x in taken ? taken[x] : x];\n      taken[x] = --len in taken ? taken[len] : len;\n    }\n    return result_list;\n  }\n\n  /*\n   * utility function to return a peer with the requested url\n   */\n  _getPeer(address) {\n    let result = null;\n    if (address) {\n      const host_port = address.split(':');\n      const url = this.discoveryService._buildUrl(host_port[0], host_port[1]);\n      const peers = this.discoveryService.channel.getEndorsers();\n      for (const peer of peers) {\n        if (peer.endpoint && peer.endpoint.url === url) {\n          result = peer;\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  // internal utility method to decode and get the write set from an endorsement\n  _getProposalResponseResults() {\n    let proposaResponse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('proposalResponse');\n    if (!proposaResponse.payload) {\n      throw new Error('Parameter must be a ProposalResponse Object');\n    }\n    const payload = fabproto6.protos.ProposalResponsePayload.decode(proposaResponse.payload);\n    const extension = fabproto6.protos.ChaincodeAction.decode(payload.extension);\n    return extension.results;\n  }\n\n  /**\n   * Utility method to examine a set of proposals to check they contain\n   * the same endorsement result write sets.\n   * This will validate that the endorsing peers all agree on the result\n   * of the chaincode execution.\n   *\n   * @param {ProposalResponse[]} proposalResponses - The proposal responses\n   * from all endorsing peers\n   * @returns {boolean} True when all proposals compare equally, false otherwise.\n   */\n  compareProposalResponseResults() {\n    let proposalResponses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('proposalResponses');\n    const method = `compareProposalResponseResults[${this.chaincodeId}]`;\n    logger.debug('%s - start', method);\n    if (!Array.isArray(proposalResponses)) {\n      throw new Error('proposalResponses must be an array, typeof=' + typeof proposalResponses);\n    }\n    if (proposalResponses.length === 0) {\n      throw new Error('proposalResponses is empty');\n    }\n    if (proposalResponses.some(response => response instanceof Error)) {\n      return false;\n    }\n    const first_one = this._getProposalResponseResults(proposalResponses[0]);\n    for (let i = 1; i < proposalResponses.length; i++) {\n      const next_one = this._getProposalResponseResults(proposalResponses[i]);\n      if (next_one.equals(first_one)) {\n        logger.debug('%s - read/writes result sets match index=%s', method, i);\n      } else {\n        logger.error('%s - read/writes result sets do not match index=%s', method, i);\n        return false;\n      }\n    }\n    return true;\n  }\n  toString() {\n    return `{type:${this.type}, discoveryService:${this.discoveryService.name}}`;\n  }\n}\nmodule.exports = DiscoveryHandler;","map":{"version":3,"names":["TYPE","Long","require","settle","ServiceHandler","fabproto6","randomize","checkParameter","getLogger","getConfigSetting","convertToLong","logger","BLOCK_HEIGHT","RANDOM","DiscoveryHandler","constructor","discoveryService","debug","type","query","signedProposal","arguments","length","undefined","request","method","requestTimeout","mspid","results","timeout","getDiscoveryResults","responses","endorsers","channel","getEndorsers","promises","map","endorser","sendProposal","forEach","result","isFulfilled","value","push","reason","Error","commit","signedEnvelope","committers","getCommitters","_commitSend","error","reconnect","return_error","committer","name","isConnected","checkConnection","sendBroadcast","status","error_message","toString","endorse","peers_by_org","requiredOrgs","endorsement_plan","_buildRequiredOrgPlan","orgs_request","sort","preferredHeightGap","_endorse","working_discovery","JSON","parse","stringify","_buildAllOrgPlan","proposal","endorsements","failed_endorsements","success","required","_create_map","preferred","ignored","required_orgs","preferred_orgs","preferredOrgs","ignored_orgs","ignoredOrgs","preferred_height_gap","fromInt","Number","isInteger","_modify_groups","layouts","_getRandom","matchError","layout_index","layout_results","_endorse_layout","compareProposalResponseResults","concat","layout","endorser_process_index","group_name","group","groups","peers","message","x","endorser_process","_build_endorse_group_member","_execute_endorsements","endorsement","endorser_processes","Promise","all","plan_id","notFound","Object","keys","org","resolve","peer_info","in_use","peer","_getPeer","endpoint","getCharacteristics","ledgerHeight","fromBits","low","high","clean_list","_removePeers","highest","_findHighest","sorted_list","_sortPeerList","split_lists","_splitList","reordered_list","priority","non_priority","array","Map","Array","isArray","item","set","ignored_peers","required_peers","keep_list","found","has","size","fromValue","greaterThan","sorted","a","b","compare","preferred_peers","subtract","randomized_priority","start_list","len","result_list","taken","n","Math","floor","random","address","host_port","split","url","_buildUrl","_getProposalResponseResults","proposaResponse","payload","protos","ProposalResponsePayload","decode","extension","ChaincodeAction","proposalResponses","chaincodeId","some","response","first_one","i","next_one","equals","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/DiscoveryHandler.js"],"sourcesContent":["/*\n Copyright 2019 IBM All Rights Reserved.\n\n SPDX-License-Identifier: Apache-2.0\n\n*/\n\nconst TYPE = 'DiscoveryHandler';\n\nconst Long = require('long');\nconst settle = require('promise-settle');\n\nconst ServiceHandler = require('./ServiceHandler.js');\nconst fabproto6 = require('fabric-protos');\nconst {randomize, checkParameter, getLogger, getConfigSetting, convertToLong} = require('./Utils.js');\n\nconst logger = getLogger(TYPE);\n\nconst BLOCK_HEIGHT = 'ledgerHeight';\nconst RANDOM = 'random';\n\n/**\n * This is an implementation for a handler.\n *\n * @class\n * @extends ServiceHandler\n */\nclass DiscoveryHandler extends ServiceHandler {\n\n\t/**\n\t * constructor\n\t *\n\t * @param {DiscoveryService} discoveryService - The discovery service for this handler.\n\t */\n\tconstructor(discoveryService) {\n\t\tlogger.debug('DiscoveryHandler.constructor - start');\n\t\tsuper();\n\t\tthis.discoveryService = discoveryService;\n\t\tthis.type = TYPE;\n\t}\n\n\t/**\n\t * This will send transactions to all peers found by discovery.\n\t * @param {*} signedProposal\n\t * @param {Object} request - Include a 'mspid' when just peers from\n\t *  an organization are required\n\t */\n\tasync query(signedProposal = checkParameter('signedProposal'), request = {}) {\n\t\tconst method = 'query';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst {requestTimeout, mspid} = request;\n\t\tlet results;\n\n\t\tlet timeout = getConfigSetting('requestTimeout');\n\t\tif (requestTimeout) {\n\t\t\ttimeout = requestTimeout;\n\t\t}\n\n\t\t// forces a refresh if needed\n\t\tawait this.discoveryService.getDiscoveryResults(true);\n\t\tconst responses = [];\n\t\tconst endorsers = this.discoveryService.channel.getEndorsers(mspid);\n\t\tif (endorsers && endorsers.length > 0) {\n\t\t\tlogger.debug('%s - found %s endorsers assigned to channel', method, endorsers.length);\n\t\t\tconst promises = endorsers.map(async (endorser) => {\n\t\t\t\treturn endorser.sendProposal(signedProposal, timeout);\n\t\t\t});\n\t\t\tresults = await settle(promises);\n\t\t\tresults.forEach((result) => {\n\t\t\t\tif (result.isFulfilled()) {\n\t\t\t\t\tlogger.debug(`query - Promise is fulfilled: ${result.value()}`);\n\t\t\t\t\tresponses.push(result.value());\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`query - Promise is rejected: ${result.reason()}`);\n\t\t\t\t\tresponses.push(result.reason());\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error('No endorsers assigned to the channel');\n\t\t}\n\n\t\treturn responses;\n\t}\n\n\t/**\n\t * This will submit transactions to be committed to one committer at a\n\t * time from a list currently assigned to the channel.\n\t * @param {*} signedProposal\n\t * @param {Object} request\n\t */\n\tasync commit(signedEnvelope = checkParameter('signedEnvelope'), request = {}) {\n\t\tconst method = 'commit';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst {requestTimeout, mspid} = request;\n\n\t\tlet timeout = getConfigSetting('requestTimeout');\n\t\tif (requestTimeout) {\n\t\t\ttimeout = requestTimeout;\n\t\t}\n\n\t\t// force a refresh if needed\n\t\tawait this.discoveryService.getDiscoveryResults(true);\n\n\t\tconst committers = this.discoveryService.channel.getCommitters(mspid);\n\t\tif (committers && committers.length > 0) {\n\t\t\tlogger.debug('%s - found %s committers assigned to channel', method, committers.length);\n\t\t\trandomize(committers);\n\n\t\t\tlet results;\n\t\t\t// first pass only try a committer that is in good standing\n\t\t\tresults = await this._commitSend(committers, signedEnvelope, timeout, false);\n\t\t\tif (results.error) {\n\t\t\t\t// since we did not get a good result, try another pass, this time try to\n\t\t\t\t// have the orderers reconnect\n\t\t\t\tresults = await this._commitSend(committers, signedEnvelope, timeout, true);\n\t\t\t}\n\n\t\t\tif (results.commit) {\n\t\t\t\tlogger.debug('%s - return commit status %s ', method, results.commit);\n\t\t\t\treturn results.commit;\n\t\t\t}\n\n\t\t\tlogger.debug('%s - return error %s ', method, results.error);\n\t\t\tthrow results.error;\n\t\t} else {\n\t\t\tthrow new Error('No committers assigned to the channel');\n\t\t}\n\t}\n\n\tasync _commitSend(committers, signedEnvelope, timeout, reconnect) {\n\t\tconst method = 'commit';\n\t\tlogger.debug('%s - start', method);\n\n\t\tlet return_error;\n\t\t// loop through the committers trying to complete one successfully\n\t\tfor (const committer of committers) {\n\t\t\tlogger.debug('%s - sending to committer %s', method, committer.name);\n\t\t\ttry {\n\t\t\t\tconst isConnected = await committer.checkConnection(reconnect);\n\t\t\t\tif (isConnected) {\n\t\t\t\t\tconst commit = await committer.sendBroadcast(signedEnvelope, timeout);\n\t\t\t\t\tif (commit) {\n\t\t\t\t\t\tif (commit.status === 'SUCCESS') {\n\t\t\t\t\t\t\tlogger.debug('%s - Successfully sent transaction to the committer %s', method, committer.name);\n\t\t\t\t\t\t\treturn {error: undefined,  commit};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug('%s - Failed, status was not \"success\" from the send transaction to the committer. status:%s', method, commit.status);\n\t\t\t\t\t\t\treturn_error = new Error('Failed to send transaction successfully to the committer. status:' + commit.status);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn_error = new Error('Failed to receive committer status');\n\t\t\t\t\t\tlogger.debug('%s - Failed, no status received on the send transaction to the committer %s', method, committer.name);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet error_message = `Failed, committer ${committer.name} is not connected`;\n\t\t\t\t\tif (reconnect) {\n\t\t\t\t\t\terror_message = `Failed, not able to reconnect to committer ${committer.name}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn_error = new Error(error_message);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.debug('%s - Caught: %s', method, error.toString());\n\t\t\t\treturn_error = error;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - return error %s ', method, return_error.toString());\n\t\treturn {error: return_error};\n\t}\n\n\t/**\n\t * This method will submit transactions to be endorsed to endorsers as\n\t * determined by the endorser's discovery service\n\t * @param {*} signedProposal\n\t * @param {*} request\n\t */\n\tasync endorse(signedProposal = checkParameter('signedProposal'), request = {}) {\n\t\tconst method = 'endorse';\n\t\tlogger.debug('%s - start', method);\n\n\t\tlet timeout = getConfigSetting('requestTimeout');\n\t\tif (request.requestTimeout) {\n\t\t\ttimeout = request.requestTimeout;\n\t\t}\n\n\t\tconst results = await this.discoveryService.getDiscoveryResults(true);\n\n\t\tif (results && results.peers_by_org && request.requiredOrgs) {\n\t\t\t// special case when user knows which organizations to send the endorsement\n\t\t\t// let's build our own endorsement plan so that we can use the sorting and sending code\n\t\t\tconst endorsement_plan = this._buildRequiredOrgPlan(results.peers_by_org, request.requiredOrgs);\n\n\t\t\t// remove conflicting settings\n\t\t\tconst orgs_request = {\n\t\t\t\tsort: request.sort,\n\t\t\t\tpreferredHeightGap: request.preferredHeightGap\n\t\t\t};\n\n\t\t\treturn this._endorse(endorsement_plan, orgs_request, signedProposal, timeout);\n\t\t} else if (results && results.endorsement_plan) {\n\t\t\t// normal processing of the discovery results\n\t\t\tconst working_discovery = JSON.parse(JSON.stringify(results.endorsement_plan));\n\n\t\t\treturn this._endorse(working_discovery, request, signedProposal, timeout);\n\t\t} else if (results && results.peers_by_org) {\n\t\t\t// special case when the chaincode is system chaincode without an endorsement policy\n\t\t\tconst endorsement_plan = this._buildAllOrgPlan(results.peers_by_org);\n\n\t\t\treturn this._endorse(endorsement_plan, request, signedProposal, timeout);\n\t\t} else {\n\t\t\tthrow Error('No endorsement plan available');\n\t\t}\n\t}\n\n\tasync _endorse(endorsement_plan = checkParameter('endorsement_plan'), request = {}, proposal = checkParameter('proposal'), timeout) {\n\t\tconst method = '_endorse';\n\t\tlogger.debug('%s - starting', method);\n\n\t\tendorsement_plan.endorsements = {};\n\t\tconst results = {};\n\t\tresults.endorsements = null; // will be from just one layout\n\t\tresults.failed_endorsements = []; // from all failed layouts\n\t\tresults.success = false;\n\n\t\tconst required = this._create_map(request.required, 'endpoint');\n\t\tconst preferred = this._create_map(request.preferred, 'endpoint');\n\t\tconst ignored = this._create_map(request.ignored, 'endpoint');\n\t\tconst required_orgs = this._create_map(request.requiredOrgs, 'mspid');\n\t\tconst preferred_orgs = this._create_map(request.preferredOrgs, 'mspid');\n\t\tconst ignored_orgs = this._create_map(request.ignoredOrgs, 'mspid');\n\n\t\tlet preferred_height_gap = Long.fromInt(1); // default of one block\n\t\ttry {\n\t\t\tif (Number.isInteger(request.preferredHeightGap) || request.preferredHeightGap) {\n\t\t\t\tpreferred_height_gap = convertToLong(request.preferredHeightGap, true);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow Error('preferred_height_gap setting is not a number');\n\t\t}\n\n\t\tlet sort = BLOCK_HEIGHT;\n\t\tif (request.sort) {\n\t\t\tif (request.sort === BLOCK_HEIGHT) {\n\t\t\t\tsort = BLOCK_HEIGHT;\n\t\t\t} else if (request.sort === RANDOM) {\n\t\t\t\tsort = RANDOM;\n\t\t\t} else {\n\t\t\t\tthrow Error('sort parameter is not valid');\n\t\t\t}\n\t\t}\n\n\t\t// fix the peer group lists to reflect the options the user has provided\n\t\tthis._modify_groups(\n\t\t\trequired,\n\t\t\tpreferred,\n\t\t\tignored,\n\t\t\trequired_orgs,\n\t\t\tpreferred_orgs,\n\t\t\tignored_orgs,\n\t\t\tpreferred_height_gap,\n\t\t\tsort,\n\t\t\tendorsement_plan\n\t\t);\n\n\t\t// always randomize the layouts\n\t\tendorsement_plan.layouts = this._getRandom(endorsement_plan.layouts);\n\n\t\tlet matchError = false;\n\n\t\t// loop through the layouts trying to complete one successfully\n\t\tfor (const layout_index in endorsement_plan.layouts) {\n\t\t\tlogger.debug('%s - starting layout plan %s', method, layout_index);\n\t\t\tconst layout_results = await this._endorse_layout(layout_index, endorsement_plan, proposal, timeout);\n\t\t\t// if this layout is successful then we are done\n\t\t\tif (layout_results.success) {\n\t\t\t\t// make sure all responses have the same endorsement read/write set\n\t\t\t\tif (this.compareProposalResponseResults(layout_results.endorsements)) {\n\t\t\t\t\tlogger.debug('%s - layout plan %s completed successfully', method, layout_index);\n\t\t\t\t\tresults.endorsements = layout_results.endorsements;\n\t\t\t\t\tresults.success = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmatchError = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.debug('%s - layout plan %s did not complete successfully', method, layout_index);\n\t\t\tresults.failed_endorsements = results.failed_endorsements.concat(layout_results.endorsements);\n\t\t}\n\n\t\tif (!results.success) {\n\t\t\tlet error;\n\t\t\tif (matchError) {\n\t\t\t\terror =  new Error('Peer endorsements do not match');\n\t\t\t} else {\n\t\t\t\terror = new Error('Endorsement has failed');\n\t\t\t}\n\t\t\terror.endorsements = results.failed_endorsements;\n\t\t\treturn [error];\n\t\t}\n\n\t\treturn results.endorsements;\n\t}\n\n\tasync _endorse_layout(layout_index, endorsement_plan, proposal, timeout) {\n\t\tconst method = '_endorse_layout';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst results = {};\n\t\tresults.endorsements = [];\n\t\tresults.success = true;\n\t\tconst layout = endorsement_plan.layouts[layout_index];\n\t\tlet endorser_process_index = 0;\n\t\tconst endorsers = [];\n\t\tfor (const group_name in layout) {\n\t\t\tconst required = layout[group_name];\n\t\t\tconst group = endorsement_plan.groups[group_name];\n\t\t\t// make sure there are enough peers in the group to satisfy required\n\t\t\tif (required > group.peers.length) {\n\t\t\t\tresults.success = false;\n\t\t\t\tconst error = new Error(`Endorsement plan group does not contain enough peers (${group.peers.length}) to satisfy policy (required:${required})`);\n\t\t\t\tlogger.debug(error.message);\n\t\t\t\tresults.endorsements.push(error);\n\t\t\t\tbreak; // no need to look at other groups, this layout failed\n\t\t\t}\n\t\t\tfor (let x = 0; x < required; x++) {\n\t\t\t\tconst endorser_process =\n\t\t\t\t\tthis._build_endorse_group_member(endorsement_plan, group, proposal, timeout, endorser_process_index++, group_name);\n\t\t\t\tendorsers.push(endorser_process);\n\t\t\t}\n\t\t}\n\n\t\tif (results.success) {\n\t\t\tresults.endorsements = await this._execute_endorsements(endorsers);\n\t\t\tfor (const endorsement of results.endorsements) {\n\t\t\t\tif (endorsement instanceof Error) {\n\t\t\t\t\tresults.success = false;\n\t\t\t\t} else if (typeof endorsement.success === 'boolean' && endorsement.success === false) {\n\t\t\t\t\tresults.success = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync _execute_endorsements(endorser_processes) {\n\t\tconst method = '_execute_endorsements';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst results = await Promise.all(endorser_processes);\n\t\tconst responses = [];\n\t\tfor (const result of results) {\n\t\t\tif (result instanceof Error) {\n\t\t\t\tlogger.debug('%s - endorsement failed: %s', method, result);\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - endorsement is complete', method);\n\t\t\t}\n\t\t\tresponses.push(result);\n\t\t}\n\n\t\treturn responses;\n\t}\n\n\t_buildRequiredOrgPlan(peers_by_org, required_orgs) {\n\t\tconst method = '_buildRequiredOrgPlan';\n\t\tlogger.debug('%s - starting', method);\n\t\tconst endorsement_plan = {plan_id: 'required organizations'};\n\t\tendorsement_plan.groups = {};\n\t\tendorsement_plan.layouts = [{}]; // only one layout which will have all organizations\n\n\t\tconst notFound = [];\n\n\t\tfor (const mspid of required_orgs) {\n\t\t\tlogger.debug(`${method} - found org:${mspid}`);\n\t\t\tendorsement_plan.groups[mspid] = {}; // make a group for each\n\t\t\tif (peers_by_org[mspid] && peers_by_org[mspid].peers && peers_by_org[mspid].peers.length > 0) {\n\t\t\t\tendorsement_plan.groups[mspid].peers = JSON.parse(JSON.stringify(peers_by_org[mspid].peers)); // now put in all peers from that organization\n\t\t\t\tendorsement_plan.layouts[0][mspid] = 1; // add this org to the one layout and require one peer to endorse\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - discovery plan does not have peers for %', method, mspid);\n\t\t\t\tnotFound.push(mspid);\n\t\t\t}\n\t\t}\n\n\t\tif (notFound.length > 0) {\n\t\t\tthrow Error(`The discovery service did not find any peers active for ${notFound} organizations`);\n\t\t}\n\n\t\treturn endorsement_plan;\n\t}\n\n\t_buildAllOrgPlan(peers_by_org) {\n\t\tconst method = '_buildAllOrgPlan';\n\t\tlogger.debug('%s - starting', method);\n\t\tconst endorsement_plan = {plan_id: 'all organizations'};\n\t\tendorsement_plan.groups = {};\n\t\tendorsement_plan.layouts = [{}]; // only one layout which will have all organizations\n\t\tlet notFound = true;\n\n\t\tObject.keys(peers_by_org).forEach((mspid) => {\n\t\t\tconst org = peers_by_org[mspid];\n\t\t\tif (org.peers && org.peers.length > 0) {\n\t\t\t\tendorsement_plan.groups[mspid] = {}; // make a group for each\n\t\t\t\tendorsement_plan.groups[mspid].peers = JSON.parse(JSON.stringify(org.peers)); // now put in all peers from that organization\n\t\t\t\tendorsement_plan.layouts[0][mspid] = 1; // add this org to the one layout and require one peer to endorse\n\t\t\t\tnotFound = false;\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - discovery plan does not have peers for %', method, mspid);\n\t\t\t}\n\t\t});\n\n\t\tif (notFound) {\n\t\t\tthrow Error('The discovery service did not find any peers active');\n\t\t}\n\n\t\treturn endorsement_plan;\n\t}\n\n\t/*\n\t * utility method to build a promise that will return one of the required\n\t * endorsements or an error object\n\t */\n\t_build_endorse_group_member(endorsement_plan, group, proposal, timeout, endorser_process_index, group_name) {\n\t\tconst method = '_build_endorse_group_member >> ' + group_name + ':' + endorser_process_index;\n\t\tlogger.debug('%s - start', method);\n\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise(async (resolve) => {\n\t\t\tlet endorsement = null;\n\t\t\tfor (const peer_info of group.peers) {\n\t\t\t\tendorsement = endorsement_plan.endorsements[peer_info.name];\n\t\t\t\tif (endorsement) {\n\t\t\t\t\tlogger.debug('%s - existing peer %s endorsement will be used', method, peer_info.name);\n\t\t\t\t} else {\n\t\t\t\t\tif (peer_info.in_use) {\n\t\t\t\t\t\tlogger.debug('%s - peer in use %s, skipping', method, peer_info.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst peer = this._getPeer(peer_info.endpoint);\n\t\t\t\t\t\tif (peer) {\n\t\t\t\t\t\t\tlogger.debug('%s - send endorsement to %s', method, peer_info.name);\n\t\t\t\t\t\t\tpeer_info.in_use = true;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst isConnected = await peer.checkConnection();\n\t\t\t\t\t\t\t\tif (isConnected) {\n\t\t\t\t\t\t\t\t\tendorsement = await peer.sendProposal(proposal, timeout);\n\t\t\t\t\t\t\t\t\t// save this endorsement results in case we try this peer again\n\t\t\t\t\t\t\t\t\tlogger.debug('%s - endorsement completed to %s', method, peer_info.name);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tendorsement = peer.getCharacteristics(new Error(`Peer ${peer.name} is not connected`));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tendorsement = peer.getCharacteristics(error);\n\t\t\t\t\t\t\t\tlogger.error('%s - error on endorsement to %s error %s', method, peer_info.name, error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// save this endorsement results in case we try this peer again\n\t\t\t\t\t\t\t// eslint-disable-next-line require-atomic-updates\n\t\t\t\t\t\t\tendorsement_plan.endorsements[peer_info.name] = endorsement;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug('%s - peer %s not assigned to this channel', method, peer_info.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (endorsement && !(endorsement instanceof Error)) {\n\t\t\t\t\tlogger.debug('%s - peer %s endorsement will be used', method, peer_info.name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endorsement) {\n\t\t\t\tlogger.debug('%s - returning endorsement', method);\n\t\t\t\tresolve(endorsement);\n\t\t\t} else {\n\t\t\t\tlogger.error('%s - returning an error endorsement, no endorsement made', method);\n\t\t\t\tresolve(new Error('No endorsement available'));\n\t\t\t}\n\t\t});\n\t}\n\n\t/*\n\t * utility method that will take a group of peers and modify the order\n\t * of the peers within the group based on the user's requirements\n\t *\n\t * for each group\n\t *  - remove the ignored and all non required\n\t *  - sort group list by ledger height (larger on top) or randomly\n\t *  - walk sorted list\n\t *      -- put the preferred peers & organizations in the priority bucket if ledger height acceptable\n\t *      -- put others in non priority bucket\n\t *  - build final modified group (this will maintain how they were sorted)\n\t *      -- pull peers from priority bucket\n\t *      -- pull peers from non priority bucket\n\t *  - return modified group\n\t */\n\t_modify_groups(required, preferred, ignored, required_orgs, preferred_orgs, ignored_orgs, preferred_height_gap, sort, endorsement_plan) {\n\t\tconst method = '_modify_groups';\n\t\tlogger.debug('%s - start', method);\n\t\tlogger.debug('%s - required:%j', method, required);\n\t\tlogger.debug('%s - preferred:%j', method, preferred);\n\t\tlogger.debug('%s - ignored:%j', method, ignored);\n\t\tlogger.debug('%s - required_orgs:%j', method, required_orgs);\n\t\tlogger.debug('%s - preferred_orgs:%j', method, preferred_orgs);\n\t\tlogger.debug('%s - ignored_orgs:%j', method, ignored_orgs);\n\t\tlogger.debug('%s - preferred_height_gap:%s', method, preferred_height_gap);\n\t\tlogger.debug('%s - sort: %s', method, sort);\n\t\tlogger.debug('%s - endorsement_plan:%j', method, endorsement_plan);\n\n\t\tfor (const group_name in endorsement_plan.groups) {\n\t\t\tconst group = endorsement_plan.groups[group_name];\n\t\t\tfor (const peer of group.peers) {\n\t\t\t\tpeer.ledgerHeight = Long.fromBits(peer.ledgerHeight.low, peer.ledgerHeight.high, true);\n\t\t\t}\n\n\t\t\t// remove ignored and non-required\n\t\t\tconst clean_list = this._removePeers(ignored, ignored_orgs, required, required_orgs, group.peers);\n\n\t\t\t// get the highest ledger height if needed\n\t\t\tlet highest = null;\n\t\t\tif (sort === BLOCK_HEIGHT) {\n\t\t\t\thighest = this._findHighest(clean_list);\n\t\t\t}\n\n\t\t\t// sort based on ledger height or randomly\n\t\t\tconst sorted_list = this._sortPeerList(sort, clean_list);\n\t\t\t// pop the priority peers off the sorted list\n\t\t\tconst split_lists = this._splitList(preferred, preferred_orgs, preferred_height_gap, highest, sorted_list);\n\t\t\t// put the priorities on top\n\t\t\tconst reordered_list = split_lists.priority.concat(split_lists.non_priority);\n\t\t\t// set the rebuilt peer list into the group\n\t\t\tgroup.peers = reordered_list;\n\t\t}\n\n\t\tlogger.debug('%s - updated endorsement_plan:%j', method, endorsement_plan);\n\t}\n\n\t_create_map(array) {\n\t\tconst map = new Map();\n\t\tif (array && Array.isArray(array)) {\n\t\t\tarray.forEach((item) => {\n\t\t\t\tmap.set(item, item);\n\t\t\t});\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/*\n\t * utility method to remove peers that are ignored or not on the required list\n\t */\n\t_removePeers(ignored_peers, ignored_orgs, required_peers, required_orgs, peers) {\n\t\tconst method = '_removePeers';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst keep_list = [];\n\t\tfor (const peer of peers) {\n\t\t\tlet found = ignored_peers.has(peer.name);\n\t\t\tif (!found) {\n\t\t\t\tfound = ignored_orgs.has(peer.mspid);\n\t\t\t\tif (!found) {\n\t\t\t\t\t// if the user has requested required peers/orgs\n\t\t\t\t\t// then all peers that stay on the list must be\n\t\t\t\t\t// one of those peers or in one of those orgs\n\t\t\t\t\tif (required_peers.size || required_orgs.size) {\n\t\t\t\t\t\tfound = required_peers.has(peer.name);\n\t\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t\tfound = required_orgs.has(peer.mspid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if we did not find it on a either list then\n\t\t\t\t\t\t// this peer will not be added to the keep list\n\t\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t\tcontinue; // do not add this peer to the keep list\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// looks like this peer is not on the ignored list and\n\t\t\t\t\t// is on the required list (if being used);\n\t\t\t\t\tkeep_list.push(peer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn keep_list;\n\t}\n\n\t_findHighest(peers) {\n\t\tlet highest = Long.fromValue(0);\n\t\tfor (const peer of peers) {\n\t\t\ttry {\n\t\t\t\tif (peer.ledgerHeight.greaterThan(highest)) {\n\t\t\t\t\thighest = peer.ledgerHeight;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('problem finding highest block with %s', error);\n\t\t\t\tthrow Error(`Unable to find highest block value :: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\treturn highest;\n\t}\n\n\t_sortPeerList(sort, peers) {\n\t\tconst method = '_sortList';\n\t\tlogger.debug('%s - start - %s', method, sort);\n\n\t\tlet sorted = null;\n\n\t\tif (sort === BLOCK_HEIGHT) {\n\t\t\tsorted = peers.sort((a, b) => {\n\t\t\t\tlogger.debug('%s - sorting descending', method);\n\t\t\t\tif (a.ledgerHeight && !b.ledgerHeight) {\n\t\t\t\t\tlogger.debug('%s - a exist (%s) - b does not exist', method, a.ledgerHeight);\n\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (!a.ledgerHeight && b.ledgerHeight) {\n\t\t\t\t\tlogger.debug('%s - a does not exist - b exist (%s)', method, b.ledgerHeight);\n\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst result = -1 * a.ledgerHeight.compare(b.ledgerHeight);\n\t\t\t\t\tlogger.debug('%s - compare result: %s for a:(%s) b:(%s) ', method, result, a.ledgerHeight.toString(), b.ledgerHeight.toString());\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t});\n\t\t} else { // must be random\n\t\t\tsorted = this._getRandom(peers);\n\t\t}\n\n\t\treturn sorted;\n\t}\n\n\n\t_splitList(preferred_peers, preferred_orgs, preferred_height_gap, highest, sorted_list) {\n\t\tconst method = '_splitList';\n\t\tlogger.debug('%s - start', method);\n\n\t\tconst priority = [];\n\t\tconst non_priority = [];\n\n\t\tfor (const peer of sorted_list) {\n\t\t\t// first see if on the preferred lists\n\t\t\tlet found = preferred_peers.has(peer.name);\n\t\t\tif (!found) {\n\t\t\t\tlogger.debug('%s - peer %s not found on the preferred peer list', method, peer.name);\n\t\t\t\tfound = preferred_orgs.has(peer.mspid);\n\t\t\t\tif (found) {\n\t\t\t\t\tlogger.debug('%s - peer %s found on preferred org list', method, peer.name);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('%s - peer %s not found on preferred org list', method, peer.name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - peer %s found on the preferred peer list', method, peer.name);\n\t\t\t}\n\n\t\t\t// if not on the preferred lists and we are sorting by block hieght\n\t\t\t// check the gap that indicates that it will be up to date shortly and it should be used\n\t\t\tif (!found && highest) {\n\t\t\t\tif (peer.ledgerHeight) {\n\t\t\t\t\tlogger.debug('%s - checking preferred gap of %s', method, preferred_height_gap);\n\t\t\t\t\tlogger.debug('%s - peer.ledgerHeight %s', method, peer.ledgerHeight);\n\t\t\t\t\tif (highest.subtract(peer.ledgerHeight).greaterThan(preferred_height_gap)) {\n\t\t\t\t\t\tfound = false; // this peer should not be on the priority list\n\t\t\t\t\t\tlogger.debug('%s -gap too big, peer should not be on priority list', method, peer.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true; // this peer should not be on the priority list\n\t\t\t\t\t\tlogger.debug('%s - gap is OK, peer should be on priority list', method, peer.name);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('%s - peer has no ledgerHeight, not a priority peer');\n\t\t\t\t\tfound = false;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - not checking the preferred height gap', method);\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tpriority.push(peer);\n\t\t\t} else {\n\t\t\t\tnon_priority.push(peer);\n\t\t\t}\n\t\t}\n\n\t\t// priority peers are all the same, try not to use the same\n\t\t// one everytime\n\t\tconst randomized_priority  = this._getRandom(priority);\n\n\t\treturn {priority: randomized_priority, non_priority};\n\t}\n\n\t/*\n\t * utility function to return a random list\n\t */\n\t_getRandom(start_list) {\n\t\tlet len = start_list.length;\n\t\tconst result_list = new Array(len);\n\t\tconst taken = new Array(len);\n\t\tlet n = len;\n\t\twhile (n--) {\n\t\t\tconst x = Math.floor(Math.random() * len);\n\t\t\tresult_list[n] = start_list[x in taken ? taken[x] : x];\n\t\t\ttaken[x] = --len in taken ? taken[len] : len;\n\t\t}\n\n\t\treturn result_list;\n\t}\n\n\t/*\n\t * utility function to return a peer with the requested url\n\t */\n\t_getPeer(address) {\n\t\tlet result = null;\n\t\tif (address) {\n\t\t\tconst host_port = address.split(':');\n\t\t\tconst url = this.discoveryService._buildUrl(host_port[0], host_port[1]);\n\t\t\tconst peers = \tthis.discoveryService.channel.getEndorsers();\n\t\t\tfor (const peer of peers) {\n\t\t\t\tif (peer.endpoint && peer.endpoint.url === url) {\n\t\t\t\t\tresult = peer;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// internal utility method to decode and get the write set from an endorsement\n\t_getProposalResponseResults(proposaResponse = checkParameter('proposalResponse')) {\n\t\tif (!proposaResponse.payload) {\n\t\t\tthrow new Error('Parameter must be a ProposalResponse Object');\n\t\t}\n\t\tconst payload = fabproto6.protos.ProposalResponsePayload.decode(proposaResponse.payload);\n\t\tconst extension = fabproto6.protos.ChaincodeAction.decode(payload.extension);\n\n\t\treturn extension.results;\n\t}\n\n\t/**\n\t * Utility method to examine a set of proposals to check they contain\n\t * the same endorsement result write sets.\n\t * This will validate that the endorsing peers all agree on the result\n\t * of the chaincode execution.\n\t *\n\t * @param {ProposalResponse[]} proposalResponses - The proposal responses\n\t * from all endorsing peers\n\t * @returns {boolean} True when all proposals compare equally, false otherwise.\n\t */\n\tcompareProposalResponseResults(proposalResponses = checkParameter('proposalResponses')) {\n\t\tconst method = `compareProposalResponseResults[${this.chaincodeId}]`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (!Array.isArray(proposalResponses)) {\n\t\t\tthrow new Error('proposalResponses must be an array, typeof=' + typeof proposalResponses);\n\t\t}\n\t\tif (proposalResponses.length === 0) {\n\t\t\tthrow new Error('proposalResponses is empty');\n\t\t}\n\n\t\tif (proposalResponses.some((response) => response instanceof Error)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst first_one = this._getProposalResponseResults(proposalResponses[0]);\n\t\tfor (let i = 1; i < proposalResponses.length; i++) {\n\t\t\tconst next_one = this._getProposalResponseResults(proposalResponses[i]);\n\t\t\tif (next_one.equals(first_one)) {\n\t\t\t\tlogger.debug('%s - read/writes result sets match index=%s', method, i);\n\t\t\t} else {\n\t\t\t\tlogger.error('%s - read/writes result sets do not match index=%s', method, i);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `{type:${this.type}, discoveryService:${this.discoveryService.name}}`;\n\t}\n}\n\nmodule.exports = DiscoveryHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}