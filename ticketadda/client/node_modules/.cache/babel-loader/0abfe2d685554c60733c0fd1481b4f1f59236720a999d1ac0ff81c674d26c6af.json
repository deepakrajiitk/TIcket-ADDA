{"ast":null,"code":"/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n'use strict';\n\nconst fabproto6 = require('fabric-protos');\nconst utils = require('./Utils');\nconst logger = utils.getLogger('BlockDecoder.js');\n\n/**\n * Utility class to convert a protobuf encoded byte array of a Hyperledger Fabric block\n * message into a pure Javascript object with the key names as they appear in the protobuf\n * defintions (typically snake case)\n *\n * @class\n */\nclass BlockDecoder {\n  /**\n   * An object of a fully decoded protobuf message \"Block\".\n   * <br><br>\n   * A Block may contain the configuration of the channel or transactions on the channel.\n   * <br><br>\n   * A Block object will have the following object structure.\n  <br><pre>\n  header\n  number -- {int}\n  previous_hash -- {byte[]}\n  data_hash -- {byte[]}\n  data\n  data -- {array}\n  \tsignature -- {byte[]}\n  \tpayload\n  \t\theader -- {{@link Header}}\n  \t\tdata -- {{@link ConfigEnvelope} | {@link Transaction}}\n  metadata\n  metadata -- {array} #each array item has it's own layout\n  \t[0] #SIGNATURES\n  \t\tsignatures -- {{@link MetadataSignature[]}}\n  \t[1] #LAST_CONFIG\n  \t\tvalue\n  \t\t\tindex -- {number}\n  \t\t\tsignatures -- {{@link MetadataSignature[]}}\n  \t[2] #TRANSACTIONS_FILTER\n  \t\t\t{int[]} #see TxValidationCode in proto/peer/transaction.proto\n  </pre>\n   *\n   * @typedef {Object} Block\n   *\n   * @example\n   * <caption>Get the block number:</caption>\n   * var block_num = block.header.number;\n   *\n   * @example\n   * <caption>Get the number of transactions, including the invalid transactions:</caption>\n   * var block_num = block.data.data.length;\n   *\n   * @example\n   * <caption>Get the Id of the first transaction in the block:</caption>\n   * var tx_id = block.data.data[0].payload.header.channel_header.tx_id;\n   */\n\n  /**\n   * Headers describe basic information about a transaction record, such\n   * as its type (configuration update, or endorser transaction, etc.),\n   * the id of the channel it belongs to, the transaction id and so on.\n   * The header message also contains a common field {@link SignatureHeader}\n   * that describes critical information about how to verify signatures.\n   * <br><br>\n   * A \"Header\" will have the following object structure.\n  <br><pre>\n  channel_header\n  type -- {string}\n  version -- {int}\n  timestamp -- {time}\n  channel_id -- {string}\n  tx_id -- {string}\n  epoch -- {int}\n  signature_header -- {{@link SignatureHeader}}\n  </pre>\n   * @typedef {Object} Header\n   */\n\n  /**\n   * A signature over the metadata of a block, to ensure the authenticity of\n   * the metadata that describes a Block.\n  <br><pre>\n  signature_header {{@link SignatureHeader}}\n  signature -- {byte[]}\n  </pre>\n   *\n   * @typedef {Object} MetadataSignature\n   */\n\n  /**\n   * An object that is part of all signatures in Hyperledger Fabric. The \"creator\"\n   * field has two important pieces of information about the identity of the signer,\n   * the organization (Mspid) that the signer belongs to, and the certificate (IdBytes).\n   * The \"nonce\" field is a unique value to guard against replay attacks.\n   *\n  <br><pre>\n  creator\n  Mspid -- {string}\n  IdBytes -- {byte[]}\n  nonce -- {byte[]}\n  </pre>\n   * @typedef {Object} SignatureHeader\n   */\n\n  /**\n   * A ConfigEnvelope contains the channel configurations data and is the\n   * main content of a configuration block. Another type of blocks are those\n   * that contain endorser transactions, where the main content is an array\n   * of {@link Transaction}.\n   * <br><br>\n   * A \"ConfigEnvelope\" will have the following object structure.\n  <br><pre>\n  config\n  sequence -- {int}\n  channel_group -- {{@link ConfigGroup}}\n  type -- {int}\n  last_update\n  signature -- {byte[]}\n  payload\n  \theader -- {{@link Header}}\n  \tdata -- {{@link ConfigUpdateEnvelope}}\n  </pre>\n   * @typedef {Object} ConfigEnvelope\n   */\n\n  /**\n   * A Transaction, or \"Endorser Transaction\", is the result of invoking chaincodes\n   * to collect endorsements, getting globally ordered in the context of a channel,\n   * and getting validated by the committer peer as part of a block before finally\n   * being formally \"committed\" to the ledger inside a Block. Each transaction contains\n   * an array of \"actions\" representing different steps for executing a transaction,\n   * and those steps will be processed atomically, meaning if any one step failed\n   * then the whole transaction will be marked as rejected.\n   * <br><br>\n   * Each entry of the \"actions\" array contains a chaincode proposal and corresponding proposal\n   * responses that encapsulate the endorsing peer's decisions on whether the proposal\n   * is considered valid. Note that even if a transaction proposal(s) is considered\n   * valid by the endorsing peers, it may still be rejected by the committers during\n   * transaction validation. Whether a transaction as a whole is valid or not, is not\n   * reflected in the transaction record itself, but rather recorded in a separate\n   * field in the Block's metadata.\n   * <br><br>\n   * A \"Transaction\" will have the following object structure.\n  <br><pre>\n  actions {array}\n  header -- {{@link SignatureHeader}}\n  payload\n  \tchaincode_proposal_payload\n  \t\tinput -- {{@link ChaincodeInvocationSpec}} for a endorser transaction\n  \taction\n  \t\tproposal_response_payload\n  \t\t\tproposal_hash -- {byte[]}\n  \t\t\textension\n  \t\t\t\tresults\n  \t\t\t\t\tdata_model -- {int}\n  \t\t\t\t\tns_rwset -- {array}\n  \t\t\t\t\t\tnamespace -- {string}\n  \t\t\t\t\t\trwset\n  \t\t\t\t\t\t\treads -- {array}\n  \t\t\t\t\t\t\t\tkey -- {string}\n  \t\t\t\t\t\t\t\tversion\n  \t\t\t\t\t\t\t\t\tblock_num -- {number}\n  \t\t\t\t\t\t\t\t\ttx_num -- {number}\n  \t\t\t\t\t\t\trange_queries_info -- {array}\n  \t\t\t\t\t\t\twrites -- {array}\n  \t\t\t\t\t\t\t\tkey -- {string}\n  \t\t\t\t\t\t\t\tis_delete -- {boolean}\n  \t\t\t\t\t\t\t\tvalue -- {string}\n  \t\t\t\t\t\t\tmetadata_writes -- {array}\n  \t\t\t\t\t\t\t\tkey -- {string}\n  \t\t\t\t\t\t\t\tentries -- {array}\n  \t\t\t\t\t\t\t\t\tname -- {string}\n  \t\t\t\t\t\t\t\t\tvalue -- {byte[]}\n  \t\t\t\t\tcollection_hashed_rwset -- {array}\n  \t\t\t\t\t\tcollection_name -- {string}\n  \t\t\t\t\t\thashed_rwset\n  \t\t\t\t\t\t\thashed_reads -- {array}\n  \t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n  \t\t\t\t\t\t\t\tversion\n  \t\t\t\t\t\t\t\t\tblock_num -- {number}\n  \t\t\t\t\t\t\t\t\ttx_num -- {number}\n  \t\t\t\t\t\t\thashed_writes -- {array}\n  \t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n  \t\t\t\t\t\t\t\tis_delete -- {boolean}\n  \t\t\t\t\t\t\t\tvalue_hash -- {byte[]}\n  \t\t\t\t\t\t\tmetadata_writes -- {array}\n  \t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n  \t\t\t\t\t\t\t\tentries -- {array}\n  \t\t\t\t\t\t\t\t\tname -- {string}\n  \t\t\t\t\t\t\t\t\tvalue -- {byte[]}\n  \t\t\t\t\t\tpvt_rwset_hash -- {byte[]}\n  \t\t\t\tevents\n  \t\t\t\t\tchaincode_id --  {string}\n  \t\t\t\t\ttx_id -- {string}\n  \t\t\t\t\tevent_name -- {string}\n  \t\t\t\t\tpayload -- {byte[]}\n  \t\t\t\tresponse\n  \t\t\t\t\tstatus -- {int}\n  \t\t\t\t\tmessage -- {string}\n  \t\t\t\t\tpayload -- {byte[]}\n  \t\tendorsements -- {{@link Endorsement}[]}\n  </pre>\n   * @typedef {Object} Transaction\n   */\n\n  /**\n   * An endorsement proposal, which includes the name of the chaincode\n   * to be invoked and the arguments to be passed to the chaincode.\n   * <br><br>\n   * A \"ChaincodeInvocationSpec\" has the following object structure.\n  <br><pre>\n  chaincode_spec\n  type -- {int}\n  chaincode_id\n  \tpath -- {string}\n  \tname -- {string}\n  \tversion -- {string}\n  input\n  \targs -- {byte[][]}\n  \tdecorations -- {map of string to byte[]}\n  timeout -- {int}\n  </pre>\n   *\n   * @typedef {Object} ChaincodeInvocationSpec\n   */\n\n  /**\n   * An object of a protobuf message \"ConfigUpdateEnvelope\".\n   * <br><br>\n   * A \"ConfigUpdateEnvelope\" will have the following object structure.\n  <br><pre>\n  config_update\n  channel_id -- {string}\n  read_set -- {{@link ChannelConfigGroup}}\n  write_set -- {{@link ChannelConfigGroup}}\n  type -- {int}\n  signatures -- {array}\n  signature_header -- {{@link SignatureHeader}}\n  signature -- {byte[]}\n  </pre>\n   * @typedef {Object} ConfigUpdateEnvelope\n   * @property {ChannelConfigGroup} config_update.read_set A set of the current version numbers of all\n   *           configuration items being updated\n   * @property {ChannelConfigGroup} config_update.write_set A set of all configuration items being updated. Must have a\n   *           version number one greater than the version number of the same item\n   *           in the read_set along with the new value.\n   */\n\n  /**\n   * The configuration settings that govern how the fabric should maintain\n   * a channel are included in the blocks of the channel itself. When a block contains\n   * the channel configuration, the channel configuration record is the only item in\n   * the block's data array. Every block, including the configuration blocks themselves,\n   * has a pointer to the latest configuration block, making it easy to query for the\n   * latest channel configuration settings.\n   * <br><br>\n   * A channel configuration record will have the following object structure.\n  <br><pre>\n  version -- {int}\n  mod_policy -- {string}\n  groups\n  Orderer\n  \tversion -- {int}\n  \tgroups\n  \t\t&ltorderer_org_name&gt -- {{@link OrganizationConfigGroup}}\n  \tvalues\n  \t\tConsensusType\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tvalue\n  \t\t\t\ttype -- {string}\n  \t\tBatchSize\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tvalue\n  \t\t\t\tmax_message_count -- {int}\n  \t\t\t\tabsolute_max_bytes -- {int}\n  \t\t\t\tpreferred_max_bytes -- {int}\n  \t\tBatchTimeout\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tvalue\n  \t\t\t\ttimeout -- {duration}\n  \t\tChannelRestrictions\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tvalue\n  \t\t\t\tmax_count -- {int}\n  \tpolicies\n  \t\tAdmins\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  \t\tWriters\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  \t\tReaders\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  \t\tBlockValidation\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link SignaturePolicy}}\n  Application\n  \tversion -- {int}\n  \tgroups\n  \t\t&ltpeer_org_name&gt -- {{@link OrganizationConfigGroup}}\n  \tvalues\n  \tpolicies\n  \t\tAdmins\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  \t\tWriters\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  \t\tReaders\n  \t\t\tversion -- {int}\n  \t\t\tmod_policy -- {string}\n  \t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n  values\n  OrdererAddresses\n  \tversion -- {int}\n  \tmod_policy -- {string}\n  \tvalue\n  \t\taddresses -- {array}\n  \t\t\t{string - host:port}\n  HashingAlgorithm\n  \tversion -- {int}\n  \tmod_policy -- {string}\n  \tvalue\n  \t\tname -- {string}\n  BlockDataHashingStructure\n  \tversion -- {int}\n  \tmod_policy -- {string}\n  \tvalue\n  \t\twidth -- {int}\n  Consortium\n  \tversion -- {int}\n  \tmod_policy -- {string}\n  \tvalue\n  \t\tname -- {string}\n  </pre>\n   * @typedef {Object} ChannelConfigGroup\n   * @property {OrganizationConfigGroup} groups.Orderer.groups.&ltorderer_org_name&gt These are the\n   *                                              orderer organizatoin names defined on the network\n   * @property {OrganizationConfigGroup} groups.Application.groups.&ltpeer_org_name&gt These are the\n   *                                              peer organization names defined on the network\n   * @property {ImplicitMetaPolicy} policy These policies point to other policies and specify a\n   *                                              threshold as in \"ANY\", \"MAJORITY\" or \"ALL\"\n   */\n\n  /**\n   * Each participating organization of the channel gets represented in a section\n   * in the configuration block as described below. Critical information about the\n   * organzation such as its Membership Service Provider (MSP) content and its pre-defined\n   * policies that form the basis of the channel's access control policies (Admins, Writers\n   * and Readers) are contained in these sections.\n   * <br><br>\n   * A organizational configuration will have the following object structure.\n  <br><pre>\n  version -- {int}\n  mod_policy -- {string}\n  values\n  MSP\n  \tversion -- {int}\n  \tmod_policy -- {string}\n  \tvalue\n  \t\ttype -- {int}\n  \t\tconfig\n  \t\t\tname -- {string}\n  \t\t\troot_certs -- {string[]}\n  \t\t\tintermediate_certs -- {string[]}\n  \t\t\tadmins -- {string[]}\n  \t\t\trevocation_list -- {string[]}\n  \t\t\tsigning_identity -- {byte[]}\n  \t\t\torganizational_unit_identifiers -- {string[]}\n  policies\n   Admins\n  \t\tversion -- {int}\n  \t\tmod_policy -- {string}\n  \t\tpolicy -- {{@link SignaturePolicy}}\n   Writers\n  \t\tversion -- {int}\n  \t\tmod_policy -- {string}\n  \t\tpolicy -- {{@link SignaturePolicy}}\n   Readers\n  \t\tversion -- {int}\n  \t\tmod_policy -- {string}\n  \t\tpolicy -- {{@link SignaturePolicy}}\n  </pre>\n   * @typedef {Object} OrganizationConfigGroup\n   */\n\n  /**\n   * An endorsement is a signature of an endorser over a proposal response.  By\n   * producing an endorsement message, an endorser implicitly \"approves\" that\n   * proposal response and the actions contained therein. When enough\n   * endorsements have been collected, a transaction can be generated out of a\n   * set of proposal responses\n   * <br><br>\n   * An endorsement message has the following structure:\n  <br><pre>\n  endorser\n  Mspid -- {string]\n  IdBytes -- {byte[]}\n  signature -- {byte[]}\n  </pre>\n   *\n   * @typedef {Object} Endorsement\n   */\n\n  /**\n   * ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration\n   * It is implicit because the rule is generate implicitly based on the number of sub policies\n   * It is meta because it depends only on the result of other policies\n   * <br><br>\n   * When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy\n   * of name sub_policy, evaluates the collection and applies the rule.\n   * <br><br>\n   * For example, with 4 sub-groups, and a policy name of \"Readers\", ImplicitMetaPolicy retrieves\n   * each sub-group, retrieves policy \"Readers\" for each subgroup, evaluates it, and, in the case of ANY\n   * 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.\n   * <br><br>\n   * An \"ImplicitMetaPolicy\" will have the following object structure.\n  <br><pre>\n  type -- IMPLICIT_META\n  policy\n  sub_policy -- {string}\n  rule -- ANY | ALL | MAJORITY\n  </pre>\n   * @typedef {Object} ImplicitMetaPolicy\n   */\n\n  /**\n   * SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing\n   * policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent\n   * to express AND as well as OR, as well as of course N out of the following M policies.\n   * <br><br>\n   * SignedBy implies that the signature is from a valid certificate which is signed by the trusted\n   * authority specified in the bytes.  This will be the certificate itself for a self-signed certificate\n   * and will be the CA for more traditional certificates\n   * <br><br>\n   * A \"SignaturePolicy\" will have the following object structure.\n  <br><pre>\n  type -- SIGNATURE\n  rule\n  Type -- n_out_of\n  n_out_of\n  \tN -- {int}\n  \trules -- {array}\n  \t\tType -- signed_by\n  \t\tsigned_by -- {int}\n  identities -- {array}\n  \tprincipal_classification -- {int}\n  \tmsp_identifier -- {string}\n  \tRole -- MEMBER | ADMIN\n  </pre>\n   * @typedef {Object} SignaturePolicy\n   */\n\n  /**\n   * Constructs a JSON object containing all decoded values from the\n   * protobuf encoded `Block` bytes.\n   *\n   * @param {byte[]} blockBuf - The encoded bytes of a Block protobuf message\n   * @returns {Block} An object of the Block\n   */\n  static decode(blockBuf) {\n    logger.debug('decode - start');\n    if (!blockBuf || !(blockBuf instanceof Buffer)) {\n      throw new Error('Block input data is not a byte buffer');\n    }\n    const block = {};\n    try {\n      const blockProto = fabproto6.common.Block.decode(blockBuf);\n      block.header = decodeBlockHeader(blockProto.header);\n      block.data = decodeBlockData(blockProto.data);\n      block.metadata = decodeBlockMetaData(blockProto.metadata);\n    } catch (error) {\n      logger.error('decode - ::' + (error.stack ? error.stack : error));\n      throw error;\n    }\n    logger.debug('decode - end');\n    return block;\n  }\n\n  /**\n   * Constructs an object containing all decoded values from the\n   * protobuf `common.Block` object\n   *\n   * @param {Object} blockProto- an object that represents the protobuf common.Block\n   * @returns {Block} An object of the fully decoded protobuf common.Block\n   */\n  static decodeBlock(blockProto) {\n    logger.debug('decodeBlock - start %j', blockProto);\n    if (!blockProto) {\n      throw new Error('Block input data is missing');\n    }\n    const block = {};\n    try {\n      block.header = {\n        number: blockProto.header.number,\n        previous_hash: blockProto.header.previous_hash,\n        data_hash: blockProto.header.data_hash\n      };\n      block.data = decodeBlockData(blockProto.data);\n      block.metadata = decodeBlockMetaData(blockProto.metadata);\n    } catch (error) {\n      logger.error('decode - ::' + (error.stack ? error.stack : error));\n      throw new Error('Block decode has failed with ' + error.toString());\n    }\n    logger.debug('decodeBlock - end');\n    return block;\n  }\n\n  /**\n   * Constructs an object containing all decoded values from the\n   * protobuf `common.Block` object\n   *\n   * @param {Object} filteredBlockProto- an object that represents the protobuf protos.FilteredBlock\n   * @returns {FilteredBlock} An object of the fully decoded protobuf protos.FilteredBlock\n   */\n  static decodeFilteredBlock(filteredBlockProto) {\n    logger.debug('decodeFilteredBlock - start %j', filteredBlockProto);\n    if (!filteredBlockProto) {\n      throw new Error('FilteredBlock input data is missing');\n    }\n    const filtered_block = {};\n    try {\n      filtered_block.channel_id = filteredBlockProto.channel_id;\n      if (filteredBlockProto.number) {\n        filtered_block.number = filteredBlockProto.number;\n      }\n      filtered_block.filtered_transactions = decodeFilteredTransactions(filteredBlockProto.filtered_transactions);\n    } catch (error) {\n      logger.error('decode - ::' + (error.stack ? error.stack : error));\n      throw new Error('FilteredBlock decode has failed with ' + error.toString());\n    }\n    logger.debug('decodeFilteredBlock - end');\n    return filtered_block;\n  }\n\n  /**\n   * Constructs an object containing all decoded values from the\n   * protobuf `BlockAndPrivateData` object\n   *\n   * @param {Object} blockAndPrivateDataProto - an object that represents the protobuf common.BlockAndPrivateData\n   * @returns {Object} An object with the fully decoded protobuf common.Block and the private data map\n   */\n  static decodeBlockWithPrivateData(blockAndPrivateDataProto) {\n    logger.debug('decodeBlockWithPrivateData - start');\n    if (!blockAndPrivateDataProto) {\n      throw new Error('Block with private data input data is missing');\n    }\n    const blockAndPrivateData = {};\n    try {\n      blockAndPrivateData.block = this.decodeBlock(blockAndPrivateDataProto.block);\n      blockAndPrivateData.private_data_map = decodePrivateData(blockAndPrivateDataProto.private_data_map);\n    } catch (error) {\n      logger.error('decode - ::' + (error.stack ? error.stack : error));\n      throw new Error('Block with private data decode has failed with ' + error.toString());\n    }\n    logger.debug('decodeBlockWithPrivateData - end');\n    return blockAndPrivateData;\n  }\n\n  /**\n   * @typedef {Object} ProcessedTransaction\n   * @property {number} validationCode - See [this list]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/peer/transaction.proto#L125}\n   * for all the defined validation codes\n   * @property {Object} transactionEnvelope - Encapsulates the transaction and the signature over it.\n   * It has the following structure:\n  \t<br><pre>\n  \tsignature -- {byte[]}\n  \tpayload -- {}\n  \theader -- {{@link Header}}\n  \tdata -- {{@link Transaction}}\n  \t</pre>\n   */\n\n  /**\n   * Constructs an object containing all decoded values from the\n   * protobuf encoded \"ProcessedTransaction\" bytes\n   *\n   * @param {byte[]} processedTransactionBuf - The encode bytes of a protobuf\n   *                                               message \"ProcessedTransaction\"\n   * @returns {ProcessedTransaction} A fully decoded ProcessedTransaction object\n   */\n  static decodeTransaction(processedTransactionBuf) {\n    logger.debug('decodeTransaction - start');\n    if (!(processedTransactionBuf instanceof Buffer)) {\n      throw new Error('Processed transaction data is not a byte buffer');\n    }\n    const processedTransactionProto = fabproto6.protos.ProcessedTransaction.decode(processedTransactionBuf);\n    const transactionEnvelope = decodeBlockDataEnvelope(processedTransactionProto.transactionEnvelope);\n    logger.debug('decodeTransaction - end');\n    return {\n      validationCode: processedTransactionProto.validationCode,\n      transactionEnvelope\n    };\n  }\n}\nfunction decodeFilteredTransactions(filteredTransactionsProto) {\n  logger.debug('decodeFilteredTransactions - %j', filteredTransactionsProto);\n  const filtered_transactions = [];\n  if (filteredTransactionsProto && Array.isArray(filteredTransactionsProto)) {\n    for (const filteredTransactionProto of filteredTransactionsProto) {\n      const filtered_transaction = {};\n      filtered_transaction.txid = filteredTransactionProto.txid;\n      filtered_transaction.type = filteredTransactionProto.type;\n      filtered_transaction.typeString = fabproto6.common.HeaderType[filteredTransactionProto.type];\n      filtered_transaction.tx_validation_code = filteredTransactionProto.tx_validation_code;\n      filtered_transaction.transaction_actions = decodeFilteredTransactionActions(filteredTransactionProto.transaction_actions);\n      filtered_transactions.push(filtered_transaction);\n    }\n  }\n  return filtered_transactions;\n}\nfunction decodeFilteredTransactionActions(transactionActionsProto) {\n  const transaction_actions = {};\n  if (transactionActionsProto && transactionActionsProto.chaincode_actions) {\n    transaction_actions.chaincode_actions = [];\n    if (Array.isArray(transactionActionsProto.chaincode_actions)) {\n      for (const filteredChaincodeAction of transactionActionsProto.chaincode_actions) {\n        const chaincode_action = decodeFilteredChaincodeAction(filteredChaincodeAction);\n        transaction_actions.chaincode_actions.push(chaincode_action);\n      }\n    }\n  }\n  return transaction_actions;\n}\nfunction decodeFilteredChaincodeAction(filteredChaincodeActionProto) {\n  const chaincode_action = {};\n  if (filteredChaincodeActionProto && filteredChaincodeActionProto.chaincode_event) {\n    chaincode_action.chaincode_event = {\n      chaincode_id: filteredChaincodeActionProto.chaincode_event.chaincode_id,\n      tx_id: filteredChaincodeActionProto.chaincode_event.tx_id,\n      event_name: filteredChaincodeActionProto.chaincode_event.event_name\n      // filtered events do not have a payload\n    };\n  }\n\n  return chaincode_action;\n}\nfunction decodePrivateData(privateDataMapProto) {\n  if (!privateDataMapProto) {\n    logger.debug('decodePrivateData - private data is missing');\n    return {};\n  }\n  const private_data_map = {};\n  let found = false;\n  // map key is the transaction index of the transaction for the private data\n  for (const txIndex in privateDataMapProto) {\n    const tx_pvt_read_write_set = {};\n    const txPvtReadWriteSetProto = privateDataMapProto[txIndex];\n    tx_pvt_read_write_set.data_model = txPvtReadWriteSetProto.data_model; // only KV=0\n    tx_pvt_read_write_set.ns_pvt_rwset = [];\n    for (const nsPvtRwsetProto of txPvtReadWriteSetProto.ns_pvt_rwset) {\n      const ns_pvt_rwset = {};\n      ns_pvt_rwset.namespace = nsPvtRwsetProto.namespace;\n      ns_pvt_rwset.collection_pvt_rwset = [];\n      for (const collectionPvtRwsetProto of nsPvtRwsetProto.collection_pvt_rwset) {\n        const collection_pvt_rwset = {};\n        collection_pvt_rwset.collection_name = collectionPvtRwsetProto.collection_name;\n        collection_pvt_rwset.rwset = decodeKVRWSet(collectionPvtRwsetProto.rwset);\n        ns_pvt_rwset.collection_pvt_rwset.push(collection_pvt_rwset);\n      }\n      tx_pvt_read_write_set.ns_pvt_rwset.push(ns_pvt_rwset);\n    }\n    const intIndex = fabproto6.uint64ToNumber(txIndex);\n    private_data_map[intIndex] = tx_pvt_read_write_set;\n    found = true;\n  }\n  if (!found) {\n    logger.debug('decodePrivateData - no private data');\n  }\n  return private_data_map;\n}\nfunction decodeBlockHeader(blockHeaderProto) {\n  const block_header = {};\n  block_header.number = blockHeaderProto.number;\n  block_header.previous_hash = blockHeaderProto.previous_hash;\n  block_header.data_hash = blockHeaderProto.data_hash;\n  return block_header;\n}\nfunction decodeBlockData(dataProto) {\n  const data = {};\n  data.data = [];\n  for (const dataBuf of dataProto.data) {\n    const envelopeProto = fabproto6.common.Envelope.decode(dataBuf);\n    const envelope = decodeBlockDataEnvelope(envelopeProto);\n    data.data.push(envelope);\n  }\n  return data;\n}\nfunction decodeBlockMetaData(metadataProto) {\n  const metadata = {};\n  metadata.metadata = [];\n  // metadata is an array with fixed locations for metadata types\n  if (metadataProto && metadataProto.metadata) {\n    metadata.metadata[0] = decodeMetadataSignatures(metadataProto.metadata[0]);\n    metadata.metadata[1] = {};\n    metadata.metadata[2] = decodeTransactionFilter(metadataProto.metadata[2]);\n    metadata.metadata[3] = {};\n    metadata.metadata[4] = decodeCommitHash(metadataProto.metadata[4]);\n  }\n  return metadata;\n}\nfunction decodeCommitHash(metadataBuf) {\n  return metadataBuf; // just return the buffer as is\n}\n\nfunction decodeTransactionFilter(metadataBuf) {\n  const transaction_filter = [];\n  if (!metadataBuf || !(metadataBuf instanceof Buffer)) {\n    logger.debug('decodeTransactionFilter - no metadata');\n    return transaction_filter;\n  }\n  logger.debug('decodeTransactionFilter - transactionFilters length:%s', metadataBuf.length);\n  for (let i = 0; i < metadataBuf.length; i++) {\n    const value = parseInt(metadataBuf[i]);\n    logger.debug('decodeTransactionFilter - looking at index:%s with value:%s', i, value);\n    transaction_filter.push(value);\n  }\n  return transaction_filter;\n}\nfunction decodeMetadataSignatures(metadataBuf) {\n  const metadata = {};\n  const metadataProto = fabproto6.common.Metadata.decode(metadataBuf);\n  metadata.value = metadataProto.value;\n  metadata.signatures = decodeMetadataValueSignatures(metadataProto.signatures);\n  return metadata;\n}\nfunction decodeMetadataValueSignatures(signaturesProto) {\n  const signatures = [];\n  if (signaturesProto) {\n    for (const metadataSignatureProto of signaturesProto) {\n      const metadata_signature = {};\n      metadata_signature.signature_header = decodeSignatureHeader(metadataSignatureProto.signature_header);\n      metadata_signature.signature = metadataSignatureProto.signature;\n      signatures.push(metadata_signature);\n    }\n  }\n  return signatures;\n}\nfunction decodeBlockDataEnvelope(envelopeProto) {\n  const envelope = {};\n  envelope.signature = envelopeProto.signature;\n  envelope.payload = {};\n  const payloadProto = fabproto6.common.Payload.decode(envelopeProto.payload);\n  envelope.payload.header = decodeHeader(payloadProto.header);\n  switch (envelope.payload.header.channel_header.type) {\n    case 1:\n      envelope.payload.data = decodeConfigEnvelope(payloadProto.data);\n      break;\n    case 2:\n      envelope.payload.data = decodeConfigUpdateEnvelope(payloadProto.data);\n      break;\n    case 3:\n      envelope.payload.data = decodeEndorserTransaction(payloadProto.data);\n      break;\n    default:\n      logger.debug(' ***** found an unknown header type of %s', envelope.payload.header.channel_header.type);\n      // return empty data on types we do not know so that\n      // event processing may continue on blocks we do not\n      // care about\n      envelope.payload.data = {};\n  }\n  // let's also have the type as the enum string value so it is easier to read\n  envelope.payload.header.channel_header.typeString = fabproto6.common.HeaderType[envelope.payload.header.channel_header.type];\n  return envelope;\n}\nfunction decodeEndorserTransaction(dataBuf) {\n  const data = {};\n  try {\n    const transactionProto = fabproto6.protos.Transaction.decode(dataBuf);\n    data.actions = [];\n    if (transactionProto && transactionProto.actions) {\n      for (const actionProto of transactionProto.actions) {\n        const action = {};\n        action.header = decodeSignatureHeader(actionProto.header);\n        action.payload = decodeChaincodeActionPayload(actionProto.payload);\n        data.actions.push(action);\n      }\n    }\n  } catch (error) {\n    logger.error(' Unable to decodeEndorserTransaction :: %s', error);\n    logger.error(' Unable to decodeEndorserTransaction :: %s', error.stack);\n  }\n  return data;\n}\nfunction decodeConfigEnvelope(dataBuf) {\n  const config_envelope = {};\n  const configEnvelopeProto = fabproto6.common.ConfigEnvelope.decode(dataBuf);\n  config_envelope.config = decodeConfig(configEnvelopeProto.config);\n  logger.debug('decodeConfigEnvelope - decode complete for config envelope - start config update');\n  config_envelope.last_update = {};\n  const lastUpdateProto = configEnvelopeProto.last_update; // this is a common.Envelope\n  if (lastUpdateProto) {\n    // the orderer's genesis block may not have this field\n    config_envelope.last_update.payload = {};\n    const payloadProto = fabproto6.common.Payload.decode(lastUpdateProto.payload);\n    config_envelope.last_update.payload.header = decodeHeader(payloadProto.header);\n    config_envelope.last_update.payload.data = decodeConfigUpdateEnvelope(payloadProto.data);\n    config_envelope.last_update.signature = lastUpdateProto.signature; // leave as bytes\n  }\n\n  return config_envelope;\n}\nfunction decodeConfig(configProto) {\n  const config = {};\n  config.sequence = configProto.sequence; // unit64\n  config.channel_group = decodeConfigGroup(configProto.channel_group);\n  return config;\n}\nfunction decodeConfigUpdateEnvelope(dataBuf) {\n  const config_update_envelope = {};\n  const configUpdateEnvelopeProto = fabproto6.common.ConfigUpdateEnvelope.decode(dataBuf);\n  config_update_envelope.config_update = decodeConfigUpdate(configUpdateEnvelopeProto.config_update);\n  const signatures = [];\n  for (const configSignatureProto of configUpdateEnvelopeProto.signatures) {\n    const config_signature = decodeConfigSignature(configSignatureProto);\n    signatures.push(config_signature);\n  }\n  config_update_envelope.signatures = signatures;\n  return config_update_envelope;\n}\nfunction decodeConfigUpdate(configUpdateBuf) {\n  const config_update = {};\n  const configUpdateProto = fabproto6.common.ConfigUpdate.decode(configUpdateBuf);\n  config_update.channel_id = configUpdateProto.channel_id;\n  config_update.read_set = decodeConfigGroup(configUpdateProto.read_set);\n  config_update.write_set = decodeConfigGroup(configUpdateProto.write_set);\n  return config_update;\n}\nfunction decodeConfigGroups(configGroupsProto) {\n  const config_groups = {};\n  const keys = Object.keys(configGroupsProto);\n  for (const groupName of keys) {\n    config_groups[groupName] = decodeConfigGroup(configGroupsProto[groupName]);\n  }\n  return config_groups;\n}\nfunction decodeConfigGroup(configGroupProto) {\n  if (!configGroupProto) {\n    return null;\n  }\n  const config_group = {};\n  config_group.version = convertVersion(configGroupProto.version);\n  config_group.groups = decodeConfigGroups(configGroupProto.groups);\n  config_group.values = decodeConfigValues(configGroupProto.values);\n  config_group.policies = decodeConfigPolicies(configGroupProto.policies);\n  config_group.mod_policy = configGroupProto.mod_policy; // string\n  return config_group;\n}\nfunction decodeConfigValues(configValuesProto) {\n  const config_values = {};\n  const keys = Object.keys(configValuesProto);\n  for (const valueName of keys) {\n    config_values[valueName] = decodeConfigValue(configValuesProto[valueName], valueName);\n  }\n  return config_values;\n}\nfunction decodeConfigValueAnchorPeers(valueBuf) {\n  const value = {};\n  value.anchor_peers = [];\n  const anchorPeersProto = fabproto6.protos.AnchorPeers.decode(valueBuf);\n  if (anchorPeersProto && anchorPeersProto.anchor_peers) {\n    for (const anchorPeerProto of anchorPeersProto.anchor_peers) {\n      const anchor_peer = {\n        host: anchorPeerProto.host,\n        port: anchorPeerProto.port\n      };\n      value.anchor_peers.push(anchor_peer);\n    }\n  }\n  return value;\n}\nfunction decodeConfigValueMSP(valueBuf) {\n  const value = {};\n  const mspConfigProto = fabproto6.msp.MSPConfig.decode(valueBuf);\n  value.type = mspConfigProto.type;\n  if (mspConfigProto.type === 0) {\n    value.config = decodeFabricMSPConfig(mspConfigProto.config);\n  }\n  return value;\n}\nfunction decodeConfigValueConsensusType(valueBuf) {\n  const value = {};\n  const consensusTypeProto = fabproto6.orderer.ConsensusType.decode(valueBuf);\n  value.type = consensusTypeProto.type; // string\n\n  return value;\n}\nfunction decodeConfigValueBatchSize(valueBuf) {\n  const value = {};\n  const batchSizeProto = fabproto6.orderer.BatchSize.decode(valueBuf);\n  value.max_message_count = batchSizeProto.max_message_count; // uint32\n  value.absolute_max_bytes = batchSizeProto.absolute_max_bytes; // uint32\n  value.preferred_max_bytes = batchSizeProto.preferred_max_bytes; // uint32\n\n  return value;\n}\nfunction decodeConfigValueBatchTimeout(valueBuf) {\n  const value = {};\n  const batchTimeoutProto = fabproto6.orderer.BatchTimeout.decode(valueBuf);\n  value.timeout = batchTimeoutProto.timeout; // string\n\n  return value;\n}\nfunction decodeConfigValueChannelRestrictions(valueBuf) {\n  const value = {};\n  const channelRestrictionsProto = fabproto6.orderer.ChannelRestrictions.decode(valueBuf);\n  value.max_count = channelRestrictionsProto.max_count; // unit64\n\n  return value;\n}\nfunction decodeConfigValueBlockDataConsortium(valueBuf) {\n  const value = {};\n  const consortiumName = fabproto6.common.Consortium.decode(valueBuf);\n  value.name = consortiumName.name; // string\n\n  return value;\n}\nfunction decodeConfigValueHashingAlgorithm(valueBuf) {\n  const value = {};\n  const hashingAlgorithmProto = fabproto6.common.HashingAlgorithm.decode(valueBuf);\n  value.name = hashingAlgorithmProto.name; // string\n\n  return value;\n}\nfunction decodeConfigValueBlockDataHashingStructure(valueBuf) {\n  const value = {};\n  const blockdataHashingStructureProto = fabproto6.common.BlockDataHashingStructure.decode(valueBuf);\n  value.width = blockdataHashingStructureProto.width; // int\n\n  return value;\n}\nfunction decodeConfigValueOrdererAddresses(valueBuf) {\n  const value = {};\n  const ordererAddressesProto = fabproto6.common.OrdererAddresses.decode(valueBuf);\n  value.addresses = [];\n  for (const address of ordererAddressesProto.addresses) {\n    value.addresses.push(address); // string\n  }\n\n  return value;\n}\nfunction decodeConfigCapabilities(valueBuf) {\n  const value = {};\n  const capabilitiesProto = fabproto6.common.Capabilities.decode(valueBuf);\n  value.capabilities = capabilitiesProto.capabilities;\n  return value;\n}\nfunction decodeConfigACLs(valueBuf) {\n  const value = {};\n  const aclsProto = fabproto6.protos.ACLs.decode(valueBuf);\n  value.acls = aclsProto.acls;\n  return value;\n}\nfunction decodeConfigValue(configValueProto, valueName) {\n  const config_value = {};\n  logger.debug(' ======> Config item ::%s', valueName);\n  config_value.mod_policy = configValueProto.mod_policy;\n  config_value.version = convertVersion(configValueProto.version);\n  switch (valueName) {\n    case 'AnchorPeers':\n      config_value.value = decodeConfigValueAnchorPeers(configValueProto.value);\n      break;\n    case 'MSP':\n      config_value.value = decodeConfigValueMSP(configValueProto.value);\n      break;\n    case 'ConsensusType':\n      config_value.value = decodeConfigValueConsensusType(configValueProto.value);\n      break;\n    case 'BatchSize':\n      config_value.value = decodeConfigValueBatchSize(configValueProto.value);\n      break;\n    case 'BatchTimeout':\n      config_value.value = decodeConfigValueBatchTimeout(configValueProto.value);\n      break;\n    case 'ChannelRestrictions':\n      config_value.value = decodeConfigValueChannelRestrictions(configValueProto.value);\n      break;\n    case 'Consortium':\n      config_value.value = decodeConfigValueBlockDataConsortium(configValueProto.value);\n      break;\n    case 'HashingAlgorithm':\n      config_value.value = decodeConfigValueHashingAlgorithm(configValueProto.value);\n      break;\n    case 'BlockDataHashingStructure':\n      config_value.value = decodeConfigValueBlockDataHashingStructure(configValueProto.value);\n      break;\n    case 'OrdererAddresses':\n      config_value.value = decodeConfigValueOrdererAddresses(configValueProto.value);\n      break;\n    case 'Capabilities':\n      config_value.value = decodeConfigCapabilities(configValueProto.value);\n      break;\n    case 'ACLs':\n      config_value.value = decodeConfigACLs(configValueProto.value);\n      break;\n    default:\n  }\n  return config_value;\n}\nfunction decodeConfigPolicies(configPoliciesProto) {\n  const config_policies = {};\n  const keys = Object.keys(configPoliciesProto);\n  for (const policyName of keys) {\n    config_policies[policyName] = decodeConfigPolicy(configPoliciesProto[policyName]);\n  }\n  return config_policies;\n}\nfunction decodeConfigPolicy(configPolicyProto) {\n  const config_policy = {};\n  config_policy.version = convertVersion(configPolicyProto.version);\n  config_policy.mod_policy = configPolicyProto.mod_policy;\n  config_policy.policy = {};\n  if (configPolicyProto && configPolicyProto.policy) {\n    config_policy.policy.type = configPolicyProto.policy.type;\n    config_policy.policy.typeString = fabproto6.common.Policy.PolicyType[configPolicyProto.policy.type];\n    logger.debug('decodeConfigPolicy ======> Policy ::%s', config_policy.policy.typeString);\n    switch (configPolicyProto.policy.type) {\n      case fabproto6.common.Policy.PolicyType.SIGNATURE:\n        config_policy.policy.value = decodeSignaturePolicyEnvelope(configPolicyProto.policy.value);\n        break;\n      case fabproto6.common.Policy.PolicyType.MSP:\n        // var proto_msp = fabproto6.common.Policy.decode(configPolicyProto.value.policy.value);\n        logger.warn('decodeConfigPolicy - found a PolicyType of MSP. This policy type has not been implemented yet.');\n        break;\n      case fabproto6.common.Policy.PolicyType.IMPLICIT_META:\n        config_policy.policy.value = decodeImplicitMetaPolicy(configPolicyProto.policy.value);\n        break;\n      default:\n        throw new Error('Unknown Policy type');\n    }\n  }\n  return config_policy;\n}\nfunction decodeImplicitMetaPolicy(implicitMetaPolicyBuf) {\n  const implicit_meta_policy = {};\n  const implicitMetaPolicyProto = fabproto6.common.ImplicitMetaPolicy.decode(implicitMetaPolicyBuf);\n  implicit_meta_policy.sub_policy = implicitMetaPolicyProto.sub_policy;\n  implicit_meta_policy.rule = implicitMetaPolicyProto.rule;\n  implicit_meta_policy.ruleString = fabproto6.common.ImplicitMetaPolicy.Rule[implicitMetaPolicyProto.rule];\n  return implicit_meta_policy;\n}\nfunction decodeSignaturePolicyEnvelope(signaturePolicyEnvelopeBuf) {\n  const signature_policy_envelope = {};\n  const signaturePolicyEnvelopeProto = fabproto6.common.SignaturePolicyEnvelope.decode(signaturePolicyEnvelopeBuf);\n  signature_policy_envelope.version = convertVersion(signaturePolicyEnvelopeProto.version);\n  signature_policy_envelope.rule = decodeSignaturePolicy(signaturePolicyEnvelopeProto.rule);\n  signature_policy_envelope.identities = [];\n  const identitiesProto = signaturePolicyEnvelopeProto.identities;\n  if (identitiesProto) {\n    for (const mSPPrincipalProto of identitiesProto) {\n      const msp_principal = decodeMSPPrincipal(mSPPrincipalProto);\n      signature_policy_envelope.identities.push(msp_principal);\n    }\n  }\n  return signature_policy_envelope;\n}\nfunction decodeSignaturePolicy(signaturePolicyProto) {\n  const signature_policy = {};\n  if (signaturePolicyProto.n_out_of) {\n    signature_policy.n_out_of = {};\n    signature_policy.n_out_of.n = signaturePolicyProto.n_out_of.n;\n    signature_policy.n_out_of.rules = [];\n    for (const childSignaturePolicyProto of signaturePolicyProto.n_out_of.rules) {\n      const child_signature_policy = decodeSignaturePolicy(childSignaturePolicyProto);\n      signature_policy.n_out_of.rules.push(child_signature_policy);\n    }\n  } else {\n    signature_policy.signed_by = signaturePolicyProto.signed_by; // int32\n  }\n\n  return signature_policy;\n}\nfunction decodeMSPPrincipal(mSPPrincipalProto) {\n  let msp_principal = {};\n  msp_principal.principal_classification = mSPPrincipalProto.principal_classification;\n  let principalProto;\n  switch (msp_principal.principal_classification) {\n    case fabproto6.common.MSPPrincipal.Classification.ROLE:\n      principalProto = fabproto6.common.MSPRole.decode(mSPPrincipalProto.principal);\n      msp_principal.msp_identifier = principalProto.msp_identifier;\n      msp_principal.role = principalProto.role;\n      // add a string for the role type\n      msp_principal.roleString = fabproto6.common.MSPRole.MSPRoleType[principalProto.role];\n      break;\n    case fabproto6.common.MSPPrincipal.Classification.ORGANIZATION_UNIT:\n      principalProto = fabproto6.common.OrganizationUnit.decode(mSPPrincipalProto.principal);\n      msp_principal.msp_identifier = principalProto.msp_identifier; // string\n      msp_principal.organizational_unit_identifier = principalProto.organizational_unit_identifier; // string\n      msp_principal.certifiers_identifier = principalProto.certifiers_identifier; // bytes\n      break;\n    case fabproto6.common.MSPPrincipal.Classification.IDENTITY:\n      msp_principal = decodeIdentity(mSPPrincipalProto.principal);\n      break;\n  }\n  return msp_principal;\n}\nfunction decodeConfigSignature(configSignatureProto) {\n  const config_signature = {};\n  config_signature.signature_header = decodeSignatureHeader(configSignatureProto.signature_header);\n  config_signature.sigature = configSignatureProto.signature;\n  return config_signature;\n}\nfunction decodeSignatureHeader(signatureHeaderBuf) {\n  const signature_header = {};\n  const signatureHeaderProto = fabproto6.common.SignatureHeader.decode(signatureHeaderBuf);\n  signature_header.creator = decodeIdentity(signatureHeaderProto.creator);\n  signature_header.nonce = signatureHeaderProto.nonce;\n  return signature_header;\n}\nfunction decodeIdentity(identityBuf) {\n  const identity = {};\n  try {\n    const identityProto = fabproto6.msp.SerializedIdentity.decode(identityBuf);\n    identity.mspid = identityProto.mspid;\n    identity.id_bytes = identityProto.id_bytes;\n  } catch (err) {\n    logger.error('Failed to decode the identity: %s', err.stack ? err.stack : err);\n  }\n  return identity;\n}\nfunction decodeFabricMSPConfig(fabricMSPConfigBuf) {\n  const config = {};\n  const mspConfigProto = fabproto6.msp.FabricMSPConfig.decode(fabricMSPConfigBuf);\n  config.name = mspConfigProto.name;\n  config.root_certs = toPEMcerts(mspConfigProto.root_certs);\n  config.intermediate_certs = toPEMcerts(mspConfigProto.intermediate_certs);\n  config.admins = toPEMcerts(mspConfigProto.admins);\n  config.revocation_list = toPEMcerts(mspConfigProto.revocation_list);\n  config.signing_identity = decodeSigningIdentityInfo(mspConfigProto.signing_identity);\n  config.organizational_unit_identifiers = decodeFabricOUIdentifier(mspConfigProto.organizational_unit_identifiers);\n  config.tls_root_certs = toPEMcerts(mspConfigProto.tls_root_certs);\n  config.tls_intermediate_certs = toPEMcerts(mspConfigProto.tls_intermediate_certs);\n  return config;\n}\nfunction decodeFabricOUIdentifier(organizationalUnitIdentitfiersProto) {\n  const organizational_unit_identitfiers = [];\n  if (organizationalUnitIdentitfiersProto) {\n    for (let i = 0; i < organizationalUnitIdentitfiersProto.length; i++) {\n      const organizationalUnitIdentitfierProto = organizationalUnitIdentitfiersProto[i];\n      const organizational_unit_identitfier = {};\n      organizational_unit_identitfier.certificate = organizationalUnitIdentitfierProto.certificate;\n      organizational_unit_identitfier.organizational_unit_identifier = organizationalUnitIdentitfierProto.organizational_unit_identifier;\n      organizational_unit_identitfiers.push(organizational_unit_identitfier);\n    }\n  }\n  return organizational_unit_identitfiers;\n}\nfunction toPEMcerts(buffer_array_in) {\n  const buffer_array_out = [];\n  for (const i in buffer_array_in) {\n    buffer_array_out.push(buffer_array_in[i]);\n  }\n  return buffer_array_out;\n}\nfunction decodeSigningIdentityInfo(signingIdentityInfoBuf) {\n  const signing_identity_info = {};\n  if (signingIdentityInfoBuf) {\n    const signingIdentityInfoProto = fabproto6.msp.SigningIdentityInfo.decode(signingIdentityInfoBuf);\n    signing_identity_info.public_signer = signingIdentityInfoProto.public_signer;\n    signing_identity_info.private_signer = decodeKeyInfo(signingIdentityInfoProto.private_signer);\n  }\n  return signing_identity_info;\n}\nfunction decodeKeyInfo(keyInfoBuf) {\n  const key_info = {};\n  if (keyInfoBuf) {\n    const keyInfoProto = fabproto6.msp.KeyInfo.decode(keyInfoBuf);\n    key_info.key_identifier = keyInfoProto.key_identifier;\n    key_info.key_material = 'private'; // should not show this\n  }\n\n  return key_info;\n}\nfunction decodeHeader(headerProto) {\n  const header = {};\n  header.channel_header = decodeChannelHeader(headerProto.channel_header);\n  header.signature_header = decodeSignatureHeader(headerProto.signature_header);\n  return header;\n}\nfunction decodeChannelHeader(channelHeaderBuf) {\n  const channel_header = {};\n  const channelHeaderProto = fabproto6.common.ChannelHeader.decode(channelHeaderBuf);\n  channel_header.type = channelHeaderProto.type;\n  logger.debug('decodeChannelHeader - looking at type:%s', channel_header.type);\n  channel_header.version = convertVersion(channelHeaderProto.version);\n  channel_header.timestamp = timeStampToDate(channelHeaderProto.timestamp);\n  channel_header.channel_id = channelHeaderProto.channel_id;\n  channel_header.tx_id = channelHeaderProto.tx_id;\n  channel_header.epoch = channelHeaderProto.epoch; // unit64\n  // TODO need to decode this\n  channel_header.extension = channelHeaderProto.extension;\n  return channel_header;\n}\nfunction decodeChaincodeActionPayload(chaincodeActionPayloadBuf) {\n  const payload = {};\n  const chaincodeActionPayloadProto = fabproto6.protos.ChaincodeActionPayload.decode(chaincodeActionPayloadBuf);\n  payload.chaincode_proposal_payload = decodeChaincodeProposalPayload(chaincodeActionPayloadProto.chaincode_proposal_payload);\n  payload.action = decodeChaincodeEndorsedAction(chaincodeActionPayloadProto.action);\n  return payload;\n}\nfunction decodeChaincodeProposalPayload(chaincodeProposalPayloadBuf) {\n  const chaincode_proposal_payload = {};\n  const chaincodeProposalPayloadProto = fabproto6.protos.ChaincodeProposalPayload.decode(chaincodeProposalPayloadBuf);\n  chaincode_proposal_payload.input = decodeChaincodeProposalPayloadInput(chaincodeProposalPayloadProto.input);\n  // TransientMap is not allowed to be included on ledger\n\n  return chaincode_proposal_payload;\n}\nfunction decodeChaincodeProposalPayloadInput(chaincodePoposalPayloadInputBuf) {\n  const chaincode_proposal_payload_input = {};\n\n  // For a normal transaction, input is ChaincodeInvocationSpec.\n  const chaincodeInvocationSpecProto = fabproto6.protos.ChaincodeInvocationSpec.decode(chaincodePoposalPayloadInputBuf);\n  chaincode_proposal_payload_input.chaincode_spec = decodeChaincodeSpec(chaincodeInvocationSpecProto.chaincode_spec);\n  return chaincode_proposal_payload_input;\n}\nfunction decodeChaincodeSpec(chaincodeSpecProto) {\n  const chaincode_spec = {};\n  chaincode_spec.type = chaincodeSpecProto.type;\n  // Add a string for the chaincode type (GOLANG, NODE, etc.)\n  chaincode_spec.typeString = fabproto6.protos.ChaincodeSpec.Type[chaincode_spec.type];\n  chaincode_spec.input = decodeChaincodeInput(chaincodeSpecProto.input);\n  chaincode_spec.chaincode_id = chaincodeSpecProto.chaincode_id;\n  chaincode_spec.timeout = chaincodeSpecProto.timeout;\n  return chaincode_spec;\n}\nfunction decodeChaincodeInput(chaincodeInputProto) {\n  const chaincode_input = {};\n  chaincode_input.args = [];\n  for (const arg of chaincodeInputProto.args) {\n    chaincode_input.args.push(arg);\n  }\n  const keys = Object.keys(chaincodeInputProto.decorations);\n  chaincode_input.decorations = {};\n  for (const key of keys) {\n    chaincode_input.decorations[key] = chaincodeInputProto.decorations[key];\n  }\n  chaincode_input.is_init = chaincodeInputProto.is_init;\n  return chaincode_input;\n}\nfunction decodeChaincodeEndorsedAction(chaincodeEndorsedActionProto) {\n  const chaincode_endorsed_action = {};\n  chaincode_endorsed_action.proposal_response_payload = decodeProposalResponsePayload(chaincodeEndorsedActionProto.proposal_response_payload);\n  chaincode_endorsed_action.endorsements = [];\n  for (const endorsementProto of chaincodeEndorsedActionProto.endorsements) {\n    const endorsement = decodeEndorsement(endorsementProto);\n    chaincode_endorsed_action.endorsements.push(endorsement);\n  }\n  return chaincode_endorsed_action;\n}\nfunction decodeEndorsement(endorsementProto) {\n  const endorsement = {};\n  endorsement.endorser = decodeIdentity(endorsementProto.endorser);\n  endorsement.signature = endorsementProto.signature;\n  return endorsement;\n}\nfunction decodeProposalResponsePayload(proposalResponsePayloadBuf) {\n  const proposal_response_payload = {};\n  const proposalResponsePayloadProto = fabproto6.protos.ProposalResponsePayload.decode(proposalResponsePayloadBuf);\n  proposal_response_payload.proposal_hash = proposalResponsePayloadProto.proposal_hash;\n  proposal_response_payload.extension = decodeChaincodeAction(proposalResponsePayloadProto.extension);\n  return proposal_response_payload;\n}\nfunction decodeChaincodeAction(chaincodeActionBuf) {\n  logger.debug('decodeChaincodeAction - start');\n  const chaincode_action = {};\n  const chaincodeActionProto = fabproto6.protos.ChaincodeAction.decode(chaincodeActionBuf);\n  chaincode_action.results = decodeReadWriteSets(chaincodeActionProto.results);\n  // it may be called events, however it is only one event at this time\n  chaincode_action.events = decodeChaincodeEvent(chaincodeActionProto.events);\n  chaincode_action.response = decodeResponse(chaincodeActionProto.response);\n  chaincode_action.chaincode_id = decodeChaincodeID(chaincodeActionProto.chaincode_id);\n  return chaincode_action;\n}\nfunction decodeChaincodeEvent(chaincodeEventBuf) {\n  const event = {};\n  const chaincodeEventProto = fabproto6.protos.ChaincodeEvent.decode(chaincodeEventBuf);\n  event.chaincode_id = chaincodeEventProto.chaincode_id;\n  event.tx_id = chaincodeEventProto.tx_id;\n  event.event_name = chaincodeEventProto.event_name;\n  event.payload = chaincodeEventProto.payload;\n  return event;\n}\nfunction decodeResponse(responseProto) {\n  if (responseProto) {\n    const response = {};\n    response.status = responseProto.status;\n    response.message = responseProto.message;\n    response.payload = responseProto.payload;\n    return response;\n  }\n  return undefined;\n}\nfunction decodeChaincodeID(chaincodeIDProto) {\n  const chaincode_id = {};\n  if (!chaincodeIDProto) {\n    logger.debug('decodeChaincodeID - no chaincodeIDProto found');\n    return chaincode_id;\n  }\n  logger.debug('decodeChaincodeID - start');\n  chaincode_id.path = chaincodeIDProto.path;\n  chaincode_id.name = chaincodeIDProto.name;\n  chaincode_id.version = chaincodeIDProto.version;\n  return chaincode_id;\n}\nfunction decodeReadWriteSets(rwsetBuf) {\n  const txReadWriteSetProto = fabproto6.rwset.TxReadWriteSet.decode(rwsetBuf);\n  const tx_read_write_set = {};\n  tx_read_write_set.data_model = txReadWriteSetProto.data_model;\n  if (txReadWriteSetProto.data_model === fabproto6.rwset.TxReadWriteSet.DataModel.KV) {\n    tx_read_write_set.ns_rwset = [];\n    for (const nsReadWriteSet of txReadWriteSetProto.ns_rwset) {\n      const kv_rw_set = {};\n      kv_rw_set.namespace = nsReadWriteSet.namespace;\n      kv_rw_set.rwset = decodeKVRWSet(nsReadWriteSet.rwset);\n      kv_rw_set.collection_hashed_rwset = decodeCollectionHashedRWSet(nsReadWriteSet.collection_hashed_rwset);\n      tx_read_write_set.ns_rwset.push(kv_rw_set);\n    }\n  } else {\n    // not able to decode this type of rw set, return as is\n    tx_read_write_set.ns_rwset = txReadWriteSetProto.ns_rwset;\n  }\n  return tx_read_write_set;\n}\nfunction decodeKVRWSet(kvBuf) {\n  const kVRWSetProto = fabproto6.kvrwset.KVRWSet.decode(kvBuf);\n  const kv_rw_set = {};\n\n  // build reads\n  kv_rw_set.reads = [];\n  for (const kvReadProto of kVRWSetProto.reads) {\n    kv_rw_set.reads.push(decodeKVRead(kvReadProto));\n  }\n\n  // build range_queries_info\n  kv_rw_set.range_queries_info = [];\n  for (const rangeQueryInfoProto of kVRWSetProto.range_queries_info) {\n    kv_rw_set.range_queries_info.push(decodeRangeQueryInfo(rangeQueryInfoProto));\n  }\n\n  // build writes\n  kv_rw_set.writes = [];\n  for (const kVWriteProto of kVRWSetProto.writes) {\n    kv_rw_set.writes.push(decodeKVWrite(kVWriteProto));\n  }\n\n  // build metadata writes\n  kv_rw_set.metadata_writes = [];\n  for (const kVMetadataWriteProto of kVRWSetProto.metadata_writes) {\n    kv_rw_set.metadata_writes.push(decodeKVMetadataWrite(kVMetadataWriteProto));\n  }\n  return kv_rw_set;\n}\nfunction decodeVersion(versionProto) {\n  if (versionProto) {\n    const version = {};\n    version.block_num = versionProto.block_num;\n    version.tx_num = versionProto.tx_num;\n    return version;\n  }\n  return;\n}\nfunction decodeKVRead(kVReadProto) {\n  const kv_read = {};\n  kv_read.key = kVReadProto.key;\n  kv_read.version = decodeVersion(kVReadProto.version);\n  return kv_read;\n}\nfunction decodeRangeQueryInfo(rangeQueryInfoProto) {\n  const range_query_info = {};\n  range_query_info.start_key = rangeQueryInfoProto.start_key;\n  range_query_info.end_key = rangeQueryInfoProto.end_key;\n  range_query_info.itr_exhausted = rangeQueryInfoProto.itr_exhausted;\n\n  // reads_info is one of QueryReads or QueryReadsMerkleSummary\n  if (rangeQueryInfoProto.raw_reads) {\n    range_query_info.raw_reads = {};\n    range_query_info.raw_reads.kv_reads = [];\n    for (const kVReadProto of rangeQueryInfoProto.raw_reads.kv_reads) {\n      range_query_info.raw_reads.kv_reads.push(decodeKVRead(kVReadProto));\n    }\n  } else if (rangeQueryInfoProto.reads_merkle_hashes) {\n    range_query_info.reads_merkle_hashes = {};\n    range_query_info.reads_merkle_hashes.max_degree = rangeQueryInfoProto.reads_merkle_hashes.max_degree;\n    range_query_info.reads_merkle_hashes.max_level = rangeQueryInfoProto.reads_merkle_hashes.max_level;\n    range_query_info.reads_merkle_hashes.max_level_hashes = rangeQueryInfoProto.reads_merkle_hashes.max_level_hashes;\n  }\n  return range_query_info;\n}\nfunction decodeKVWrite(kVWriteProto) {\n  const kv_write = {};\n  kv_write.key = kVWriteProto.key;\n  kv_write.is_delete = kVWriteProto.is_delete;\n  kv_write.value = kVWriteProto.value;\n  return kv_write;\n}\nfunction decodeKVMetadataWrite(kVMetadataWriteProto) {\n  const kv_metadata_write = {};\n  kv_metadata_write.key = kVMetadataWriteProto.key;\n  kv_metadata_write.entries = [];\n  for (const kVMetadataEntryProto of kVMetadataWriteProto.entries) {\n    kv_metadata_write.entries.push(decodeKVMetadataEntry(kVMetadataEntryProto));\n  }\n  return kv_metadata_write;\n}\nfunction decodeKVMetadataEntry(kVMetadataEntryProto) {\n  const kv_metadata_entry = {};\n  kv_metadata_entry.name = kVMetadataEntryProto.name;\n  kv_metadata_entry.value = kVMetadataEntryProto.value;\n  return kv_metadata_entry;\n}\n\n// This decodes an array of CollectionHashedReadWriteSet\nfunction decodeCollectionHashedRWSet(collectionHashedRwsetArray) {\n  const collection_hashed_rwset = [];\n  for (const collectionHashedRwset of collectionHashedRwsetArray) {\n    const collection = {};\n    collection.collection_name = collectionHashedRwset.collection_name;\n    collection.hashed_rwset = decodeHashedRwset(collectionHashedRwset.hashed_rwset);\n    collection.pvt_rwset_hash = collectionHashedRwset.pvt_rwset_hash;\n    collection_hashed_rwset.push(collection);\n  }\n  return collection_hashed_rwset;\n}\nfunction decodeHashedRwset(hashedRWSetBuf) {\n  const hashedRWSetProto = fabproto6.kvrwset.HashedRWSet.decode(hashedRWSetBuf);\n  const hashed_rwset = {};\n  hashed_rwset.hashed_reads = [];\n  for (const kVReadHashProto of hashedRWSetProto.hashed_reads) {\n    hashed_rwset.hashed_reads.push(decodeKVReadHash(kVReadHashProto));\n  }\n  hashed_rwset.hashed_writes = [];\n  for (const kVWriteHashProto of hashedRWSetProto.hashed_writes) {\n    hashed_rwset.hashed_writes.push(decodeKVWriteHash(kVWriteHashProto));\n  }\n  hashed_rwset.metadata_writes = [];\n  for (const kVMetadataWriteHashProto of hashedRWSetProto.metadata_writes) {\n    hashed_rwset.metadata_writes.push(decodeKVMetadataWriteHash(kVMetadataWriteHashProto));\n  }\n  return hashed_rwset;\n}\nfunction decodeKVReadHash(kVReadHashProto) {\n  const kv_read_hash = {};\n  kv_read_hash.key_hash = kVReadHashProto.key_hash;\n  kv_read_hash.version = decodeVersion(kVReadHashProto.version);\n  return kv_read_hash;\n}\nfunction decodeKVWriteHash(kVWriteHashProto) {\n  const kv_write_hash = {};\n  kv_write_hash.key_hash = kVWriteHashProto.key_hash;\n  kv_write_hash.is_delete = kVWriteHashProto.is_delete;\n  kv_write_hash.value_hash = kVWriteHashProto.value_hash;\n  return kv_write_hash;\n}\nfunction decodeKVMetadataWriteHash(kVMetadataWriteHashProto) {\n  const kv_metadata_write_hash = {};\n  kv_metadata_write_hash.key_hash = kVMetadataWriteHashProto.key_hash;\n  kv_metadata_write_hash.entries = [];\n  for (const kVMetadataEntryProto of kVMetadataWriteHashProto.entries) {\n    kv_metadata_write_hash.entries.push(decodeKVMetadataEntry(kVMetadataEntryProto));\n  }\n  return kv_metadata_write_hash;\n}\n\n// version numbers should not get that big\n// so lets just return an Integer (32bits)\nfunction convertVersion(versionLong) {\n  const versionString = versionLong.toString();\n  const version = Number.parseInt(versionString);\n  return version;\n}\nfunction timeStampToDate(timestamp) {\n  if (!timestamp) {\n    return 'null';\n  }\n  const millis = timestamp.seconds * 1000 + timestamp.nanos / 1000000;\n  const date = new Date(millis);\n  return date.toISOString();\n}\nmodule.exports = BlockDecoder;","map":{"version":3,"names":["fabproto6","require","utils","logger","getLogger","BlockDecoder","decode","blockBuf","debug","Buffer","Error","block","blockProto","common","Block","header","decodeBlockHeader","data","decodeBlockData","metadata","decodeBlockMetaData","error","stack","decodeBlock","number","previous_hash","data_hash","toString","decodeFilteredBlock","filteredBlockProto","filtered_block","channel_id","filtered_transactions","decodeFilteredTransactions","decodeBlockWithPrivateData","blockAndPrivateDataProto","blockAndPrivateData","private_data_map","decodePrivateData","decodeTransaction","processedTransactionBuf","processedTransactionProto","protos","ProcessedTransaction","transactionEnvelope","decodeBlockDataEnvelope","validationCode","filteredTransactionsProto","Array","isArray","filteredTransactionProto","filtered_transaction","txid","type","typeString","HeaderType","tx_validation_code","transaction_actions","decodeFilteredTransactionActions","push","transactionActionsProto","chaincode_actions","filteredChaincodeAction","chaincode_action","decodeFilteredChaincodeAction","filteredChaincodeActionProto","chaincode_event","chaincode_id","tx_id","event_name","privateDataMapProto","found","txIndex","tx_pvt_read_write_set","txPvtReadWriteSetProto","data_model","ns_pvt_rwset","nsPvtRwsetProto","namespace","collection_pvt_rwset","collectionPvtRwsetProto","collection_name","rwset","decodeKVRWSet","intIndex","uint64ToNumber","blockHeaderProto","block_header","dataProto","dataBuf","envelopeProto","Envelope","envelope","metadataProto","decodeMetadataSignatures","decodeTransactionFilter","decodeCommitHash","metadataBuf","transaction_filter","length","i","value","parseInt","Metadata","signatures","decodeMetadataValueSignatures","signaturesProto","metadataSignatureProto","metadata_signature","signature_header","decodeSignatureHeader","signature","payload","payloadProto","Payload","decodeHeader","channel_header","decodeConfigEnvelope","decodeConfigUpdateEnvelope","decodeEndorserTransaction","transactionProto","Transaction","actions","actionProto","action","decodeChaincodeActionPayload","config_envelope","configEnvelopeProto","ConfigEnvelope","config","decodeConfig","last_update","lastUpdateProto","configProto","sequence","channel_group","decodeConfigGroup","config_update_envelope","configUpdateEnvelopeProto","ConfigUpdateEnvelope","config_update","decodeConfigUpdate","configSignatureProto","config_signature","decodeConfigSignature","configUpdateBuf","configUpdateProto","ConfigUpdate","read_set","write_set","decodeConfigGroups","configGroupsProto","config_groups","keys","Object","groupName","configGroupProto","config_group","version","convertVersion","groups","values","decodeConfigValues","policies","decodeConfigPolicies","mod_policy","configValuesProto","config_values","valueName","decodeConfigValue","decodeConfigValueAnchorPeers","valueBuf","anchor_peers","anchorPeersProto","AnchorPeers","anchorPeerProto","anchor_peer","host","port","decodeConfigValueMSP","mspConfigProto","msp","MSPConfig","decodeFabricMSPConfig","decodeConfigValueConsensusType","consensusTypeProto","orderer","ConsensusType","decodeConfigValueBatchSize","batchSizeProto","BatchSize","max_message_count","absolute_max_bytes","preferred_max_bytes","decodeConfigValueBatchTimeout","batchTimeoutProto","BatchTimeout","timeout","decodeConfigValueChannelRestrictions","channelRestrictionsProto","ChannelRestrictions","max_count","decodeConfigValueBlockDataConsortium","consortiumName","Consortium","name","decodeConfigValueHashingAlgorithm","hashingAlgorithmProto","HashingAlgorithm","decodeConfigValueBlockDataHashingStructure","blockdataHashingStructureProto","BlockDataHashingStructure","width","decodeConfigValueOrdererAddresses","ordererAddressesProto","OrdererAddresses","addresses","address","decodeConfigCapabilities","capabilitiesProto","Capabilities","capabilities","decodeConfigACLs","aclsProto","ACLs","acls","configValueProto","config_value","configPoliciesProto","config_policies","policyName","decodeConfigPolicy","configPolicyProto","config_policy","policy","Policy","PolicyType","SIGNATURE","decodeSignaturePolicyEnvelope","MSP","warn","IMPLICIT_META","decodeImplicitMetaPolicy","implicitMetaPolicyBuf","implicit_meta_policy","implicitMetaPolicyProto","ImplicitMetaPolicy","sub_policy","rule","ruleString","Rule","signaturePolicyEnvelopeBuf","signature_policy_envelope","signaturePolicyEnvelopeProto","SignaturePolicyEnvelope","decodeSignaturePolicy","identities","identitiesProto","mSPPrincipalProto","msp_principal","decodeMSPPrincipal","signaturePolicyProto","signature_policy","n_out_of","n","rules","childSignaturePolicyProto","child_signature_policy","signed_by","principal_classification","principalProto","MSPPrincipal","Classification","ROLE","MSPRole","principal","msp_identifier","role","roleString","MSPRoleType","ORGANIZATION_UNIT","OrganizationUnit","organizational_unit_identifier","certifiers_identifier","IDENTITY","decodeIdentity","sigature","signatureHeaderBuf","signatureHeaderProto","SignatureHeader","creator","nonce","identityBuf","identity","identityProto","SerializedIdentity","mspid","id_bytes","err","fabricMSPConfigBuf","FabricMSPConfig","root_certs","toPEMcerts","intermediate_certs","admins","revocation_list","signing_identity","decodeSigningIdentityInfo","organizational_unit_identifiers","decodeFabricOUIdentifier","tls_root_certs","tls_intermediate_certs","organizationalUnitIdentitfiersProto","organizational_unit_identitfiers","organizationalUnitIdentitfierProto","organizational_unit_identitfier","certificate","buffer_array_in","buffer_array_out","signingIdentityInfoBuf","signing_identity_info","signingIdentityInfoProto","SigningIdentityInfo","public_signer","private_signer","decodeKeyInfo","keyInfoBuf","key_info","keyInfoProto","KeyInfo","key_identifier","key_material","headerProto","decodeChannelHeader","channelHeaderBuf","channelHeaderProto","ChannelHeader","timestamp","timeStampToDate","epoch","extension","chaincodeActionPayloadBuf","chaincodeActionPayloadProto","ChaincodeActionPayload","chaincode_proposal_payload","decodeChaincodeProposalPayload","decodeChaincodeEndorsedAction","chaincodeProposalPayloadBuf","chaincodeProposalPayloadProto","ChaincodeProposalPayload","input","decodeChaincodeProposalPayloadInput","chaincodePoposalPayloadInputBuf","chaincode_proposal_payload_input","chaincodeInvocationSpecProto","ChaincodeInvocationSpec","chaincode_spec","decodeChaincodeSpec","chaincodeSpecProto","ChaincodeSpec","Type","decodeChaincodeInput","chaincodeInputProto","chaincode_input","args","arg","decorations","key","is_init","chaincodeEndorsedActionProto","chaincode_endorsed_action","proposal_response_payload","decodeProposalResponsePayload","endorsements","endorsementProto","endorsement","decodeEndorsement","endorser","proposalResponsePayloadBuf","proposalResponsePayloadProto","ProposalResponsePayload","proposal_hash","decodeChaincodeAction","chaincodeActionBuf","chaincodeActionProto","ChaincodeAction","results","decodeReadWriteSets","events","decodeChaincodeEvent","response","decodeResponse","decodeChaincodeID","chaincodeEventBuf","event","chaincodeEventProto","ChaincodeEvent","responseProto","status","message","undefined","chaincodeIDProto","path","rwsetBuf","txReadWriteSetProto","TxReadWriteSet","tx_read_write_set","DataModel","KV","ns_rwset","nsReadWriteSet","kv_rw_set","collection_hashed_rwset","decodeCollectionHashedRWSet","kvBuf","kVRWSetProto","kvrwset","KVRWSet","reads","kvReadProto","decodeKVRead","range_queries_info","rangeQueryInfoProto","decodeRangeQueryInfo","writes","kVWriteProto","decodeKVWrite","metadata_writes","kVMetadataWriteProto","decodeKVMetadataWrite","decodeVersion","versionProto","block_num","tx_num","kVReadProto","kv_read","range_query_info","start_key","end_key","itr_exhausted","raw_reads","kv_reads","reads_merkle_hashes","max_degree","max_level","max_level_hashes","kv_write","is_delete","kv_metadata_write","entries","kVMetadataEntryProto","decodeKVMetadataEntry","kv_metadata_entry","collectionHashedRwsetArray","collectionHashedRwset","collection","hashed_rwset","decodeHashedRwset","pvt_rwset_hash","hashedRWSetBuf","hashedRWSetProto","HashedRWSet","hashed_reads","kVReadHashProto","decodeKVReadHash","hashed_writes","kVWriteHashProto","decodeKVWriteHash","kVMetadataWriteHashProto","decodeKVMetadataWriteHash","kv_read_hash","key_hash","kv_write_hash","value_hash","kv_metadata_write_hash","versionLong","versionString","Number","millis","seconds","nanos","date","Date","toISOString","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/BlockDecoder.js"],"sourcesContent":["/*\n * Copyright IBM Corp. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n'use strict';\n\nconst fabproto6 = require('fabric-protos');\nconst utils = require('./Utils');\n\nconst logger = utils.getLogger('BlockDecoder.js');\n\n/**\n * Utility class to convert a protobuf encoded byte array of a Hyperledger Fabric block\n * message into a pure Javascript object with the key names as they appear in the protobuf\n * defintions (typically snake case)\n *\n * @class\n */\nclass BlockDecoder {\n\t/**\n\t * An object of a fully decoded protobuf message \"Block\".\n\t * <br><br>\n\t * A Block may contain the configuration of the channel or transactions on the channel.\n\t * <br><br>\n\t * A Block object will have the following object structure.\n<br><pre>\nheader\n\tnumber -- {int}\n\tprevious_hash -- {byte[]}\n\tdata_hash -- {byte[]}\ndata\n\tdata -- {array}\n\t\tsignature -- {byte[]}\n\t\tpayload\n\t\t\theader -- {{@link Header}}\n\t\t\tdata -- {{@link ConfigEnvelope} | {@link Transaction}}\nmetadata\n\tmetadata -- {array} #each array item has it's own layout\n\t\t[0] #SIGNATURES\n\t\t\tsignatures -- {{@link MetadataSignature[]}}\n\t\t[1] #LAST_CONFIG\n\t\t\tvalue\n\t\t\t\tindex -- {number}\n\t\t\t\tsignatures -- {{@link MetadataSignature[]}}\n\t\t[2] #TRANSACTIONS_FILTER\n\t\t\t\t{int[]} #see TxValidationCode in proto/peer/transaction.proto\n</pre>\n\t *\n\t * @typedef {Object} Block\n\t *\n\t * @example\n\t * <caption>Get the block number:</caption>\n\t * var block_num = block.header.number;\n\t *\n\t * @example\n\t * <caption>Get the number of transactions, including the invalid transactions:</caption>\n\t * var block_num = block.data.data.length;\n\t *\n\t * @example\n\t * <caption>Get the Id of the first transaction in the block:</caption>\n\t * var tx_id = block.data.data[0].payload.header.channel_header.tx_id;\n\t */\n\n\t/**\n\t * Headers describe basic information about a transaction record, such\n\t * as its type (configuration update, or endorser transaction, etc.),\n\t * the id of the channel it belongs to, the transaction id and so on.\n\t * The header message also contains a common field {@link SignatureHeader}\n\t * that describes critical information about how to verify signatures.\n\t * <br><br>\n\t * A \"Header\" will have the following object structure.\n<br><pre>\nchannel_header\n\ttype -- {string}\n\tversion -- {int}\n\ttimestamp -- {time}\n\tchannel_id -- {string}\n\ttx_id -- {string}\n\tepoch -- {int}\nsignature_header -- {{@link SignatureHeader}}\n</pre>\n\t * @typedef {Object} Header\n\t */\n\n\t/**\n\t * A signature over the metadata of a block, to ensure the authenticity of\n\t * the metadata that describes a Block.\n<br><pre>\nsignature_header {{@link SignatureHeader}}\nsignature -- {byte[]}\n</pre>\n\t *\n\t * @typedef {Object} MetadataSignature\n\t */\n\n\t/**\n\t * An object that is part of all signatures in Hyperledger Fabric. The \"creator\"\n\t * field has two important pieces of information about the identity of the signer,\n\t * the organization (Mspid) that the signer belongs to, and the certificate (IdBytes).\n\t * The \"nonce\" field is a unique value to guard against replay attacks.\n\t *\n<br><pre>\ncreator\n\tMspid -- {string}\n\tIdBytes -- {byte[]}\nnonce -- {byte[]}\n</pre>\n\t * @typedef {Object} SignatureHeader\n\t */\n\n\t/**\n\t * A ConfigEnvelope contains the channel configurations data and is the\n\t * main content of a configuration block. Another type of blocks are those\n\t * that contain endorser transactions, where the main content is an array\n\t * of {@link Transaction}.\n\t * <br><br>\n\t * A \"ConfigEnvelope\" will have the following object structure.\n<br><pre>\nconfig\n\tsequence -- {int}\n\tchannel_group -- {{@link ConfigGroup}}\n\ttype -- {int}\nlast_update\n\tsignature -- {byte[]}\n\tpayload\n\t\theader -- {{@link Header}}\n\t\tdata -- {{@link ConfigUpdateEnvelope}}\n</pre>\n\t * @typedef {Object} ConfigEnvelope\n\t */\n\n\t/**\n\t * A Transaction, or \"Endorser Transaction\", is the result of invoking chaincodes\n\t * to collect endorsements, getting globally ordered in the context of a channel,\n\t * and getting validated by the committer peer as part of a block before finally\n\t * being formally \"committed\" to the ledger inside a Block. Each transaction contains\n\t * an array of \"actions\" representing different steps for executing a transaction,\n\t * and those steps will be processed atomically, meaning if any one step failed\n\t * then the whole transaction will be marked as rejected.\n\t * <br><br>\n\t * Each entry of the \"actions\" array contains a chaincode proposal and corresponding proposal\n\t * responses that encapsulate the endorsing peer's decisions on whether the proposal\n\t * is considered valid. Note that even if a transaction proposal(s) is considered\n\t * valid by the endorsing peers, it may still be rejected by the committers during\n\t * transaction validation. Whether a transaction as a whole is valid or not, is not\n\t * reflected in the transaction record itself, but rather recorded in a separate\n\t * field in the Block's metadata.\n\t * <br><br>\n\t * A \"Transaction\" will have the following object structure.\n<br><pre>\nactions {array}\n\theader -- {{@link SignatureHeader}}\n\tpayload\n\t\tchaincode_proposal_payload\n\t\t\tinput -- {{@link ChaincodeInvocationSpec}} for a endorser transaction\n\t\taction\n\t\t\tproposal_response_payload\n\t\t\t\tproposal_hash -- {byte[]}\n\t\t\t\textension\n\t\t\t\t\tresults\n\t\t\t\t\t\tdata_model -- {int}\n\t\t\t\t\t\tns_rwset -- {array}\n\t\t\t\t\t\t\tnamespace -- {string}\n\t\t\t\t\t\t\trwset\n\t\t\t\t\t\t\t\treads -- {array}\n\t\t\t\t\t\t\t\t\tkey -- {string}\n\t\t\t\t\t\t\t\t\tversion\n\t\t\t\t\t\t\t\t\t\tblock_num -- {number}\n\t\t\t\t\t\t\t\t\t\ttx_num -- {number}\n\t\t\t\t\t\t\t\trange_queries_info -- {array}\n\t\t\t\t\t\t\t\twrites -- {array}\n\t\t\t\t\t\t\t\t\tkey -- {string}\n\t\t\t\t\t\t\t\t\tis_delete -- {boolean}\n\t\t\t\t\t\t\t\t\tvalue -- {string}\n\t\t\t\t\t\t\t\tmetadata_writes -- {array}\n\t\t\t\t\t\t\t\t\tkey -- {string}\n\t\t\t\t\t\t\t\t\tentries -- {array}\n\t\t\t\t\t\t\t\t\t\tname -- {string}\n\t\t\t\t\t\t\t\t\t\tvalue -- {byte[]}\n\t\t\t\t\t\tcollection_hashed_rwset -- {array}\n\t\t\t\t\t\t\tcollection_name -- {string}\n\t\t\t\t\t\t\thashed_rwset\n\t\t\t\t\t\t\t\thashed_reads -- {array}\n\t\t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n\t\t\t\t\t\t\t\t\tversion\n\t\t\t\t\t\t\t\t\t\tblock_num -- {number}\n\t\t\t\t\t\t\t\t\t\ttx_num -- {number}\n\t\t\t\t\t\t\t\thashed_writes -- {array}\n\t\t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n\t\t\t\t\t\t\t\t\tis_delete -- {boolean}\n\t\t\t\t\t\t\t\t\tvalue_hash -- {byte[]}\n\t\t\t\t\t\t\t\tmetadata_writes -- {array}\n\t\t\t\t\t\t\t\t\tkey_hash -- {byte[]}\n\t\t\t\t\t\t\t\t\tentries -- {array}\n\t\t\t\t\t\t\t\t\t\tname -- {string}\n\t\t\t\t\t\t\t\t\t\tvalue -- {byte[]}\n\t\t\t\t\t\t\tpvt_rwset_hash -- {byte[]}\n\t\t\t\t\tevents\n\t\t\t\t\t\tchaincode_id --  {string}\n\t\t\t\t\t\ttx_id -- {string}\n\t\t\t\t\t\tevent_name -- {string}\n\t\t\t\t\t\tpayload -- {byte[]}\n\t\t\t\t\tresponse\n\t\t\t\t\t\tstatus -- {int}\n\t\t\t\t\t\tmessage -- {string}\n\t\t\t\t\t\tpayload -- {byte[]}\n\t\t\tendorsements -- {{@link Endorsement}[]}\n</pre>\n\t * @typedef {Object} Transaction\n\t */\n\n\t/**\n\t * An endorsement proposal, which includes the name of the chaincode\n\t * to be invoked and the arguments to be passed to the chaincode.\n\t * <br><br>\n\t * A \"ChaincodeInvocationSpec\" has the following object structure.\n<br><pre>\nchaincode_spec\n\ttype -- {int}\n\tchaincode_id\n\t\tpath -- {string}\n\t\tname -- {string}\n\t\tversion -- {string}\n\tinput\n\t\targs -- {byte[][]}\n\t\tdecorations -- {map of string to byte[]}\n\ttimeout -- {int}\n</pre>\n\t *\n\t * @typedef {Object} ChaincodeInvocationSpec\n\t */\n\n\t/**\n\t * An object of a protobuf message \"ConfigUpdateEnvelope\".\n\t * <br><br>\n\t * A \"ConfigUpdateEnvelope\" will have the following object structure.\n<br><pre>\nconfig_update\n\tchannel_id -- {string}\n\tread_set -- {{@link ChannelConfigGroup}}\n\twrite_set -- {{@link ChannelConfigGroup}}\n\ttype -- {int}\nsignatures -- {array}\n\tsignature_header -- {{@link SignatureHeader}}\n\tsignature -- {byte[]}\n</pre>\n\t * @typedef {Object} ConfigUpdateEnvelope\n\t * @property {ChannelConfigGroup} config_update.read_set A set of the current version numbers of all\n\t *           configuration items being updated\n\t * @property {ChannelConfigGroup} config_update.write_set A set of all configuration items being updated. Must have a\n\t *           version number one greater than the version number of the same item\n\t *           in the read_set along with the new value.\n\t */\n\n\t/**\n\t * The configuration settings that govern how the fabric should maintain\n\t * a channel are included in the blocks of the channel itself. When a block contains\n\t * the channel configuration, the channel configuration record is the only item in\n\t * the block's data array. Every block, including the configuration blocks themselves,\n\t * has a pointer to the latest configuration block, making it easy to query for the\n\t * latest channel configuration settings.\n\t * <br><br>\n\t * A channel configuration record will have the following object structure.\n<br><pre>\nversion -- {int}\nmod_policy -- {string}\ngroups\n\tOrderer\n\t\tversion -- {int}\n\t\tgroups\n\t\t\t&ltorderer_org_name&gt -- {{@link OrganizationConfigGroup}}\n\t\tvalues\n\t\t\tConsensusType\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tvalue\n\t\t\t\t\ttype -- {string}\n\t\t\tBatchSize\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tvalue\n\t\t\t\t\tmax_message_count -- {int}\n\t\t\t\t\tabsolute_max_bytes -- {int}\n\t\t\t\t\tpreferred_max_bytes -- {int}\n\t\t\tBatchTimeout\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tvalue\n\t\t\t\t\ttimeout -- {duration}\n\t\t\tChannelRestrictions\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tvalue\n\t\t\t\t\tmax_count -- {int}\n\t\tpolicies\n\t\t\tAdmins\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n\t\t\tWriters\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n\t\t\tReaders\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n\t\t\tBlockValidation\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link SignaturePolicy}}\n\tApplication\n\t\tversion -- {int}\n\t\tgroups\n\t\t\t&ltpeer_org_name&gt -- {{@link OrganizationConfigGroup}}\n\t\tvalues\n\t\tpolicies\n\t\t\tAdmins\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n\t\t\tWriters\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\n\t\t\tReaders\n\t\t\t\tversion -- {int}\n\t\t\t\tmod_policy -- {string}\n\t\t\t\tpolicy -- {{@link ImplicitMetaPolicy}}\nvalues\n\tOrdererAddresses\n\t\tversion -- {int}\n\t\tmod_policy -- {string}\n\t\tvalue\n\t\t\taddresses -- {array}\n\t\t\t\t{string - host:port}\n\tHashingAlgorithm\n\t\tversion -- {int}\n\t\tmod_policy -- {string}\n\t\tvalue\n\t\t\tname -- {string}\n\tBlockDataHashingStructure\n\t\tversion -- {int}\n\t\tmod_policy -- {string}\n\t\tvalue\n\t\t\twidth -- {int}\n\tConsortium\n\t\tversion -- {int}\n\t\tmod_policy -- {string}\n\t\tvalue\n\t\t\tname -- {string}\n</pre>\n\t * @typedef {Object} ChannelConfigGroup\n\t * @property {OrganizationConfigGroup} groups.Orderer.groups.&ltorderer_org_name&gt These are the\n\t *                                              orderer organizatoin names defined on the network\n\t * @property {OrganizationConfigGroup} groups.Application.groups.&ltpeer_org_name&gt These are the\n\t *                                              peer organization names defined on the network\n\t * @property {ImplicitMetaPolicy} policy These policies point to other policies and specify a\n\t *                                              threshold as in \"ANY\", \"MAJORITY\" or \"ALL\"\n\t */\n\n\t/**\n\t * Each participating organization of the channel gets represented in a section\n\t * in the configuration block as described below. Critical information about the\n\t * organzation such as its Membership Service Provider (MSP) content and its pre-defined\n\t * policies that form the basis of the channel's access control policies (Admins, Writers\n\t * and Readers) are contained in these sections.\n\t * <br><br>\n\t * A organizational configuration will have the following object structure.\n<br><pre>\nversion -- {int}\nmod_policy -- {string}\nvalues\n\tMSP\n\t\tversion -- {int}\n\t\tmod_policy -- {string}\n\t\tvalue\n\t\t\ttype -- {int}\n\t\t\tconfig\n\t\t\t\tname -- {string}\n\t\t\t\troot_certs -- {string[]}\n\t\t\t\tintermediate_certs -- {string[]}\n\t\t\t\tadmins -- {string[]}\n\t\t\t\trevocation_list -- {string[]}\n\t\t\t\tsigning_identity -- {byte[]}\n\t\t\t\torganizational_unit_identifiers -- {string[]}\npolicies\n\t Admins\n\t\t\tversion -- {int}\n\t\t\tmod_policy -- {string}\n\t\t\tpolicy -- {{@link SignaturePolicy}}\n\t Writers\n\t\t\tversion -- {int}\n\t\t\tmod_policy -- {string}\n\t\t\tpolicy -- {{@link SignaturePolicy}}\n\t Readers\n\t\t\tversion -- {int}\n\t\t\tmod_policy -- {string}\n\t\t\tpolicy -- {{@link SignaturePolicy}}\n</pre>\n\t * @typedef {Object} OrganizationConfigGroup\n\t */\n\n\n\t/**\n\t * An endorsement is a signature of an endorser over a proposal response.  By\n\t * producing an endorsement message, an endorser implicitly \"approves\" that\n\t * proposal response and the actions contained therein. When enough\n\t * endorsements have been collected, a transaction can be generated out of a\n\t * set of proposal responses\n\t * <br><br>\n\t * An endorsement message has the following structure:\n<br><pre>\nendorser\n\tMspid -- {string]\n\tIdBytes -- {byte[]}\nsignature -- {byte[]}\n</pre>\n\t *\n\t * @typedef {Object} Endorsement\n\t */\n\n\t/**\n\t * ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration\n\t * It is implicit because the rule is generate implicitly based on the number of sub policies\n\t * It is meta because it depends only on the result of other policies\n\t * <br><br>\n\t * When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy\n\t * of name sub_policy, evaluates the collection and applies the rule.\n\t * <br><br>\n\t * For example, with 4 sub-groups, and a policy name of \"Readers\", ImplicitMetaPolicy retrieves\n\t * each sub-group, retrieves policy \"Readers\" for each subgroup, evaluates it, and, in the case of ANY\n\t * 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.\n\t * <br><br>\n\t * An \"ImplicitMetaPolicy\" will have the following object structure.\n<br><pre>\ntype -- IMPLICIT_META\npolicy\n\tsub_policy -- {string}\n\trule -- ANY | ALL | MAJORITY\n</pre>\n\t * @typedef {Object} ImplicitMetaPolicy\n\t */\n\n\t/**\n\t * SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing\n\t * policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent\n\t * to express AND as well as OR, as well as of course N out of the following M policies.\n\t * <br><br>\n\t * SignedBy implies that the signature is from a valid certificate which is signed by the trusted\n\t * authority specified in the bytes.  This will be the certificate itself for a self-signed certificate\n\t * and will be the CA for more traditional certificates\n\t * <br><br>\n\t * A \"SignaturePolicy\" will have the following object structure.\n<br><pre>\ntype -- SIGNATURE\nrule\n\tType -- n_out_of\n\tn_out_of\n\t\tN -- {int}\n\t\trules -- {array}\n\t\t\tType -- signed_by\n\t\t\tsigned_by -- {int}\n\tidentities -- {array}\n\t\tprincipal_classification -- {int}\n\t\tmsp_identifier -- {string}\n\t\tRole -- MEMBER | ADMIN\n</pre>\n\t * @typedef {Object} SignaturePolicy\n\t */\n\n\t/**\n\t * Constructs a JSON object containing all decoded values from the\n\t * protobuf encoded `Block` bytes.\n\t *\n\t * @param {byte[]} blockBuf - The encoded bytes of a Block protobuf message\n\t * @returns {Block} An object of the Block\n\t */\n\tstatic decode(blockBuf) {\n\t\tlogger.debug('decode - start');\n\n\t\tif (!blockBuf || !(blockBuf instanceof Buffer)) {\n\t\t\tthrow new Error('Block input data is not a byte buffer');\n\t\t}\n\t\tconst block = {};\n\t\ttry {\n\t\t\tconst blockProto = fabproto6.common.Block.decode(blockBuf);\n\t\t\tblock.header = decodeBlockHeader(blockProto.header);\n\t\t\tblock.data = decodeBlockData(blockProto.data);\n\t\t\tblock.metadata = decodeBlockMetaData(blockProto.metadata);\n\t\t} catch (error) {\n\t\t\tlogger.error('decode - ::' + (error.stack ? error.stack : error));\n\t\t\tthrow error;\n\t\t}\n\n\t\tlogger.debug('decode - end');\n\t\treturn block;\n\t}\n\n\t/**\n\t * Constructs an object containing all decoded values from the\n\t * protobuf `common.Block` object\n\t *\n\t * @param {Object} blockProto- an object that represents the protobuf common.Block\n\t * @returns {Block} An object of the fully decoded protobuf common.Block\n\t */\n\tstatic decodeBlock(blockProto) {\n\t\tlogger.debug('decodeBlock - start %j', blockProto);\n\n\t\tif (!blockProto) {\n\t\t\tthrow new Error('Block input data is missing');\n\t\t}\n\t\tconst block = {};\n\t\ttry {\n\t\t\tblock.header = {\n\t\t\t\tnumber: blockProto.header.number,\n\t\t\t\tprevious_hash: blockProto.header.previous_hash,\n\t\t\t\tdata_hash: blockProto.header.data_hash\n\t\t\t};\n\t\t\tblock.data = decodeBlockData(blockProto.data);\n\t\t\tblock.metadata = decodeBlockMetaData(blockProto.metadata);\n\t\t} catch (error) {\n\t\t\tlogger.error('decode - ::' + (error.stack ? error.stack : error));\n\t\t\tthrow new Error('Block decode has failed with ' + error.toString());\n\t\t}\n\n\t\tlogger.debug('decodeBlock - end');\n\t\treturn block;\n\t}\n\n\t/**\n\t * Constructs an object containing all decoded values from the\n\t * protobuf `common.Block` object\n\t *\n\t * @param {Object} filteredBlockProto- an object that represents the protobuf protos.FilteredBlock\n\t * @returns {FilteredBlock} An object of the fully decoded protobuf protos.FilteredBlock\n\t */\n\tstatic decodeFilteredBlock(filteredBlockProto) {\n\t\tlogger.debug('decodeFilteredBlock - start %j', filteredBlockProto);\n\n\t\tif (!filteredBlockProto) {\n\t\t\tthrow new Error('FilteredBlock input data is missing');\n\t\t}\n\t\tconst filtered_block = {};\n\t\ttry {\n\t\t\tfiltered_block.channel_id = filteredBlockProto.channel_id;\n\t\t\tif (filteredBlockProto.number) {\n\t\t\t\tfiltered_block.number = filteredBlockProto.number;\n\t\t\t}\n\t\t\tfiltered_block.filtered_transactions = decodeFilteredTransactions(filteredBlockProto.filtered_transactions);\n\t\t} catch (error) {\n\t\t\tlogger.error('decode - ::' + (error.stack ? error.stack : error));\n\t\t\tthrow new Error('FilteredBlock decode has failed with ' + error.toString());\n\t\t}\n\n\t\tlogger.debug('decodeFilteredBlock - end');\n\t\treturn filtered_block;\n\t}\n\n\t/**\n\t * Constructs an object containing all decoded values from the\n\t * protobuf `BlockAndPrivateData` object\n\t *\n\t * @param {Object} blockAndPrivateDataProto - an object that represents the protobuf common.BlockAndPrivateData\n\t * @returns {Object} An object with the fully decoded protobuf common.Block and the private data map\n\t */\n\tstatic decodeBlockWithPrivateData(blockAndPrivateDataProto) {\n\t\tlogger.debug('decodeBlockWithPrivateData - start');\n\n\t\tif (!blockAndPrivateDataProto) {\n\t\t\tthrow new Error('Block with private data input data is missing');\n\t\t}\n\t\tconst blockAndPrivateData = {};\n\t\ttry {\n\t\t\tblockAndPrivateData.block = this.decodeBlock(blockAndPrivateDataProto.block);\n\t\t\tblockAndPrivateData.private_data_map = decodePrivateData(blockAndPrivateDataProto.private_data_map);\n\t\t} catch (error) {\n\t\t\tlogger.error('decode - ::' + (error.stack ? error.stack : error));\n\t\t\tthrow new Error('Block with private data decode has failed with ' + error.toString());\n\t\t}\n\n\t\tlogger.debug('decodeBlockWithPrivateData - end');\n\t\treturn blockAndPrivateData;\n\t}\n\n\t/**\n\t * @typedef {Object} ProcessedTransaction\n\t * @property {number} validationCode - See [this list]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/peer/transaction.proto#L125}\n\t * for all the defined validation codes\n\t * @property {Object} transactionEnvelope - Encapsulates the transaction and the signature over it.\n\t * It has the following structure:\n\t\t<br><pre>\n\t\tsignature -- {byte[]}\n\t\tpayload -- {}\n\t\theader -- {{@link Header}}\n\t\tdata -- {{@link Transaction}}\n\t\t</pre>\n\t */\n\n\t/**\n\t * Constructs an object containing all decoded values from the\n\t * protobuf encoded \"ProcessedTransaction\" bytes\n\t *\n\t * @param {byte[]} processedTransactionBuf - The encode bytes of a protobuf\n\t *                                               message \"ProcessedTransaction\"\n\t * @returns {ProcessedTransaction} A fully decoded ProcessedTransaction object\n\t */\n\tstatic decodeTransaction(processedTransactionBuf) {\n\t\tlogger.debug('decodeTransaction - start');\n\n\n\t\tif (!(processedTransactionBuf instanceof Buffer)) {\n\t\t\tthrow new Error('Processed transaction data is not a byte buffer');\n\t\t}\n\t\tconst processedTransactionProto = fabproto6.protos.ProcessedTransaction.decode(processedTransactionBuf);\n\n\t\tconst transactionEnvelope = decodeBlockDataEnvelope(processedTransactionProto.transactionEnvelope);\n\n\t\tlogger.debug('decodeTransaction - end');\n\t\treturn {\n\t\t\tvalidationCode: processedTransactionProto.validationCode,\n\t\t\ttransactionEnvelope\n\t\t};\n\t}\n}\n\nfunction decodeFilteredTransactions(filteredTransactionsProto) {\n\tlogger.debug('decodeFilteredTransactions - %j', filteredTransactionsProto);\n\tconst filtered_transactions = [];\n\tif (filteredTransactionsProto && Array.isArray(filteredTransactionsProto)) {\n\t\tfor (const filteredTransactionProto of filteredTransactionsProto) {\n\t\t\tconst filtered_transaction = {};\n\t\t\tfiltered_transaction.txid = filteredTransactionProto.txid;\n\t\t\tfiltered_transaction.type = filteredTransactionProto.type;\n\t\t\tfiltered_transaction.typeString = fabproto6.common.HeaderType[filteredTransactionProto.type];\n\t\t\tfiltered_transaction.tx_validation_code = filteredTransactionProto.tx_validation_code;\n\t\t\tfiltered_transaction.transaction_actions = decodeFilteredTransactionActions(filteredTransactionProto.transaction_actions);\n\t\t\tfiltered_transactions.push(filtered_transaction);\n\t\t}\n\t}\n\n\treturn filtered_transactions;\n}\n\nfunction decodeFilteredTransactionActions(transactionActionsProto) {\n\tconst transaction_actions = {};\n\tif (transactionActionsProto && transactionActionsProto.chaincode_actions) {\n\t\ttransaction_actions.chaincode_actions = [];\n\t\tif (Array.isArray(transactionActionsProto.chaincode_actions)) {\n\t\t\tfor (const filteredChaincodeAction of transactionActionsProto.chaincode_actions) {\n\t\t\t\tconst chaincode_action = decodeFilteredChaincodeAction(filteredChaincodeAction);\n\t\t\t\ttransaction_actions.chaincode_actions.push(chaincode_action);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn transaction_actions;\n}\n\nfunction decodeFilteredChaincodeAction(filteredChaincodeActionProto) {\n\tconst chaincode_action = {};\n\tif (filteredChaincodeActionProto && filteredChaincodeActionProto.chaincode_event) {\n\t\tchaincode_action.chaincode_event = {\n\t\t\tchaincode_id: filteredChaincodeActionProto.chaincode_event.chaincode_id,\n\t\t\ttx_id: filteredChaincodeActionProto.chaincode_event.tx_id,\n\t\t\tevent_name: filteredChaincodeActionProto.chaincode_event.event_name\n\t\t\t// filtered events do not have a payload\n\t\t};\n\t}\n\n\treturn chaincode_action;\n}\n\nfunction decodePrivateData(privateDataMapProto) {\n\tif (!privateDataMapProto) {\n\t\tlogger.debug('decodePrivateData - private data is missing');\n\t\treturn {};\n\t}\n\tconst private_data_map = {};\n\tlet found = false;\n\t// map key is the transaction index of the transaction for the private data\n\tfor (const txIndex in privateDataMapProto) {\n\t\tconst tx_pvt_read_write_set = {};\n\t\tconst txPvtReadWriteSetProto = privateDataMapProto[txIndex];\n\n\t\ttx_pvt_read_write_set.data_model = txPvtReadWriteSetProto.data_model; // only KV=0\n\t\ttx_pvt_read_write_set.ns_pvt_rwset = [];\n\t\tfor (const nsPvtRwsetProto of txPvtReadWriteSetProto.ns_pvt_rwset) {\n\t\t\tconst ns_pvt_rwset = {};\n\t\t\tns_pvt_rwset.namespace = nsPvtRwsetProto.namespace;\n\t\t\tns_pvt_rwset.collection_pvt_rwset = [];\n\t\t\tfor (const collectionPvtRwsetProto of nsPvtRwsetProto.collection_pvt_rwset) {\n\t\t\t\tconst collection_pvt_rwset = {};\n\t\t\t\tcollection_pvt_rwset.collection_name = collectionPvtRwsetProto.collection_name;\n\t\t\t\tcollection_pvt_rwset.rwset = decodeKVRWSet(collectionPvtRwsetProto.rwset);\n\t\t\t\tns_pvt_rwset.collection_pvt_rwset.push(collection_pvt_rwset);\n\t\t\t}\n\t\t\ttx_pvt_read_write_set.ns_pvt_rwset.push(ns_pvt_rwset);\n\t\t}\n\t\tconst intIndex = fabproto6.uint64ToNumber(txIndex);\n\t\tprivate_data_map[intIndex] = tx_pvt_read_write_set;\n\t\tfound = true;\n\t}\n\n\tif (!found) {\n\t\tlogger.debug('decodePrivateData - no private data');\n\t}\n\n\treturn private_data_map;\n}\n\nfunction decodeBlockHeader(blockHeaderProto) {\n\tconst block_header = {};\n\tblock_header.number = blockHeaderProto.number;\n\tblock_header.previous_hash = blockHeaderProto.previous_hash;\n\tblock_header.data_hash = blockHeaderProto.data_hash;\n\n\treturn block_header;\n}\n\nfunction decodeBlockData(dataProto) {\n\tconst data = {};\n\tdata.data = [];\n\tfor (const dataBuf of dataProto.data) {\n\t\tconst envelopeProto = fabproto6.common.Envelope.decode(dataBuf);\n\t\tconst envelope = decodeBlockDataEnvelope(envelopeProto);\n\t\tdata.data.push(envelope);\n\t}\n\n\treturn data;\n}\n\nfunction decodeBlockMetaData(metadataProto) {\n\tconst metadata = {};\n\tmetadata.metadata = [];\n\t// metadata is an array with fixed locations for metadata types\n\tif (metadataProto && metadataProto.metadata) {\n\t\tmetadata.metadata[0] = decodeMetadataSignatures(metadataProto.metadata[0]);\n\t\tmetadata.metadata[1] = {};\n\t\tmetadata.metadata[2] = decodeTransactionFilter(metadataProto.metadata[2]);\n\t\tmetadata.metadata[3] = {};\n\t\tmetadata.metadata[4] = decodeCommitHash(metadataProto.metadata[4]);\n\t}\n\n\treturn metadata;\n}\n\nfunction decodeCommitHash(metadataBuf) {\n\treturn metadataBuf; // just return the buffer as is\n}\n\nfunction decodeTransactionFilter(metadataBuf) {\n\tconst transaction_filter = [];\n\tif (!metadataBuf || !(metadataBuf instanceof Buffer)) {\n\t\tlogger.debug('decodeTransactionFilter - no metadata');\n\n\t\treturn transaction_filter;\n\t}\n\n\tlogger.debug('decodeTransactionFilter - transactionFilters length:%s', metadataBuf.length);\n\n\tfor (let i = 0; i < metadataBuf.length; i++) {\n\t\tconst value = parseInt(metadataBuf[i]);\n\t\tlogger.debug('decodeTransactionFilter - looking at index:%s with value:%s', i, value);\n\t\ttransaction_filter.push(value);\n\t}\n\n\treturn transaction_filter;\n}\n\nfunction decodeMetadataSignatures(metadataBuf) {\n\tconst metadata = {};\n\tconst metadataProto = fabproto6.common.Metadata.decode(metadataBuf);\n\tmetadata.value = metadataProto.value;\n\tmetadata.signatures = decodeMetadataValueSignatures(metadataProto.signatures);\n\n\treturn metadata;\n}\n\nfunction decodeMetadataValueSignatures(signaturesProto) {\n\tconst signatures = [];\n\tif (signaturesProto) {\n\t\tfor (const metadataSignatureProto of signaturesProto) {\n\t\t\tconst metadata_signature = {};\n\t\t\tmetadata_signature.signature_header = decodeSignatureHeader(metadataSignatureProto.signature_header);\n\t\t\tmetadata_signature.signature = metadataSignatureProto.signature;\n\t\t\tsignatures.push(metadata_signature);\n\t\t}\n\t}\n\n\treturn signatures;\n}\n\nfunction decodeBlockDataEnvelope(envelopeProto) {\n\tconst envelope = {};\n\tenvelope.signature = envelopeProto.signature;\n\n\tenvelope.payload = {};\n\tconst payloadProto = fabproto6.common.Payload.decode(envelopeProto.payload);\n\tenvelope.payload.header = decodeHeader(payloadProto.header);\n\n\tswitch (envelope.payload.header.channel_header.type) {\n\t\tcase 1:\n\t\t\tenvelope.payload.data = decodeConfigEnvelope(payloadProto.data);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tenvelope.payload.data = decodeConfigUpdateEnvelope(payloadProto.data);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tenvelope.payload.data = decodeEndorserTransaction(payloadProto.data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger.debug(' ***** found an unknown header type of %s', envelope.payload.header.channel_header.type);\n\t\t\t// return empty data on types we do not know so that\n\t\t\t// event processing may continue on blocks we do not\n\t\t\t// care about\n\t\t\tenvelope.payload.data = {};\n\t}\n\t// let's also have the type as the enum string value so it is easier to read\n\tenvelope.payload.header.channel_header.typeString =\n\t\tfabproto6.common.HeaderType[envelope.payload.header.channel_header.type];\n\n\treturn envelope;\n}\n\nfunction decodeEndorserTransaction(dataBuf) {\n\tconst data = {};\n\ttry {\n\t\tconst transactionProto = fabproto6.protos.Transaction.decode(dataBuf);\n\t\tdata.actions = [];\n\t\tif (transactionProto && transactionProto.actions) {\n\t\t\tfor (const actionProto of transactionProto.actions) {\n\t\t\t\tconst action = {};\n\t\t\t\taction.header = decodeSignatureHeader(actionProto.header);\n\t\t\t\taction.payload = decodeChaincodeActionPayload(actionProto.payload);\n\t\t\t\tdata.actions.push(action);\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlogger.error(' Unable to decodeEndorserTransaction :: %s', error);\n\t\tlogger.error(' Unable to decodeEndorserTransaction :: %s', error.stack);\n\t}\n\n\treturn data;\n}\n\nfunction decodeConfigEnvelope(dataBuf) {\n\tconst config_envelope = {};\n\tconst configEnvelopeProto = fabproto6.common.ConfigEnvelope.decode(dataBuf);\n\tconfig_envelope.config = decodeConfig(configEnvelopeProto.config);\n\tlogger.debug('decodeConfigEnvelope - decode complete for config envelope - start config update');\n\tconfig_envelope.last_update = {};\n\tconst lastUpdateProto = configEnvelopeProto.last_update; // this is a common.Envelope\n\tif (lastUpdateProto) { // the orderer's genesis block may not have this field\n\t\tconfig_envelope.last_update.payload = {};\n\t\tconst payloadProto = fabproto6.common.Payload.decode(lastUpdateProto.payload);\n\t\tconfig_envelope.last_update.payload.header = decodeHeader(payloadProto.header);\n\t\tconfig_envelope.last_update.payload.data = decodeConfigUpdateEnvelope(payloadProto.data);\n\t\tconfig_envelope.last_update.signature = lastUpdateProto.signature; // leave as bytes\n\t}\n\n\treturn config_envelope;\n}\n\nfunction decodeConfig(configProto) {\n\tconst config = {};\n\tconfig.sequence = configProto.sequence; // unit64\n\tconfig.channel_group = decodeConfigGroup(configProto.channel_group);\n\n\treturn config;\n}\n\nfunction decodeConfigUpdateEnvelope(dataBuf) {\n\tconst config_update_envelope = {};\n\tconst configUpdateEnvelopeProto = fabproto6.common.ConfigUpdateEnvelope.decode(dataBuf);\n\tconfig_update_envelope.config_update = decodeConfigUpdate(configUpdateEnvelopeProto.config_update);\n\tconst signatures = [];\n\tfor (const configSignatureProto of configUpdateEnvelopeProto.signatures) {\n\t\tconst config_signature = decodeConfigSignature(configSignatureProto);\n\t\tsignatures.push(config_signature);\n\t}\n\tconfig_update_envelope.signatures = signatures;\n\n\treturn config_update_envelope;\n}\n\nfunction decodeConfigUpdate(configUpdateBuf) {\n\tconst config_update = {};\n\tconst configUpdateProto = fabproto6.common.ConfigUpdate.decode(configUpdateBuf);\n\tconfig_update.channel_id = configUpdateProto.channel_id;\n\tconfig_update.read_set = decodeConfigGroup(configUpdateProto.read_set);\n\tconfig_update.write_set = decodeConfigGroup(configUpdateProto.write_set);\n\n\treturn config_update;\n}\n\nfunction decodeConfigGroups(configGroupsProto) {\n\tconst config_groups = {};\n\tconst keys = Object.keys(configGroupsProto);\n\tfor (const groupName of keys) {\n\t\tconfig_groups[groupName] = decodeConfigGroup(configGroupsProto[groupName]);\n\t}\n\n\treturn config_groups;\n}\n\nfunction decodeConfigGroup(configGroupProto) {\n\tif (!configGroupProto) {\n\t\treturn null;\n\t}\n\tconst config_group = {};\n\tconfig_group.version = convertVersion(configGroupProto.version);\n\tconfig_group.groups = decodeConfigGroups(configGroupProto.groups);\n\tconfig_group.values = decodeConfigValues(configGroupProto.values);\n\tconfig_group.policies = decodeConfigPolicies(configGroupProto.policies);\n\tconfig_group.mod_policy = configGroupProto.mod_policy; // string\n\treturn config_group;\n}\n\nfunction decodeConfigValues(configValuesProto) {\n\tconst config_values = {};\n\tconst keys = Object.keys(configValuesProto);\n\tfor (const valueName of keys) {\n\t\tconfig_values[valueName] = decodeConfigValue(configValuesProto[valueName], valueName);\n\t}\n\n\treturn config_values;\n}\n\nfunction decodeConfigValueAnchorPeers(valueBuf) {\n\tconst value = {};\n\tvalue.anchor_peers = [];\n\tconst anchorPeersProto = fabproto6.protos.AnchorPeers.decode(valueBuf);\n\tif (anchorPeersProto && anchorPeersProto.anchor_peers) {\n\t\tfor (const anchorPeerProto of anchorPeersProto.anchor_peers) {\n\t\t\tconst anchor_peer = {\n\t\t\t\thost: anchorPeerProto.host,\n\t\t\t\tport: anchorPeerProto.port\n\t\t\t};\n\t\t\tvalue.anchor_peers.push(anchor_peer);\n\t\t}\n\t}\n\n\treturn value;\n}\n\nfunction decodeConfigValueMSP(valueBuf) {\n\tconst value = {};\n\tconst mspConfigProto = fabproto6.msp.MSPConfig.decode(valueBuf);\n\tvalue.type = mspConfigProto.type;\n\tif (mspConfigProto.type === 0) {\n\t\tvalue.config = decodeFabricMSPConfig(mspConfigProto.config);\n\t}\n\n\treturn value;\n}\n\nfunction decodeConfigValueConsensusType(valueBuf) {\n\tconst value = {};\n\tconst consensusTypeProto = fabproto6.orderer.ConsensusType.decode(valueBuf);\n\tvalue.type = consensusTypeProto.type; // string\n\n\treturn value;\n}\n\nfunction decodeConfigValueBatchSize(valueBuf) {\n\tconst value = {};\n\tconst batchSizeProto = fabproto6.orderer.BatchSize.decode(valueBuf);\n\tvalue.max_message_count = batchSizeProto.max_message_count; // uint32\n\tvalue.absolute_max_bytes = batchSizeProto.absolute_max_bytes; // uint32\n\tvalue.preferred_max_bytes = batchSizeProto.preferred_max_bytes; // uint32\n\n\treturn value;\n}\n\nfunction decodeConfigValueBatchTimeout(valueBuf) {\n\tconst value = {};\n\tconst batchTimeoutProto = fabproto6.orderer.BatchTimeout.decode(valueBuf);\n\tvalue.timeout = batchTimeoutProto.timeout; // string\n\n\treturn value;\n}\n\nfunction decodeConfigValueChannelRestrictions(valueBuf) {\n\tconst value = {};\n\tconst channelRestrictionsProto = fabproto6.orderer.ChannelRestrictions.decode(valueBuf);\n\tvalue.max_count = channelRestrictionsProto.max_count; // unit64\n\n\treturn value;\n}\n\nfunction decodeConfigValueBlockDataConsortium(valueBuf) {\n\tconst value = {};\n\tconst consortiumName = fabproto6.common.Consortium.decode(valueBuf);\n\tvalue.name = consortiumName.name; // string\n\n\treturn value;\n}\n\nfunction decodeConfigValueHashingAlgorithm(valueBuf) {\n\tconst value = {};\n\tconst hashingAlgorithmProto = fabproto6.common.HashingAlgorithm.decode(valueBuf);\n\tvalue.name = hashingAlgorithmProto.name; // string\n\n\treturn value;\n}\n\nfunction decodeConfigValueBlockDataHashingStructure(valueBuf) {\n\tconst value = {};\n\tconst blockdataHashingStructureProto = fabproto6.common.BlockDataHashingStructure.decode(valueBuf);\n\tvalue.width = blockdataHashingStructureProto.width; // int\n\n\treturn value;\n}\n\nfunction decodeConfigValueOrdererAddresses(valueBuf) {\n\tconst value = {};\n\tconst ordererAddressesProto = fabproto6.common.OrdererAddresses.decode(valueBuf);\n\tvalue.addresses = [];\n\tfor (const address of ordererAddressesProto.addresses) {\n\t\tvalue.addresses.push(address); // string\n\t}\n\n\treturn value;\n}\n\nfunction decodeConfigCapabilities(valueBuf) {\n\tconst value = {};\n\tconst capabilitiesProto = fabproto6.common.Capabilities.decode(valueBuf);\n\tvalue.capabilities = capabilitiesProto.capabilities;\n\n\treturn value;\n}\n\nfunction decodeConfigACLs(valueBuf) {\n\tconst value = {};\n\tconst aclsProto = fabproto6.protos.ACLs.decode(valueBuf);\n\tvalue.acls = aclsProto.acls;\n\n\treturn value;\n}\n\nfunction decodeConfigValue(configValueProto, valueName) {\n\tconst config_value = {};\n\tlogger.debug(' ======> Config item ::%s', valueName);\n\tconfig_value.mod_policy = configValueProto.mod_policy;\n\tconfig_value.version = convertVersion(configValueProto.version);\n\tswitch (valueName) {\n\t\tcase 'AnchorPeers':\n\t\t\tconfig_value.value = decodeConfigValueAnchorPeers(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'MSP':\n\t\t\tconfig_value.value = decodeConfigValueMSP(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'ConsensusType':\n\t\t\tconfig_value.value = decodeConfigValueConsensusType(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'BatchSize':\n\t\t\tconfig_value.value = decodeConfigValueBatchSize(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'BatchTimeout':\n\t\t\tconfig_value.value = decodeConfigValueBatchTimeout(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'ChannelRestrictions':\n\t\t\tconfig_value.value = decodeConfigValueChannelRestrictions(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'Consortium':\n\t\t\tconfig_value.value = decodeConfigValueBlockDataConsortium(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'HashingAlgorithm':\n\t\t\tconfig_value.value = decodeConfigValueHashingAlgorithm(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'BlockDataHashingStructure':\n\t\t\tconfig_value.value = decodeConfigValueBlockDataHashingStructure(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'OrdererAddresses':\n\t\t\tconfig_value.value = decodeConfigValueOrdererAddresses(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'Capabilities':\n\t\t\tconfig_value.value = decodeConfigCapabilities(configValueProto.value);\n\t\t\tbreak;\n\t\tcase 'ACLs':\n\t\t\tconfig_value.value = decodeConfigACLs(configValueProto.value);\n\t\t\tbreak;\n\t\tdefault:\n\t}\n\n\treturn config_value;\n}\n\nfunction decodeConfigPolicies(configPoliciesProto) {\n\tconst config_policies = {};\n\tconst keys = Object.keys(configPoliciesProto);\n\tfor (const policyName of keys) {\n\t\tconfig_policies[policyName] = decodeConfigPolicy(configPoliciesProto[policyName]);\n\t}\n\n\treturn config_policies;\n}\n\nfunction decodeConfigPolicy(configPolicyProto) {\n\tconst config_policy = {};\n\tconfig_policy.version = convertVersion(configPolicyProto.version);\n\tconfig_policy.mod_policy = configPolicyProto.mod_policy;\n\tconfig_policy.policy = {};\n\tif (configPolicyProto && configPolicyProto.policy) {\n\t\tconfig_policy.policy.type = configPolicyProto.policy.type;\n\t\tconfig_policy.policy.typeString = fabproto6.common.Policy.PolicyType[configPolicyProto.policy.type];\n\t\tlogger.debug('decodeConfigPolicy ======> Policy ::%s', config_policy.policy.typeString);\n\t\tswitch (configPolicyProto.policy.type) {\n\t\t\tcase fabproto6.common.Policy.PolicyType.SIGNATURE:\n\t\t\t\tconfig_policy.policy.value = decodeSignaturePolicyEnvelope(configPolicyProto.policy.value);\n\t\t\t\tbreak;\n\t\t\tcase fabproto6.common.Policy.PolicyType.MSP:\n\t\t\t\t// var proto_msp = fabproto6.common.Policy.decode(configPolicyProto.value.policy.value);\n\t\t\t\tlogger.warn('decodeConfigPolicy - found a PolicyType of MSP. This policy type has not been implemented yet.');\n\t\t\t\tbreak;\n\t\t\tcase fabproto6.common.Policy.PolicyType.IMPLICIT_META:\n\t\t\t\tconfig_policy.policy.value = decodeImplicitMetaPolicy(configPolicyProto.policy.value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown Policy type');\n\t\t}\n\t}\n\n\treturn config_policy;\n}\n\nfunction decodeImplicitMetaPolicy(implicitMetaPolicyBuf) {\n\tconst implicit_meta_policy = {};\n\tconst implicitMetaPolicyProto = fabproto6.common.ImplicitMetaPolicy.decode(implicitMetaPolicyBuf);\n\timplicit_meta_policy.sub_policy = implicitMetaPolicyProto.sub_policy;\n\timplicit_meta_policy.rule = implicitMetaPolicyProto.rule;\n\timplicit_meta_policy.ruleString = fabproto6.common.ImplicitMetaPolicy.Rule[implicitMetaPolicyProto.rule];\n\n\treturn implicit_meta_policy;\n}\n\nfunction decodeSignaturePolicyEnvelope(signaturePolicyEnvelopeBuf) {\n\tconst signature_policy_envelope = {};\n\tconst signaturePolicyEnvelopeProto = fabproto6.common.SignaturePolicyEnvelope.decode(signaturePolicyEnvelopeBuf);\n\tsignature_policy_envelope.version = convertVersion(signaturePolicyEnvelopeProto.version);\n\tsignature_policy_envelope.rule = decodeSignaturePolicy(signaturePolicyEnvelopeProto.rule);\n\tsignature_policy_envelope.identities = [];\n\tconst identitiesProto = signaturePolicyEnvelopeProto.identities;\n\tif (identitiesProto) {\n\t\tfor (const mSPPrincipalProto of identitiesProto) {\n\t\t\tconst msp_principal = decodeMSPPrincipal(mSPPrincipalProto);\n\t\t\tsignature_policy_envelope.identities.push(msp_principal);\n\t\t}\n\t}\n\n\treturn signature_policy_envelope;\n}\n\nfunction decodeSignaturePolicy(signaturePolicyProto) {\n\tconst signature_policy = {};\n\tif (signaturePolicyProto.n_out_of) {\n\t\tsignature_policy.n_out_of = {};\n\t\tsignature_policy.n_out_of.n = signaturePolicyProto.n_out_of.n;\n\t\tsignature_policy.n_out_of.rules = [];\n\t\tfor (const childSignaturePolicyProto of signaturePolicyProto.n_out_of.rules) {\n\t\t\tconst child_signature_policy = decodeSignaturePolicy(childSignaturePolicyProto);\n\t\t\tsignature_policy.n_out_of.rules.push(child_signature_policy);\n\t\t}\n\t} else {\n\t\tsignature_policy.signed_by = signaturePolicyProto.signed_by; // int32\n\t}\n\n\treturn signature_policy;\n}\n\nfunction decodeMSPPrincipal(mSPPrincipalProto) {\n\tlet msp_principal = {};\n\tmsp_principal.principal_classification = mSPPrincipalProto.principal_classification;\n\tlet principalProto;\n\tswitch (msp_principal.principal_classification) {\n\t\tcase fabproto6.common.MSPPrincipal.Classification.ROLE:\n\t\t\tprincipalProto = fabproto6.common.MSPRole.decode(mSPPrincipalProto.principal);\n\t\t\tmsp_principal.msp_identifier = principalProto.msp_identifier;\n\t\t\tmsp_principal.role = principalProto.role;\n\t\t\t// add a string for the role type\n\t\t\tmsp_principal.roleString = fabproto6.common.MSPRole.MSPRoleType[principalProto.role];\n\t\t\tbreak;\n\t\tcase fabproto6.common.MSPPrincipal.Classification.ORGANIZATION_UNIT:\n\t\t\tprincipalProto = fabproto6.common.OrganizationUnit.decode(mSPPrincipalProto.principal);\n\t\t\tmsp_principal.msp_identifier = principalProto.msp_identifier; // string\n\t\t\tmsp_principal.organizational_unit_identifier = principalProto.organizational_unit_identifier; // string\n\t\t\tmsp_principal.certifiers_identifier = principalProto.certifiers_identifier; // bytes\n\t\t\tbreak;\n\t\tcase fabproto6.common.MSPPrincipal.Classification.IDENTITY:\n\t\t\tmsp_principal = decodeIdentity(mSPPrincipalProto.principal);\n\t\t\tbreak;\n\t}\n\n\treturn msp_principal;\n}\n\nfunction decodeConfigSignature(configSignatureProto) {\n\tconst config_signature = {};\n\tconfig_signature.signature_header = decodeSignatureHeader(configSignatureProto.signature_header);\n\tconfig_signature.sigature = configSignatureProto.signature;\n\treturn config_signature;\n}\n\nfunction decodeSignatureHeader(signatureHeaderBuf) {\n\tconst signature_header = {};\n\tconst signatureHeaderProto = fabproto6.common.SignatureHeader.decode(signatureHeaderBuf);\n\tsignature_header.creator = decodeIdentity(signatureHeaderProto.creator);\n\tsignature_header.nonce = signatureHeaderProto.nonce;\n\n\treturn signature_header;\n}\n\nfunction decodeIdentity(identityBuf) {\n\tconst identity = {};\n\ttry {\n\t\tconst identityProto = fabproto6.msp.SerializedIdentity.decode(identityBuf);\n\t\tidentity.mspid = identityProto.mspid;\n\t\tidentity.id_bytes = identityProto.id_bytes;\n\t} catch (err) {\n\t\tlogger.error('Failed to decode the identity: %s', (err.stack ? err.stack : err));\n\t}\n\n\treturn identity;\n}\n\nfunction decodeFabricMSPConfig(fabricMSPConfigBuf) {\n\tconst config = {};\n\tconst mspConfigProto = fabproto6.msp.FabricMSPConfig.decode(fabricMSPConfigBuf);\n\n\tconfig.name = mspConfigProto.name;\n\tconfig.root_certs = toPEMcerts(mspConfigProto.root_certs);\n\tconfig.intermediate_certs = toPEMcerts(mspConfigProto.intermediate_certs);\n\tconfig.admins = toPEMcerts(mspConfigProto.admins);\n\tconfig.revocation_list = toPEMcerts(mspConfigProto.revocation_list);\n\tconfig.signing_identity = decodeSigningIdentityInfo(mspConfigProto.signing_identity);\n\tconfig.organizational_unit_identifiers = decodeFabricOUIdentifier(mspConfigProto.organizational_unit_identifiers);\n\tconfig.tls_root_certs = toPEMcerts(mspConfigProto.tls_root_certs);\n\tconfig.tls_intermediate_certs = toPEMcerts(mspConfigProto.tls_intermediate_certs);\n\n\treturn config;\n}\n\nfunction decodeFabricOUIdentifier(organizationalUnitIdentitfiersProto) {\n\tconst organizational_unit_identitfiers = [];\n\tif (organizationalUnitIdentitfiersProto) {\n\t\tfor (let i = 0; i < organizationalUnitIdentitfiersProto.length; i++) {\n\t\t\tconst organizationalUnitIdentitfierProto = organizationalUnitIdentitfiersProto[i];\n\t\t\tconst organizational_unit_identitfier = {};\n\t\t\torganizational_unit_identitfier.certificate =\n\t\t\t\torganizationalUnitIdentitfierProto.certificate;\n\t\t\torganizational_unit_identitfier.organizational_unit_identifier =\n\t\t\t\torganizationalUnitIdentitfierProto.organizational_unit_identifier;\n\n\t\t\torganizational_unit_identitfiers.push(organizational_unit_identitfier);\n\t\t}\n\t}\n\n\treturn organizational_unit_identitfiers;\n}\n\nfunction toPEMcerts(buffer_array_in) {\n\tconst buffer_array_out = [];\n\tfor (const i in buffer_array_in) {\n\t\tbuffer_array_out.push(buffer_array_in[i]);\n\t}\n\n\treturn buffer_array_out;\n}\n\nfunction decodeSigningIdentityInfo(signingIdentityInfoBuf) {\n\tconst signing_identity_info = {};\n\tif (signingIdentityInfoBuf) {\n\t\tconst signingIdentityInfoProto = fabproto6.msp.SigningIdentityInfo.decode(signingIdentityInfoBuf);\n\t\tsigning_identity_info.public_signer = signingIdentityInfoProto.public_signer;\n\t\tsigning_identity_info.private_signer = decodeKeyInfo(signingIdentityInfoProto.private_signer);\n\t}\n\n\treturn signing_identity_info;\n}\n\nfunction decodeKeyInfo(keyInfoBuf) {\n\tconst key_info = {};\n\tif (keyInfoBuf) {\n\t\tconst keyInfoProto = fabproto6.msp.KeyInfo.decode(keyInfoBuf);\n\t\tkey_info.key_identifier = keyInfoProto.key_identifier;\n\t\tkey_info.key_material = 'private'; // should not show this\n\t}\n\n\treturn key_info;\n}\n\nfunction decodeHeader(headerProto) {\n\tconst header = {};\n\theader.channel_header = decodeChannelHeader(headerProto.channel_header);\n\theader.signature_header = decodeSignatureHeader(headerProto.signature_header);\n\n\treturn header;\n}\n\nfunction decodeChannelHeader(channelHeaderBuf) {\n\tconst channel_header = {};\n\tconst channelHeaderProto = fabproto6.common.ChannelHeader.decode(channelHeaderBuf);\n\tchannel_header.type = channelHeaderProto.type;\n\tlogger.debug('decodeChannelHeader - looking at type:%s', channel_header.type);\n\tchannel_header.version = convertVersion(channelHeaderProto.version);\n\tchannel_header.timestamp = timeStampToDate(channelHeaderProto.timestamp);\n\tchannel_header.channel_id = channelHeaderProto.channel_id;\n\tchannel_header.tx_id = channelHeaderProto.tx_id;\n\tchannel_header.epoch = channelHeaderProto.epoch; // unit64\n\t// TODO need to decode this\n\tchannel_header.extension = channelHeaderProto.extension;\n\n\treturn channel_header;\n}\n\nfunction decodeChaincodeActionPayload(chaincodeActionPayloadBuf) {\n\tconst payload = {};\n\tconst chaincodeActionPayloadProto = fabproto6.protos.ChaincodeActionPayload.decode(chaincodeActionPayloadBuf);\n\tpayload.chaincode_proposal_payload = decodeChaincodeProposalPayload(chaincodeActionPayloadProto.chaincode_proposal_payload);\n\tpayload.action = decodeChaincodeEndorsedAction(chaincodeActionPayloadProto.action);\n\n\treturn payload;\n}\n\nfunction decodeChaincodeProposalPayload(chaincodeProposalPayloadBuf) {\n\tconst chaincode_proposal_payload = {};\n\tconst chaincodeProposalPayloadProto = fabproto6.protos.ChaincodeProposalPayload.decode(chaincodeProposalPayloadBuf);\n\tchaincode_proposal_payload.input = decodeChaincodeProposalPayloadInput(chaincodeProposalPayloadProto.input);\n\t// TransientMap is not allowed to be included on ledger\n\n\treturn chaincode_proposal_payload;\n}\n\nfunction decodeChaincodeProposalPayloadInput(chaincodePoposalPayloadInputBuf) {\n\tconst chaincode_proposal_payload_input = {};\n\n\t// For a normal transaction, input is ChaincodeInvocationSpec.\n\tconst chaincodeInvocationSpecProto = fabproto6.protos.ChaincodeInvocationSpec.decode(chaincodePoposalPayloadInputBuf);\n\tchaincode_proposal_payload_input.chaincode_spec = decodeChaincodeSpec(chaincodeInvocationSpecProto.chaincode_spec);\n\n\treturn chaincode_proposal_payload_input;\n}\n\nfunction decodeChaincodeSpec(chaincodeSpecProto) {\n\tconst chaincode_spec = {};\n\tchaincode_spec.type = chaincodeSpecProto.type;\n\t// Add a string for the chaincode type (GOLANG, NODE, etc.)\n\tchaincode_spec.typeString = fabproto6.protos.ChaincodeSpec.Type[chaincode_spec.type];\n\tchaincode_spec.input = decodeChaincodeInput(chaincodeSpecProto.input);\n\tchaincode_spec.chaincode_id = chaincodeSpecProto.chaincode_id;\n\tchaincode_spec.timeout = chaincodeSpecProto.timeout;\n\n\treturn chaincode_spec;\n}\n\nfunction decodeChaincodeInput(chaincodeInputProto) {\n\tconst chaincode_input = {};\n\n\tchaincode_input.args = [];\n\tfor (const arg of chaincodeInputProto.args) {\n\t\tchaincode_input.args.push(arg);\n\t}\n\tconst keys = Object.keys(chaincodeInputProto.decorations);\n\tchaincode_input.decorations = {};\n\tfor (const key of keys) {\n\t\tchaincode_input.decorations[key] = chaincodeInputProto.decorations[key];\n\t}\n\tchaincode_input.is_init = chaincodeInputProto.is_init;\n\n\treturn chaincode_input;\n}\n\nfunction decodeChaincodeEndorsedAction(chaincodeEndorsedActionProto) {\n\tconst chaincode_endorsed_action = {};\n\tchaincode_endorsed_action.proposal_response_payload = decodeProposalResponsePayload(chaincodeEndorsedActionProto.proposal_response_payload);\n\tchaincode_endorsed_action.endorsements = [];\n\tfor (const endorsementProto of chaincodeEndorsedActionProto.endorsements) {\n\t\tconst endorsement = decodeEndorsement(endorsementProto);\n\t\tchaincode_endorsed_action.endorsements.push(endorsement);\n\t}\n\n\treturn chaincode_endorsed_action;\n}\n\nfunction decodeEndorsement(endorsementProto) {\n\tconst endorsement = {};\n\tendorsement.endorser = decodeIdentity(endorsementProto.endorser);\n\tendorsement.signature = endorsementProto.signature;\n\n\treturn endorsement;\n}\n\nfunction decodeProposalResponsePayload(proposalResponsePayloadBuf) {\n\tconst proposal_response_payload = {};\n\tconst proposalResponsePayloadProto = fabproto6.protos.ProposalResponsePayload.decode(proposalResponsePayloadBuf);\n\tproposal_response_payload.proposal_hash = proposalResponsePayloadProto.proposal_hash;\n\tproposal_response_payload.extension = decodeChaincodeAction(proposalResponsePayloadProto.extension);\n\n\treturn proposal_response_payload;\n}\n\nfunction decodeChaincodeAction(chaincodeActionBuf) {\n\tlogger.debug('decodeChaincodeAction - start');\n\tconst chaincode_action = {};\n\tconst chaincodeActionProto = fabproto6.protos.ChaincodeAction.decode(chaincodeActionBuf);\n\tchaincode_action.results = decodeReadWriteSets(chaincodeActionProto.results);\n\t// it may be called events, however it is only one event at this time\n\tchaincode_action.events = decodeChaincodeEvent(chaincodeActionProto.events);\n\tchaincode_action.response = decodeResponse(chaincodeActionProto.response);\n\tchaincode_action.chaincode_id = decodeChaincodeID(chaincodeActionProto.chaincode_id);\n\n\treturn chaincode_action;\n}\n\nfunction decodeChaincodeEvent(chaincodeEventBuf) {\n\tconst event = {};\n\tconst chaincodeEventProto = fabproto6.protos.ChaincodeEvent.decode(chaincodeEventBuf);\n\tevent.chaincode_id = chaincodeEventProto.chaincode_id;\n\tevent.tx_id = chaincodeEventProto.tx_id;\n\tevent.event_name = chaincodeEventProto.event_name;\n\tevent.payload = chaincodeEventProto.payload;\n\n\treturn event;\n}\n\nfunction decodeResponse(responseProto) {\n\tif (responseProto) {\n\t\tconst response = {};\n\t\tresponse.status = responseProto.status;\n\t\tresponse.message = responseProto.message;\n\t\tresponse.payload = responseProto.payload;\n\n\t\treturn response;\n\t}\n\treturn undefined;\n}\n\nfunction decodeChaincodeID(chaincodeIDProto) {\n\tconst chaincode_id = {};\n\tif (!chaincodeIDProto) {\n\t\tlogger.debug('decodeChaincodeID - no chaincodeIDProto found');\n\t\treturn chaincode_id;\n\t}\n\tlogger.debug('decodeChaincodeID - start');\n\tchaincode_id.path = chaincodeIDProto.path;\n\tchaincode_id.name = chaincodeIDProto.name;\n\tchaincode_id.version = chaincodeIDProto.version;\n\n\treturn chaincode_id;\n}\n\nfunction decodeReadWriteSets(rwsetBuf) {\n\tconst txReadWriteSetProto = fabproto6.rwset.TxReadWriteSet.decode(rwsetBuf);\n\tconst tx_read_write_set = {};\n\ttx_read_write_set.data_model = txReadWriteSetProto.data_model;\n\tif (txReadWriteSetProto.data_model === fabproto6.rwset.TxReadWriteSet.DataModel.KV) {\n\t\ttx_read_write_set.ns_rwset = [];\n\t\tfor (const nsReadWriteSet of txReadWriteSetProto.ns_rwset) {\n\t\t\tconst kv_rw_set = {};\n\t\t\tkv_rw_set.namespace = nsReadWriteSet.namespace;\n\t\t\tkv_rw_set.rwset = decodeKVRWSet(nsReadWriteSet.rwset);\n\t\t\tkv_rw_set.collection_hashed_rwset = decodeCollectionHashedRWSet(nsReadWriteSet.collection_hashed_rwset);\n\t\t\ttx_read_write_set.ns_rwset.push(kv_rw_set);\n\t\t}\n\t} else {\n\t\t// not able to decode this type of rw set, return as is\n\t\ttx_read_write_set.ns_rwset = txReadWriteSetProto.ns_rwset;\n\t}\n\n\treturn tx_read_write_set;\n}\n\nfunction decodeKVRWSet(kvBuf) {\n\tconst kVRWSetProto = fabproto6.kvrwset.KVRWSet.decode(kvBuf);\n\tconst kv_rw_set = {};\n\n\t// build reads\n\tkv_rw_set.reads = [];\n\tfor (const kvReadProto of kVRWSetProto.reads) {\n\t\tkv_rw_set.reads.push(decodeKVRead(kvReadProto));\n\t}\n\n\t// build range_queries_info\n\tkv_rw_set.range_queries_info = [];\n\tfor (const rangeQueryInfoProto of kVRWSetProto.range_queries_info) {\n\t\tkv_rw_set.range_queries_info.push(decodeRangeQueryInfo(rangeQueryInfoProto));\n\t}\n\n\t// build writes\n\tkv_rw_set.writes = [];\n\tfor (const kVWriteProto of kVRWSetProto.writes) {\n\t\tkv_rw_set.writes.push(decodeKVWrite(kVWriteProto));\n\t}\n\n\t// build metadata writes\n\tkv_rw_set.metadata_writes = [];\n\tfor (const kVMetadataWriteProto of kVRWSetProto.metadata_writes) {\n\t\tkv_rw_set.metadata_writes.push(decodeKVMetadataWrite(kVMetadataWriteProto));\n\t}\n\n\treturn kv_rw_set;\n}\n\nfunction decodeVersion(versionProto) {\n\tif (versionProto) {\n\t\tconst version = {};\n\t\tversion.block_num = versionProto.block_num;\n\t\tversion.tx_num = versionProto.tx_num;\n\t\treturn version;\n\t}\n\n\treturn;\n}\n\nfunction decodeKVRead(kVReadProto) {\n\tconst kv_read = {};\n\tkv_read.key = kVReadProto.key;\n\tkv_read.version = decodeVersion(kVReadProto.version);\n\n\treturn kv_read;\n}\n\nfunction decodeRangeQueryInfo(rangeQueryInfoProto) {\n\tconst range_query_info = {};\n\trange_query_info.start_key = rangeQueryInfoProto.start_key;\n\trange_query_info.end_key = rangeQueryInfoProto.end_key;\n\trange_query_info.itr_exhausted = rangeQueryInfoProto.itr_exhausted;\n\n\t// reads_info is one of QueryReads or QueryReadsMerkleSummary\n\tif (rangeQueryInfoProto.raw_reads) {\n\t\trange_query_info.raw_reads = {};\n\t\trange_query_info.raw_reads.kv_reads = [];\n\t\tfor (const kVReadProto of rangeQueryInfoProto.raw_reads.kv_reads) {\n\t\t\trange_query_info.raw_reads.kv_reads.push(decodeKVRead(kVReadProto));\n\t\t}\n\t} else if (rangeQueryInfoProto.reads_merkle_hashes) {\n\t\trange_query_info.reads_merkle_hashes = {};\n\t\trange_query_info.reads_merkle_hashes.max_degree = rangeQueryInfoProto.reads_merkle_hashes.max_degree;\n\t\trange_query_info.reads_merkle_hashes.max_level = rangeQueryInfoProto.reads_merkle_hashes.max_level;\n\t\trange_query_info.reads_merkle_hashes.max_level_hashes = rangeQueryInfoProto.reads_merkle_hashes.max_level_hashes;\n\t}\n\n\treturn range_query_info;\n}\n\nfunction decodeKVWrite(kVWriteProto) {\n\tconst kv_write = {};\n\tkv_write.key = kVWriteProto.key;\n\tkv_write.is_delete = kVWriteProto.is_delete;\n\tkv_write.value = kVWriteProto.value;\n\n\treturn kv_write;\n}\n\nfunction decodeKVMetadataWrite(kVMetadataWriteProto) {\n\tconst kv_metadata_write = {};\n\tkv_metadata_write.key = kVMetadataWriteProto.key;\n\tkv_metadata_write.entries = [];\n\tfor (const kVMetadataEntryProto of kVMetadataWriteProto.entries) {\n\t\tkv_metadata_write.entries.push(decodeKVMetadataEntry(kVMetadataEntryProto));\n\t}\n\n\treturn kv_metadata_write;\n}\n\nfunction decodeKVMetadataEntry(kVMetadataEntryProto) {\n\tconst kv_metadata_entry = {};\n\tkv_metadata_entry.name = kVMetadataEntryProto.name;\n\tkv_metadata_entry.value = kVMetadataEntryProto.value;\n\n\treturn kv_metadata_entry;\n}\n\n// This decodes an array of CollectionHashedReadWriteSet\nfunction decodeCollectionHashedRWSet(collectionHashedRwsetArray) {\n\tconst collection_hashed_rwset = [];\n\tfor (const collectionHashedRwset of collectionHashedRwsetArray) {\n\t\tconst collection = {};\n\t\tcollection.collection_name = collectionHashedRwset.collection_name;\n\t\tcollection.hashed_rwset = decodeHashedRwset(collectionHashedRwset.hashed_rwset);\n\t\tcollection.pvt_rwset_hash = collectionHashedRwset.pvt_rwset_hash;\n\t\tcollection_hashed_rwset.push(collection);\n\t}\n\n\treturn collection_hashed_rwset;\n}\n\nfunction decodeHashedRwset(hashedRWSetBuf) {\n\tconst hashedRWSetProto = fabproto6.kvrwset.HashedRWSet.decode(hashedRWSetBuf);\n\tconst hashed_rwset = {};\n\thashed_rwset.hashed_reads = [];\n\tfor (const kVReadHashProto of hashedRWSetProto.hashed_reads) {\n\t\thashed_rwset.hashed_reads.push(decodeKVReadHash(kVReadHashProto));\n\t}\n\thashed_rwset.hashed_writes = [];\n\tfor (const kVWriteHashProto of hashedRWSetProto.hashed_writes) {\n\t\thashed_rwset.hashed_writes.push(decodeKVWriteHash(kVWriteHashProto));\n\t}\n\thashed_rwset.metadata_writes = [];\n\tfor (const kVMetadataWriteHashProto of hashedRWSetProto.metadata_writes) {\n\t\thashed_rwset.metadata_writes.push(decodeKVMetadataWriteHash(kVMetadataWriteHashProto));\n\t}\n\n\treturn hashed_rwset;\n}\n\nfunction decodeKVReadHash(kVReadHashProto) {\n\tconst kv_read_hash = {};\n\tkv_read_hash.key_hash = kVReadHashProto.key_hash;\n\tkv_read_hash.version = decodeVersion(kVReadHashProto.version);\n\n\treturn kv_read_hash;\n}\n\nfunction decodeKVWriteHash(kVWriteHashProto) {\n\tconst kv_write_hash = {};\n\tkv_write_hash.key_hash = kVWriteHashProto.key_hash;\n\tkv_write_hash.is_delete = kVWriteHashProto.is_delete;\n\tkv_write_hash.value_hash = kVWriteHashProto.value_hash;\n\n\treturn kv_write_hash;\n}\n\nfunction decodeKVMetadataWriteHash(kVMetadataWriteHashProto) {\n\tconst kv_metadata_write_hash = {};\n\tkv_metadata_write_hash.key_hash = kVMetadataWriteHashProto.key_hash;\n\tkv_metadata_write_hash.entries = [];\n\tfor (const kVMetadataEntryProto of kVMetadataWriteHashProto.entries) {\n\t\tkv_metadata_write_hash.entries.push(decodeKVMetadataEntry(kVMetadataEntryProto));\n\t}\n\n\treturn kv_metadata_write_hash;\n}\n\n// version numbers should not get that big\n// so lets just return an Integer (32bits)\nfunction convertVersion(versionLong) {\n\tconst versionString = versionLong.toString();\n\tconst version = Number.parseInt(versionString);\n\n\treturn version;\n}\n\nfunction timeStampToDate(timestamp) {\n\tif (!timestamp) {\n\t\treturn 'null';\n\t}\n\tconst millis = timestamp.seconds * 1000 + timestamp.nanos / 1000000;\n\tconst date = new Date(millis);\n\n\treturn date.toISOString();\n}\n\nmodule.exports = BlockDecoder;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC1C,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAEhC,MAAME,MAAM,GAAGD,KAAK,CAACE,SAAS,CAAC,iBAAiB,CAAC;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,CAAC;EAClB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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"},"metadata":{},"sourceType":"script","externalDependencies":[]}