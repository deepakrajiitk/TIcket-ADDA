{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n'use strict';\n\nconst Long = require('long');\nconst util = require('util');\nconst winston = require('winston');\nconst crypto = require('crypto');\nconst path = require('path');\nconst os = require('os');\nconst Config = require('./Config');\nconst InMemoryKeyValueStore = require('./impl/InMemoryKeyValueStore');\nconst CryptoKeyStore = require('./impl/CryptoKeyStore');\nconst sjcl = require('sjcl');\nconst yn = require('yn');\nconst fabricCommonConfigProperty = 'fabric-common-config';\n//\n// The following methods are for loading the proper implementation of an extensible APIs.\n//\n\nfunction isOldPropertyValue(value) {\n  return typeof value === 'string' && value.startsWith('fabric-client/');\n}\nfunction isOldCryptoSuiteImpl(csImpl) {\n  for (const key of Object.getOwnPropertyNames(csImpl)) {\n    if (isOldPropertyValue(csImpl[key])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getSoftwareCryptoSuiteImpl() {\n  let result = exports.getConfigSetting('crypto-suite-software');\n  if (!result || isOldCryptoSuiteImpl(result)) {\n    result = {\n      EC: 'fabric-common/lib/impl/CryptoSuite_ECDSA_AES'\n    };\n  }\n  return result;\n}\nfunction getHsmCryptoSuiteImpl() {\n  let result = exports.getConfigSetting('crypto-suite-hsm');\n  if (!result || isOldCryptoSuiteImpl(result)) {\n    result = {\n      EC: 'fabric-common/lib/impl/bccsp_pkcs11'\n    };\n  }\n  return result;\n}\n\n/**\n * @typedef {Object} CryptoSetting\n * @property {boolean} software - Whether to load a software-based implementation (true) or HSM implementation (false)\n * @property {number} keysize - The key size to use for the crypto suite instance.\n * @property {string} algorithm - Digital signature algorithm\n * @property {string} hash 'SHA2' or 'SHA3'\n */\n\n/**\n * Returns a new instance of the CryptoSuite API implementation. Supports the following:\n * - newCryptoSuite({software: true, keysize: 256, algorithm: EC})\n * - newCryptoSuite({software: false, lib: '/usr/local/bin/pkcs11.so', slot: 0, pin: '1234'})\n * - newCryptoSuite({software: false, lib: '/usr/local/bin/pkcs11.so', label: 'ForFabric', pin: '1234'})\n * - newCryptoSuite({keysize: 384})\n * - newCryptoSuite()\n * @param {CryptoSetting} [setting]\n *  - property `software` default is true (for software based implementation),\n *          specific implementation module is specified in the setting 'crypto-suite-software'\n *  - property `algorithm` currently supporting ECDSA only with value \"EC\"\n *  - property `keysize` default is value of the setting 'crypto-keysize'\n */\nmodule.exports.newCryptoSuite = setting => {\n  let csImpl,\n    keysize,\n    algorithm,\n    hashAlgo,\n    opts = null;\n  let useHSM = false;\n  if (setting && typeof setting.software === 'boolean') {\n    useHSM = !setting.software;\n  } else {\n    useHSM = yn(exports.getConfigSetting('crypto-hsm'));\n  }\n  csImpl = useHSM ? getHsmCryptoSuiteImpl() : getSoftwareCryptoSuiteImpl();\n\n  // step 1: what's the cryptosuite impl to use, key size and algo\n  if (setting && setting.keysize && typeof setting === 'object' && typeof setting.keysize === 'number') {\n    keysize = setting.keysize;\n  } else {\n    keysize = exports.getConfigSetting('crypto-keysize');\n  }\n  if (setting && setting.algorithm && typeof setting === 'object' && typeof setting.algorithm === 'string') {\n    algorithm = setting.algorithm.toUpperCase();\n  } else {\n    algorithm = 'EC';\n  }\n  if (setting && setting.hash && typeof setting === 'object' && typeof setting.hash === 'string') {\n    hashAlgo = setting.hash.toUpperCase();\n  } else {\n    hashAlgo = null;\n  }\n\n  // csImpl at this point should be a map (see config/default.json) with keys being the algorithm\n  csImpl = csImpl[algorithm];\n  if (!csImpl) {\n    throw new Error(util.format('Desired CryptoSuite module not found supporting algorithm \"%s\"', algorithm));\n  }\n  const cryptoSuite = require(csImpl);\n\n  // the 'opts' argument to be passed or none at all\n  opts = typeof setting === 'undefined' ? null : setting;\n\n  // opts Option is the form { lib: string, slot: number, pin: string }\n  return new cryptoSuite(keysize, hashAlgo, opts);\n};\n\n// Provide an in-memory keyValueStore\nmodule.exports.newKeyValueStore = () => {\n  return new InMemoryKeyValueStore();\n};\n\n//\n// Internal API.\n// Notice this API is only used at the SDK scope. For the client application, do not use\n// this api.\n//\n// Get the standard logger to use throughout the SDK code. If the client application has\n// configured a logger, then that'll be returned.\n//\n// The user can also make use of the built-in \"winston\" based logger and use the environment\n// variable HFC_LOGGING to pass in configurations in the following format:\n//\n// {\n//   'error': 'error.log',\t\t\t\t// 'error' logs are printed to file 'error.log' relative of the current working dir for node.js\n//   'debug': '/tmp/myapp/debug.log',\t// 'debug' and anything more critical ('info', 'warn', 'error') can also be an absolute path\n//   'info': 'console'\t\t\t\t\t// 'console' is a keyword for logging to console\n// }\n//\n\nconst LOGGING_LEVELS = ['debug', 'info', 'warn', 'error'];\nmodule.exports.getLogger = function (name) {\n  let logger;\n  const saveLogger = function (loggerToSave) {\n    if (global.hfc) {\n      global.hfc.logger = loggerToSave;\n    } else {\n      global.hfc = {\n        logger: loggerToSave\n      };\n    }\n  };\n  const newDefaultLogger = () => {\n    return new winston.Logger({\n      transports: [new winston.transports.Console({\n        colorize: true,\n        timestamp: true\n      })]\n    });\n  };\n  const insertLoggerName = (originalLogger, lname) => {\n    logger = Object.assign({}, originalLogger);\n    LOGGING_LEVELS.forEach(method => {\n      const func = originalLogger[method];\n      logger[method] = function (context, loggerName, f) {\n        return function () {\n          if (arguments.length > 0) {\n            arguments[0] = '[' + loggerName + ']: ' + arguments[0];\n          }\n          f.apply(context, arguments);\n        };\n      }(originalLogger, lname, func);\n    });\n    return logger;\n  };\n  if (global.hfc && global.hfc.logger) {\n    return insertLoggerName(global.hfc.logger, name);\n  }\n\n  // see if the config has it set\n  const config_log_setting = exports.getConfigSetting('hfc-logging', undefined); // environment setting will be HFC_LOGGING\n\n  const options = {};\n  if (config_log_setting) {\n    try {\n      const config = typeof config_log_setting === 'string' ? JSON.parse(config_log_setting) : config_log_setting;\n      if (typeof config !== 'object') {\n        throw new Error('Environment variable \"HFC_LOGGING\" must be an object conforming to the format documented.');\n      }\n      for (const level in config) {\n        if (!config[level]) {\n          continue;\n        }\n        if (LOGGING_LEVELS.includes(level)) {\n          if (!options.transports) {\n            options.transports = [];\n          }\n          if (config[level] === 'console') {\n            options.transports.push(new winston.transports.Console({\n              name: level + 'console',\n              level: level,\n              timestamp: true,\n              colorize: true\n            }));\n          } else {\n            options.transports.push(new winston.transports.File({\n              name: level + 'file',\n              level: level,\n              filename: config[level],\n              timestamp: true,\n              colorize: false,\n              json: false\n            }));\n          }\n        }\n      }\n      logger = new winston.Logger(options);\n      logger.debug('Successfully constructed a winston logger with configurations', config);\n      saveLogger(logger);\n      return insertLoggerName(logger, name);\n    } catch (err) {\n      // the user's configuration from environment variable failed to parse.\n      // construct the default logger, log a warning and return it\n      logger = newDefaultLogger();\n      saveLogger(logger);\n      logger.log('warn', 'Failed to parse environment variable \"HFC_LOGGING\". Returned a winston logger with default configurations. Error: %s', err.stack ? err.stack : err);\n      return insertLoggerName(logger, name);\n    }\n  }\n  logger = newDefaultLogger();\n  saveLogger(logger);\n  logger.debug('Returning a new winston logger with default configurations');\n  return insertLoggerName(logger, name);\n};\n\n/**\n * Configures a logger for the entire SDK to use and override the default logger. Unless this method is called,\n * the SDK uses a default logger based on [winston]{@link https://www.npmjs.com/package/winston}.\n * When using the built-in winston based logger, use the configuration setting <code>hfc-logging</code> to pass\n * in configurations in the following format:\n * <br><br>\n * <pre>\n * {\n *   'error': 'error.log',\t\t\t// 'error' logs are printed to file 'error.log' relative of the current working dir for node.js\n *   'debug': '/tmp/myapp/debug.log',\t// 'debug' and anything more critical ('info', 'warn', 'error') can also be an absolute path\n *   'info': 'console'\t\t\t// 'console' is a keyword for logging to console\n * }\n * </pre>\n * <br>\n * @param {Object} logger a logger instance that defines the following methods: debug(), info(), warn(), error() with\n * string interpolation methods like [util.format]{@link https://nodejs.org/api/util.html#util_util_format_format}.\n */\nmodule.exports.setLogger = logger => {\n  let err = '';\n  if (typeof logger.debug !== 'function') {\n    err += 'debug() ';\n  }\n  if (typeof logger.info !== 'function') {\n    err += 'info() ';\n  }\n  if (typeof logger.warn !== 'function') {\n    err += 'warn() ';\n  }\n  if (typeof logger.error !== 'function') {\n    err += 'error()';\n  }\n  if (err !== '') {\n    throw new Error('The \"logger\" parameter must be an object that implements the following methods, which are missing: ' + err);\n  }\n  if (global.hfc) {\n    global.hfc.logger = logger;\n  } else {\n    global.hfc = {\n      logger: logger\n    };\n  }\n};\n\n//\n// Internal method to add additional configuration file to override default file configuration settings\n//\nmodule.exports.addConfigFile = filePath => {\n  const config = exports.getConfig();\n  config.file(filePath);\n};\n\n//\n// Internal method to set an override setting to the configuration settings\n//\nmodule.exports.setConfigSetting = (name, value) => {\n  const config = exports.getConfig();\n  config.set(name, value);\n};\n\n//\n// Internal method to get an override setting to the configuration settings\n//\nexports.getConfigSetting = (name, default_value) => {\n  const config = exports.getConfig();\n  return config.get(name, default_value);\n};\nfunction ensureFabricCommonConfigLoaded(config) {\n  if (!config.get(fabricCommonConfigProperty)) {\n    const default_config = path.resolve(__dirname, '../config/default.json');\n    config.reorderFileStores(default_config);\n    config.set(fabricCommonConfigProperty, true);\n  }\n}\n\n//\n// Internal method to get the configuration settings singleton\n//\nexports.getConfig = () => {\n  if (!global.hfc) {\n    global.hfc = {};\n  }\n  if (!global.hfc.config) {\n    global.hfc.config = new Config();\n  }\n  ensureFabricCommonConfigLoaded(global.hfc.config);\n  return global.hfc.config;\n};\n\n//\n// Other miscellaneous methods\n//\n\n/**\n * Convert from a bitArray to bytes (refer to SJCL's codec)\n * @param {number[]} arr a bitArray to convert from\n * @returns the bytes converted from the bitArray\n */\nmodule.exports.bitsToBytes = arr => {\n  const out = [];\n  const bl = sjcl.bitArray.bitLength(arr);\n  let tmp;\n  for (let i = 0; i < bl / 8; i++) {\n    if ((i & 3) === 0) {\n      tmp = arr[i / 4];\n    }\n    out.push(tmp >>> 24);\n    tmp <<= 8;\n  }\n  return out;\n};\n\n/**\n * Convert from bytes to a bitArray (refer to SJCL's codec)\n * @param {number[]} bytes a bytes to convert from\n * @returns the bitArray converted from bytes\n */\nmodule.exports.bytesToBits = bytes => {\n  const out = [];\n  let i;\n  let tmp = 0;\n  for (i = 0; i < bytes.length; i++) {\n    tmp = tmp << 8 | bytes[i];\n    if ((i & 3) === 3) {\n      out.push(tmp);\n      tmp = 0;\n    }\n  }\n  if (i & 3) {\n    out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n  }\n  return out;\n};\nmodule.exports.zeroBuffer = length => {\n  return Buffer.alloc(length);\n};\n\n// utility function to convert Node buffers to Javascript arraybuffer\nmodule.exports.toArrayBuffer = buffer => {\n  const ab = new ArrayBuffer(buffer.length);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buffer.length; ++i) {\n    view[i] = buffer[i];\n  }\n  return ab;\n};\n\n// utility function to create a random number of\n// the specified length.\nmodule.exports.getNonce = length => {\n  if (length) {\n    if (Number.isInteger(length)) {\n      // good, it is a number\n    } else {\n      throw new Error('Parameter must be an integer');\n    }\n  } else {\n    length = exports.getConfigSetting('nonce-size', 24);\n  }\n  const value = crypto.randomBytes(length);\n  return value;\n};\nmodule.exports.getClassMethods = clazz => {\n  const i = new clazz();\n  const proto = Object.getPrototypeOf(i);\n  return Object.getOwnPropertyNames(proto).filter(e => {\n    if (e !== 'constructor' && typeof i[e] === 'function') {\n      return true;\n    }\n  });\n};\nmodule.exports.getBufferBit = (buf, idx) => {\n  // return error=true if bit to mask exceeds buffer length\n  if (parseInt(idx / 8) + 1 > buf.length) {\n    return {\n      error: true,\n      invalid: 0\n    };\n  }\n  if ((buf[parseInt(idx / 8)] & 1 << idx % 8) !== 0) {\n    return {\n      error: false,\n      invalid: 1\n    };\n  } else {\n    return {\n      error: false,\n      invalid: 0\n    };\n  }\n};\nmodule.exports.getDefaultKeyStorePath = () => {\n  return path.join(os.homedir(), '.hfc-key-store');\n};\n\n/**\n *\n * @param {KeyValueStore} [keyValueStore] Optional. The built-in key store saves private keys.\n *    The key store must be instance of any {@link KeyValueStore} implementations.\n * @return {CryptoKeyStore}\n */\nmodule.exports.newCryptoKeyStore = function () {\n  let keyValueStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new InMemoryKeyValueStore();\n  return new CryptoKeyStore(keyValueStore);\n};\n\n/*\n * This function will create a new key value pair type options list based\n * on the one passed in. The option setting will be added to the options if it\n * does not exist in the options already. The value of the setting being checked\n * will be the default value passed in unless there is a value in the config\n * settings or already on the options list.\n */\nmodule.exports.checkAndAddConfigSetting = (option_name, default_value, options) => {\n  const return_options = {};\n  return_options[option_name] = module.exports.getConfigSetting(option_name, default_value);\n  if (options) {\n    const keys = Object.keys(options);\n    for (const i in keys) {\n      const key = keys[i];\n      const value = options[key];\n      return_options[key] = value;\n    }\n  }\n  return return_options;\n};\n\n/*\n * Make sure there's a start line with '-----BEGIN CERTIFICATE-----'\n * and end line with '-----END CERTIFICATE-----', so as to be compliant\n * with x509 parsers\n */\nmodule.exports.normalizeX509 = raw => {\n  const regex = /(-----\\s*BEGIN ?[^-]+?-----)([\\s\\S]*)(-----\\s*END ?[^-]+?-----)/;\n  let matches = raw.match(regex);\n  if (!matches || matches.length !== 4) {\n    throw new Error('Failed to find start line or end line of the certificate.');\n  }\n\n  // remove the first element that is the whole match\n  matches.shift();\n  // remove LF or CR\n  matches = matches.map(element => {\n    return element.trim();\n  });\n\n  // make sure '-----BEGIN CERTIFICATE-----' and '-----END CERTIFICATE-----' are in their own lines\n  // and that it ends in a new line\n  let result = matches.join('\\n') + '\\n';\n\n  // could be this has multiple certs within\n  const regex2 = /----------/;\n  result = result.replace(new RegExp(regex2, 'g'), '-----\\n-----');\n  return result;\n};\n\n/*\n * Convert a PEM encoded certificate to DER format\n * @param {string) pem PEM encoded public or private key\n * @returns {string} hex Hex-encoded DER bytes\n * @throws Will throw an error if the conversation fails\n */\nmodule.exports.pemToDER = pem => {\n  // PEM format is essentially a nicely formatted base64 representation of DER encoding\n  // So we need to strip \"BEGIN\" / \"END\" header/footer and string line breaks\n  // Then we simply base64 decode it and convert to hex string\n  const contents = pem.toString().trim().split(/\\r?\\n/);\n  // check for BEGIN and END tags\n  if (!(contents[0].match(/-----\\s*BEGIN ?([^-]+)?-----/) && contents[contents.length - 1].match(/-----\\s*END ?([^-]+)?-----/))) {\n    throw new Error('Input parameter does not appear to be PEM-encoded.');\n  }\n  contents.shift(); // remove BEGIN\n  contents.pop(); // remove END\n  // base64 decode and encode as hex string\n  // var hex = Buffer.from(contents.join(''), 'base64').toString('hex');\n  const hex = Buffer.from(contents.join(''), 'base64');\n  return hex;\n};\nmodule.exports.checkIntegerConfig = (opts, configName) => {\n  let result = false;\n  if (opts && opts[configName]) {\n    if (!Number.isInteger(opts[configName])) {\n      throw new Error(`Expect an integer value of ${configName}, found ${typeof configName}`);\n    }\n    result = true;\n  }\n  return result;\n};\nmodule.exports.convertBytetoString = (buffer_array, encoding) => {\n  const decode_as = encoding || 'utf8';\n  if (!Array.isArray(buffer_array)) {\n    return buffer_array.toString(decode_as);\n  }\n  return buffer_array.map(buffer => buffer.toString(decode_as)).join('');\n};\nmodule.exports.byteToNormalizedPEM = (buffer_array, encoding) => {\n  let result = module.exports.convertBytetoString(buffer_array, encoding);\n  if (result) {\n    result = module.exports.normalizeX509(result);\n  }\n  return result;\n};\n\n/*\n * Converts to a Long number\n * Returns a null if the incoming value is not a string that represents a\n * number or an actual javascript number. Also allows for a Long object to be\n * passed in as the value to convert\n */\nmodule.exports.convertToLong = function (value) {\n  let throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let result = null;\n  if (Long.isLong(value)) {\n    result = value; // already a long\n  } else if (typeof value !== 'undefined' && value !== null) {\n    result = Long.fromValue(value);\n    // Long will return a zero for invalid strings so make sure we did\n    // not get a real zero as the incoming value\n    if (result.equals(Long.ZERO)) {\n      if (Number.isInteger(value) || value === '0') {\n        // all good\n      } else {\n        // anything else must be a string that is not a valid number\n        throw new Error(`value:${value} is not a valid number`);\n      }\n    }\n  } else {\n    if (throwError) {\n      module.exports.checkParameter('value');\n    }\n  }\n  return result;\n};\n\n/*\n * randomizes the input array\n */\nmodule.exports.randomize = items => {\n  for (let i = items.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [items[i], items[j]] = [items[j], items[i]];\n  }\n};\n\n/*\n * Used on a method's parameter to throw an error when\n * the value is missing.\n */\nmodule.exports.checkParameter = name => {\n  throw Error(`Missing ${name} parameter`);\n};\n\n/**\n * Map CSRUtil.newCSRPEM style extensions:\n * ```\n * {\n *     subjectAltName: {\n *         array: [...],\n *     },\n * }\n * ```\n *\n * to CertificationRequest style extensions:\n * ```\n * {\n *     extname: 'subjectAltName',\n *     array: [...],\n * }\n * ```\n * @private\n */\nmodule.exports.mapCSRExtensions = extensions => {\n  if (!Array.isArray(extensions)) {\n    return extensions;\n  }\n  const results = [];\n  extensions.forEach(extension => {\n    const isCertificationRequestExtension = typeof extension.extname === 'string';\n    if (isCertificationRequestExtension) {\n      results.push(extension);\n    } else {\n      Object.entries(extension).forEach(_ref => {\n        let [extname, props] = _ref;\n        const extensionRequest = Object.assign({}, props, {\n          extname\n        });\n        results.push(extensionRequest);\n      });\n    }\n  });\n  return results;\n};","map":{"version":3,"names":["Long","require","util","winston","crypto","path","os","Config","InMemoryKeyValueStore","CryptoKeyStore","sjcl","yn","fabricCommonConfigProperty","isOldPropertyValue","value","startsWith","isOldCryptoSuiteImpl","csImpl","key","Object","getOwnPropertyNames","getSoftwareCryptoSuiteImpl","result","exports","getConfigSetting","EC","getHsmCryptoSuiteImpl","module","newCryptoSuite","setting","keysize","algorithm","hashAlgo","opts","useHSM","software","toUpperCase","hash","Error","format","cryptoSuite","newKeyValueStore","LOGGING_LEVELS","getLogger","name","logger","saveLogger","loggerToSave","global","hfc","newDefaultLogger","Logger","transports","Console","colorize","timestamp","insertLoggerName","originalLogger","lname","assign","forEach","method","func","context","loggerName","f","arguments","length","apply","config_log_setting","undefined","options","config","JSON","parse","level","includes","push","File","filename","json","debug","err","log","stack","setLogger","info","warn","error","addConfigFile","filePath","getConfig","file","setConfigSetting","set","default_value","get","ensureFabricCommonConfigLoaded","default_config","resolve","__dirname","reorderFileStores","bitsToBytes","arr","out","bl","bitArray","bitLength","tmp","i","bytesToBits","bytes","partial","zeroBuffer","Buffer","alloc","toArrayBuffer","buffer","ab","ArrayBuffer","view","Uint8Array","getNonce","Number","isInteger","randomBytes","getClassMethods","clazz","proto","getPrototypeOf","filter","e","getBufferBit","buf","idx","parseInt","invalid","getDefaultKeyStorePath","join","homedir","newCryptoKeyStore","keyValueStore","checkAndAddConfigSetting","option_name","return_options","keys","normalizeX509","raw","regex","matches","match","shift","map","element","trim","regex2","replace","RegExp","pemToDER","pem","contents","toString","split","pop","hex","from","checkIntegerConfig","configName","convertBytetoString","buffer_array","encoding","decode_as","Array","isArray","byteToNormalizedPEM","convertToLong","throwError","isLong","fromValue","equals","ZERO","checkParameter","randomize","items","j","Math","floor","random","mapCSRExtensions","extensions","results","extension","isCertificationRequestExtension","extname","entries","_ref","props","extensionRequest"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/Utils.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n'use strict';\n\nconst Long = require('long');\nconst util = require('util');\nconst winston = require('winston');\nconst crypto = require('crypto');\nconst path = require('path');\nconst os = require('os');\n\nconst Config = require('./Config');\nconst InMemoryKeyValueStore = require('./impl/InMemoryKeyValueStore');\nconst CryptoKeyStore = require('./impl/CryptoKeyStore');\nconst sjcl = require('sjcl');\nconst yn = require('yn');\n\nconst fabricCommonConfigProperty = 'fabric-common-config';\n//\n// The following methods are for loading the proper implementation of an extensible APIs.\n//\n\nfunction isOldPropertyValue(value) {\n\treturn typeof value === 'string' && value.startsWith('fabric-client/');\n}\n\nfunction isOldCryptoSuiteImpl(csImpl) {\n\tfor (const key of Object.getOwnPropertyNames(csImpl)) {\n\t\tif (isOldPropertyValue(csImpl[key])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction getSoftwareCryptoSuiteImpl() {\n\tlet result = exports.getConfigSetting('crypto-suite-software');\n\tif (!result || isOldCryptoSuiteImpl(result)) {\n\t\tresult = {\n\t\t\tEC: 'fabric-common/lib/impl/CryptoSuite_ECDSA_AES'\n\t\t};\n\t}\n\treturn result;\n}\n\nfunction getHsmCryptoSuiteImpl() {\n\tlet result = exports.getConfigSetting('crypto-suite-hsm');\n\tif (!result || isOldCryptoSuiteImpl(result)) {\n\t\tresult = {\n\t\t\tEC: 'fabric-common/lib/impl/bccsp_pkcs11'\n\t\t};\n\t}\n\treturn result;\n}\n\n/**\n * @typedef {Object} CryptoSetting\n * @property {boolean} software - Whether to load a software-based implementation (true) or HSM implementation (false)\n * @property {number} keysize - The key size to use for the crypto suite instance.\n * @property {string} algorithm - Digital signature algorithm\n * @property {string} hash 'SHA2' or 'SHA3'\n */\n\n\n/**\n * Returns a new instance of the CryptoSuite API implementation. Supports the following:\n * - newCryptoSuite({software: true, keysize: 256, algorithm: EC})\n * - newCryptoSuite({software: false, lib: '/usr/local/bin/pkcs11.so', slot: 0, pin: '1234'})\n * - newCryptoSuite({software: false, lib: '/usr/local/bin/pkcs11.so', label: 'ForFabric', pin: '1234'})\n * - newCryptoSuite({keysize: 384})\n * - newCryptoSuite()\n * @param {CryptoSetting} [setting]\n *  - property `software` default is true (for software based implementation),\n *          specific implementation module is specified in the setting 'crypto-suite-software'\n *  - property `algorithm` currently supporting ECDSA only with value \"EC\"\n *  - property `keysize` default is value of the setting 'crypto-keysize'\n */\nmodule.exports.newCryptoSuite = (setting) => {\n\tlet csImpl, keysize, algorithm, hashAlgo, opts = null;\n\n\tlet useHSM = false;\n\tif (setting && typeof setting.software === 'boolean') {\n\t\tuseHSM = !setting.software;\n\t} else {\n\t\tuseHSM = yn(exports.getConfigSetting('crypto-hsm'));\n\t}\n\n\tcsImpl = useHSM ? getHsmCryptoSuiteImpl() : getSoftwareCryptoSuiteImpl();\n\n\t// step 1: what's the cryptosuite impl to use, key size and algo\n\tif (setting && setting.keysize && typeof setting === 'object' && typeof setting.keysize === 'number') {\n\t\tkeysize = setting.keysize;\n\t} else {\n\t\tkeysize = exports.getConfigSetting('crypto-keysize');\n\t}\n\n\tif (setting && setting.algorithm && typeof setting === 'object' && typeof setting.algorithm === 'string') {\n\t\talgorithm = setting.algorithm.toUpperCase();\n\t} else {\n\t\talgorithm = 'EC';\n\t}\n\n\tif (setting && setting.hash && typeof setting === 'object' && typeof setting.hash === 'string') {\n\t\thashAlgo = setting.hash.toUpperCase();\n\t} else {\n\t\thashAlgo = null;\n\t}\n\n\t// csImpl at this point should be a map (see config/default.json) with keys being the algorithm\n\tcsImpl = csImpl[algorithm];\n\n\tif (!csImpl) {\n\t\tthrow new Error(util.format('Desired CryptoSuite module not found supporting algorithm \"%s\"', algorithm));\n\t}\n\n\tconst cryptoSuite = require(csImpl);\n\n\t// the 'opts' argument to be passed or none at all\n\topts = (typeof setting === 'undefined') ? null : setting;\n\n\t// opts Option is the form { lib: string, slot: number, pin: string }\n\treturn new cryptoSuite(keysize, hashAlgo, opts);\n};\n\n// Provide an in-memory keyValueStore\nmodule.exports.newKeyValueStore = () => {\n\treturn new InMemoryKeyValueStore();\n};\n\n//\n// Internal API.\n// Notice this API is only used at the SDK scope. For the client application, do not use\n// this api.\n//\n// Get the standard logger to use throughout the SDK code. If the client application has\n// configured a logger, then that'll be returned.\n//\n// The user can also make use of the built-in \"winston\" based logger and use the environment\n// variable HFC_LOGGING to pass in configurations in the following format:\n//\n// {\n//   'error': 'error.log',\t\t\t\t// 'error' logs are printed to file 'error.log' relative of the current working dir for node.js\n//   'debug': '/tmp/myapp/debug.log',\t// 'debug' and anything more critical ('info', 'warn', 'error') can also be an absolute path\n//   'info': 'console'\t\t\t\t\t// 'console' is a keyword for logging to console\n// }\n//\n\nconst LOGGING_LEVELS = ['debug', 'info', 'warn', 'error'];\n\nmodule.exports.getLogger = function (name) {\n\tlet logger;\n\tconst saveLogger = function (loggerToSave) {\n\t\tif (global.hfc) {\n\t\t\tglobal.hfc.logger = loggerToSave;\n\t\t} else {\n\t\t\tglobal.hfc = {\n\t\t\t\tlogger: loggerToSave\n\t\t\t};\n\t\t}\n\t};\n\n\tconst newDefaultLogger = () => {\n\t\treturn new winston.Logger({\n\t\t\ttransports: [\n\t\t\t\tnew (winston.transports.Console)({colorize: true, timestamp: true})\n\t\t\t]\n\t\t});\n\t};\n\n\tconst insertLoggerName = (originalLogger, lname) => {\n\t\tlogger = Object.assign({}, originalLogger);\n\n\t\tLOGGING_LEVELS.forEach((method) => {\n\t\t\tconst func = originalLogger[method];\n\n\t\t\tlogger[method] = (function (context, loggerName, f) {\n\t\t\t\treturn function () {\n\t\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t\targuments[0] = '[' + loggerName + ']: ' + arguments[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tf.apply(context, arguments);\n\t\t\t\t};\n\t\t\t})(originalLogger, lname, func);\n\t\t});\n\n\t\treturn logger;\n\t};\n\n\tif (global.hfc && global.hfc.logger) {\n\t\treturn insertLoggerName(global.hfc.logger, name);\n\t}\n\n\t// see if the config has it set\n\tconst config_log_setting = exports.getConfigSetting('hfc-logging', undefined); // environment setting will be HFC_LOGGING\n\n\tconst options = {};\n\tif (config_log_setting) {\n\t\ttry {\n\t\t\tconst config = typeof config_log_setting === 'string' ? JSON.parse(config_log_setting) : config_log_setting;\n\t\t\tif (typeof config !== 'object') {\n\t\t\t\tthrow new Error('Environment variable \"HFC_LOGGING\" must be an object conforming to the format documented.');\n\t\t\t}\n\t\t\tfor (const level in config) {\n\t\t\t\tif (!config[level]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (LOGGING_LEVELS.includes(level)) {\n\t\t\t\t\tif (!options.transports) {\n\t\t\t\t\t\toptions.transports = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config[level] === 'console') {\n\t\t\t\t\t\toptions.transports.push(new (winston.transports.Console)({\n\t\t\t\t\t\t\tname: level + 'console',\n\t\t\t\t\t\t\tlevel: level,\n\t\t\t\t\t\t\ttimestamp: true,\n\t\t\t\t\t\t\tcolorize: true\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.transports.push(new (winston.transports.File)({\n\t\t\t\t\t\t\tname: level + 'file',\n\t\t\t\t\t\t\tlevel: level,\n\t\t\t\t\t\t\tfilename: config[level],\n\t\t\t\t\t\t\ttimestamp: true,\n\t\t\t\t\t\t\tcolorize: false,\n\t\t\t\t\t\t\tjson: false\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger = new winston.Logger(options);\n\t\t\tlogger.debug('Successfully constructed a winston logger with configurations', config);\n\t\t\tsaveLogger(logger);\n\t\t\treturn insertLoggerName(logger, name);\n\t\t} catch (err) {\n\t\t\t// the user's configuration from environment variable failed to parse.\n\t\t\t// construct the default logger, log a warning and return it\n\t\t\tlogger = newDefaultLogger();\n\t\t\tsaveLogger(logger);\n\t\t\tlogger.log('warn', 'Failed to parse environment variable \"HFC_LOGGING\". Returned a winston logger with default configurations. Error: %s', err.stack ? err.stack : err);\n\t\t\treturn insertLoggerName(logger, name);\n\t\t}\n\t}\n\n\tlogger = newDefaultLogger();\n\tsaveLogger(logger);\n\tlogger.debug('Returning a new winston logger with default configurations');\n\treturn insertLoggerName(logger, name);\n};\n\n/**\n * Configures a logger for the entire SDK to use and override the default logger. Unless this method is called,\n * the SDK uses a default logger based on [winston]{@link https://www.npmjs.com/package/winston}.\n * When using the built-in winston based logger, use the configuration setting <code>hfc-logging</code> to pass\n * in configurations in the following format:\n * <br><br>\n * <pre>\n * {\n *   'error': 'error.log',\t\t\t// 'error' logs are printed to file 'error.log' relative of the current working dir for node.js\n *   'debug': '/tmp/myapp/debug.log',\t// 'debug' and anything more critical ('info', 'warn', 'error') can also be an absolute path\n *   'info': 'console'\t\t\t// 'console' is a keyword for logging to console\n * }\n * </pre>\n * <br>\n * @param {Object} logger a logger instance that defines the following methods: debug(), info(), warn(), error() with\n * string interpolation methods like [util.format]{@link https://nodejs.org/api/util.html#util_util_format_format}.\n */\nmodule.exports.setLogger = (logger) => {\n\tlet err = '';\n\n\tif (typeof logger.debug !== 'function') {\n\t\terr += 'debug() ';\n\t}\n\n\tif (typeof logger.info !== 'function') {\n\t\terr += 'info() ';\n\t}\n\n\tif (typeof logger.warn !== 'function') {\n\t\terr += 'warn() ';\n\t}\n\n\tif (typeof logger.error !== 'function') {\n\t\terr += 'error()';\n\t}\n\n\tif (err !== '') {\n\t\tthrow new Error('The \"logger\" parameter must be an object that implements the following methods, which are missing: ' + err);\n\t}\n\n\tif (global.hfc) {\n\t\tglobal.hfc.logger = logger;\n\t} else {\n\t\tglobal.hfc = {\n\t\t\tlogger: logger\n\t\t};\n\t}\n};\n\n//\n// Internal method to add additional configuration file to override default file configuration settings\n//\nmodule.exports.addConfigFile = (filePath) => {\n\tconst config = exports.getConfig();\n\tconfig.file(filePath);\n};\n\n//\n// Internal method to set an override setting to the configuration settings\n//\nmodule.exports.setConfigSetting = (name, value) => {\n\tconst config = exports.getConfig();\n\tconfig.set(name, value);\n};\n\n//\n// Internal method to get an override setting to the configuration settings\n//\nexports.getConfigSetting = (name, default_value) => {\n\tconst config = exports.getConfig();\n\treturn config.get(name, default_value);\n};\n\nfunction ensureFabricCommonConfigLoaded(config) {\n\tif (!config.get(fabricCommonConfigProperty)) {\n\t\tconst default_config = path.resolve(__dirname, '../config/default.json');\n\t\tconfig.reorderFileStores(default_config);\n\t\tconfig.set(fabricCommonConfigProperty, true);\n\t}\n}\n\n//\n// Internal method to get the configuration settings singleton\n//\nexports.getConfig = () => {\n\tif (!global.hfc) {\n\t\tglobal.hfc = {};\n\t}\n\tif (!global.hfc.config) {\n\t\tglobal.hfc.config = new Config();\n\t}\n\n\tensureFabricCommonConfigLoaded(global.hfc.config);\n\n\treturn global.hfc.config;\n};\n\n//\n// Other miscellaneous methods\n//\n\n/**\n * Convert from a bitArray to bytes (refer to SJCL's codec)\n * @param {number[]} arr a bitArray to convert from\n * @returns the bytes converted from the bitArray\n */\nmodule.exports.bitsToBytes = (arr) => {\n\tconst out = [];\n\tconst bl = sjcl.bitArray.bitLength(arr);\n\tlet tmp;\n\tfor (let i = 0; i < bl / 8; i++) {\n\t\tif ((i & 3) === 0) {\n\t\t\ttmp = arr[i / 4];\n\t\t}\n\t\tout.push(tmp >>> 24);\n\t\ttmp <<= 8;\n\t}\n\treturn out;\n};\n\n/**\n * Convert from bytes to a bitArray (refer to SJCL's codec)\n * @param {number[]} bytes a bytes to convert from\n * @returns the bitArray converted from bytes\n */\nmodule.exports.bytesToBits = (bytes) => {\n\tconst out = [];\n\tlet i;\n\tlet tmp = 0;\n\tfor (i = 0; i < bytes.length; i++) {\n\t\ttmp = tmp << 8 | bytes[i];\n\t\tif ((i & 3) === 3) {\n\t\t\tout.push(tmp);\n\t\t\ttmp = 0;\n\t\t}\n\t}\n\tif (i & 3) {\n\t\tout.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n\t}\n\treturn out;\n};\n\nmodule.exports.zeroBuffer = (length) => {\n\treturn Buffer.alloc(length);\n};\n\n// utility function to convert Node buffers to Javascript arraybuffer\nmodule.exports.toArrayBuffer = (buffer) => {\n\tconst ab = new ArrayBuffer(buffer.length);\n\tconst view = new Uint8Array(ab);\n\tfor (let i = 0; i < buffer.length; ++i) {\n\t\tview[i] = buffer[i];\n\t}\n\treturn ab;\n};\n\n// utility function to create a random number of\n// the specified length.\nmodule.exports.getNonce = (length) => {\n\tif (length) {\n\t\tif (Number.isInteger(length)) {\n\t\t\t// good, it is a number\n\t\t} else {\n\t\t\tthrow new Error('Parameter must be an integer');\n\t\t}\n\t} else {\n\t\tlength = exports.getConfigSetting('nonce-size', 24);\n\t}\n\n\tconst value = crypto.randomBytes(length);\n\treturn value;\n};\n\nmodule.exports.getClassMethods = (clazz) => {\n\tconst i = new clazz();\n\tconst proto = Object.getPrototypeOf(i);\n\treturn Object.getOwnPropertyNames(proto).filter(\n\t\t(e) => {\n\t\t\tif (e !== 'constructor' && typeof i[e] === 'function') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n};\n\nmodule.exports.getBufferBit = (buf, idx) => {\n\t// return error=true if bit to mask exceeds buffer length\n\tif ((parseInt(idx / 8) + 1) > buf.length) {\n\t\treturn {error: true, invalid: 0};\n\t}\n\tif ((buf[parseInt(idx / 8)] & (1 << (idx % 8))) !== 0) {\n\t\treturn {error: false, invalid: 1};\n\t} else {\n\t\treturn {error: false, invalid: 0};\n\t}\n};\n\nmodule.exports.getDefaultKeyStorePath = () => {\n\treturn path.join(os.homedir(), '.hfc-key-store');\n};\n\n/**\n *\n * @param {KeyValueStore} [keyValueStore] Optional. The built-in key store saves private keys.\n *    The key store must be instance of any {@link KeyValueStore} implementations.\n * @return {CryptoKeyStore}\n */\nmodule.exports.newCryptoKeyStore = (keyValueStore = new InMemoryKeyValueStore()) => {\n\treturn new CryptoKeyStore(keyValueStore);\n};\n\n/*\n * This function will create a new key value pair type options list based\n * on the one passed in. The option setting will be added to the options if it\n * does not exist in the options already. The value of the setting being checked\n * will be the default value passed in unless there is a value in the config\n * settings or already on the options list.\n */\nmodule.exports.checkAndAddConfigSetting = (option_name, default_value, options) => {\n\tconst return_options = {};\n\treturn_options[option_name] = module.exports.getConfigSetting(option_name, default_value);\n\tif (options) {\n\t\tconst keys = Object.keys(options);\n\t\tfor (const i in keys) {\n\t\t\tconst key = keys[i];\n\t\t\tconst value = options[key];\n\t\t\treturn_options[key] = value;\n\t\t}\n\t}\n\treturn return_options;\n};\n\n/*\n * Make sure there's a start line with '-----BEGIN CERTIFICATE-----'\n * and end line with '-----END CERTIFICATE-----', so as to be compliant\n * with x509 parsers\n */\nmodule.exports.normalizeX509 = (raw) => {\n\tconst regex = /(-----\\s*BEGIN ?[^-]+?-----)([\\s\\S]*)(-----\\s*END ?[^-]+?-----)/;\n\tlet matches = raw.match(regex);\n\tif (!matches || matches.length !== 4) {\n\t\tthrow new Error('Failed to find start line or end line of the certificate.');\n\t}\n\n\t// remove the first element that is the whole match\n\tmatches.shift();\n\t// remove LF or CR\n\tmatches = matches.map((element) => {\n\t\treturn element.trim();\n\t});\n\n\t// make sure '-----BEGIN CERTIFICATE-----' and '-----END CERTIFICATE-----' are in their own lines\n\t// and that it ends in a new line\n\tlet result = matches.join('\\n') + '\\n';\n\n\t// could be this has multiple certs within\n\tconst regex2 = /----------/;\n\tresult = result.replace(new RegExp(regex2, 'g'), '-----\\n-----');\n\n\treturn result;\n};\n\n/*\n * Convert a PEM encoded certificate to DER format\n * @param {string) pem PEM encoded public or private key\n * @returns {string} hex Hex-encoded DER bytes\n * @throws Will throw an error if the conversation fails\n */\nmodule.exports.pemToDER = (pem) => {\n\n\t// PEM format is essentially a nicely formatted base64 representation of DER encoding\n\t// So we need to strip \"BEGIN\" / \"END\" header/footer and string line breaks\n\t// Then we simply base64 decode it and convert to hex string\n\tconst contents = pem.toString().trim().split(/\\r?\\n/);\n\t// check for BEGIN and END tags\n\tif (!(contents[0].match(/-----\\s*BEGIN ?([^-]+)?-----/) &&\n\t\tcontents[contents.length - 1].match(/-----\\s*END ?([^-]+)?-----/))) {\n\t\tthrow new Error('Input parameter does not appear to be PEM-encoded.');\n\t}\n\tcontents.shift(); // remove BEGIN\n\tcontents.pop(); // remove END\n\t// base64 decode and encode as hex string\n\t// var hex = Buffer.from(contents.join(''), 'base64').toString('hex');\n\tconst hex = Buffer.from(contents.join(''), 'base64');\n\treturn hex;\n};\n\nmodule.exports.checkIntegerConfig = (opts, configName) => {\n\tlet result = false;\n\tif (opts && opts[configName]) {\n\t\tif (!Number.isInteger(opts[configName])) {\n\t\t\tthrow new Error(`Expect an integer value of ${configName}, found ${typeof configName}`);\n\t\t}\n\t\tresult = true;\n\t}\n\treturn result;\n};\n\nmodule.exports.convertBytetoString = (buffer_array, encoding) => {\n\tconst decode_as = encoding || 'utf8';\n\n\tif (!Array.isArray(buffer_array)) {\n\t\treturn buffer_array.toString(decode_as);\n\t}\n\n\treturn buffer_array\n\t\t.map(buffer => buffer.toString(decode_as))\n\t\t.join('');\n};\n\nmodule.exports.byteToNormalizedPEM = (buffer_array, encoding) => {\n\tlet result = module.exports.convertBytetoString(buffer_array, encoding);\n\tif (result) {\n\t\tresult = module.exports.normalizeX509(result);\n\t}\n\n\treturn result;\n};\n\n/*\n * Converts to a Long number\n * Returns a null if the incoming value is not a string that represents a\n * number or an actual javascript number. Also allows for a Long object to be\n * passed in as the value to convert\n */\nmodule.exports.convertToLong = (value, throwError = true) => {\n\tlet result = null;\n\tif (Long.isLong(value)) {\n\t\tresult = value; // already a long\n\t} else if (typeof value !== 'undefined' && value !== null) {\n\t\tresult = Long.fromValue(value);\n\t\t// Long will return a zero for invalid strings so make sure we did\n\t\t// not get a real zero as the incoming value\n\t\tif (result.equals(Long.ZERO)) {\n\t\t\tif (Number.isInteger(value) || value === '0') {\n\t\t\t\t// all good\n\t\t\t} else {\n\t\t\t\t// anything else must be a string that is not a valid number\n\t\t\t\tthrow new Error(`value:${value} is not a valid number`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (throwError) {\n\t\t\tmodule.exports.checkParameter('value');\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/*\n * randomizes the input array\n */\nmodule.exports.randomize = (items) => {\n\tfor (let i = items.length - 1; i > 0; i--) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[items[i], items[j]] = [items[j], items[i]];\n\t}\n};\n\n/*\n * Used on a method's parameter to throw an error when\n * the value is missing.\n */\nmodule.exports.checkParameter = (name) => {\n\tthrow Error(`Missing ${name} parameter`);\n};\n\n/**\n * Map CSRUtil.newCSRPEM style extensions:\n * ```\n * {\n *     subjectAltName: {\n *         array: [...],\n *     },\n * }\n * ```\n *\n * to CertificationRequest style extensions:\n * ```\n * {\n *     extname: 'subjectAltName',\n *     array: [...],\n * }\n * ```\n * @private\n */\nmodule.exports.mapCSRExtensions = (extensions) => {\n\tif (!Array.isArray(extensions)) {\n\t\treturn extensions;\n\t}\n\n\tconst results = [];\n\textensions.forEach(extension => {\n\t\tconst isCertificationRequestExtension = typeof extension.extname === 'string';\n\t\tif (isCertificationRequestExtension) {\n\t\t\tresults.push(extension);\n\t\t} else {\n\t\t\tObject.entries(extension).forEach(([extname, props]) => {\n\t\t\t\tconst extensionRequest = Object.assign({}, props, {extname});\n\t\t\t\tresults.push(extensionRequest);\n\t\t\t});\n\t\t}\n\t});\n\n\treturn results;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}