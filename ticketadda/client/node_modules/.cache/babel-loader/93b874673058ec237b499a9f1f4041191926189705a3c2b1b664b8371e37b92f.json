{"ast":null,"code":"/*\n Copyright 2016, 2018 IBM All Rights Reserved.\n\n SPDX-License-Identifier: Apache-2.0\n\n*/\n\n'use strict';\n\nconst Key = require('../../Key');\nconst HashPrimitives = require('../../HashPrimitives');\nconst jsrsa = require('jsrsasign');\nconst Utils = require('../../Utils');\nconst asn1 = jsrsa.asn1;\nconst KEYUTIL = jsrsa.KEYUTIL;\nconst ECDSA = jsrsa.ECDSA;\nconst jws = jsrsa.jws;\n\n/**\n * This module implements the {@link module:api.Key} interface, for ECDSA.\n * @class ECDSA_KEY\n * @extends module:api.Key\n */\nclass ECDSA_KEY extends Key {\n  /**\n   * this class represents the private or public key of an ECDSA key pair.\n   *\n   * @param {Object} key This must be the \"privKeyObj\" or \"pubKeyObj\" part of the object generated by jsrsasign.KEYUTIL.generateKeypair()\n   */\n  constructor(key) {\n    if (!key) {\n      throw new Error('The key parameter is required by this key class implementation, whether this instance is for the public key or private key');\n    }\n    if (!key.type || key.type !== 'EC') {\n      throw new Error('This key implementation only supports keys generated by jsrsasign.KEYUTIL. It must have a \"type\" property of value \"EC\"');\n    }\n\n    // pubKeyHex must have a non-null value\n    if (!key.pubKeyHex) {\n      throw new Error('This key implementation only supports keys generated by jsrsasign.KEYUTIL. It must have a \"pubKeyHex\" property');\n    }\n\n    // prvKeyHex value can be null for public keys\n\n    super();\n    this._key = typeof key === 'undefined' ? null : key;\n  }\n\n  /**\n   * @returns {string} a string representation of the hash from a sequence based on the private key bytes\n   */\n  getSKI() {\n    let buff;\n    const pointToOctet = function (key) {\n      const byteLen = key.ecparams.keylen + 7 >> 3;\n      const newBuff = Buffer.allocUnsafe(1 + 2 * byteLen);\n      newBuff[0] = 4; // uncompressed point (https://www.security-audit.com/files/x9-62-09-20-98.pdf, section 4.3.6)\n      const xyhex = key.getPublicKeyXYHex();\n      const xBuffer = Buffer.from(xyhex.x, 'hex');\n      const yBuffer = Buffer.from(xyhex.y, 'hex');\n      xBuffer.copy(newBuff, 1 + byteLen - xBuffer.length);\n      yBuffer.copy(newBuff, 1 + 2 * byteLen - yBuffer.length);\n      return newBuff;\n    };\n    if (this._key.isPublic) {\n      // referencing implementation of the Marshal() method of https://golang.org/src/crypto/elliptic/elliptic.go\n      buff = pointToOctet(this._key);\n    } else {\n      buff = pointToOctet(this.getPublicKey()._key);\n    }\n\n    // always use SHA256 regardless of the key size in effect\n    return HashPrimitives.SHA2_256(buff);\n  }\n\n  /**\n   * Not supported by non PKCS11 keys.\n   * Only PKCS11 keys have a handle used by the HSM internally to access the key.\n   *\n   * @throws Error\n   */\n  getHandle() {\n    throw Error('This key does not have a PKCS11 handle');\n  }\n  isSymmetric() {\n    return false;\n  }\n  isPrivate() {\n    if (typeof this._key.prvKeyHex !== 'undefined' && this._key.prvKeyHex === null) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  getPublicKey() {\n    if (this._key.isPublic) {\n      return this;\n    } else {\n      const f = new ECDSA({\n        curve: this._key.curveName\n      });\n      f.setPublicKeyHex(this._key.pubKeyHex);\n      f.isPrivate = false;\n      f.isPublic = true;\n      return new ECDSA_KEY(f);\n    }\n  }\n\n  /**\n   * Generates a CSR/PKCS#10 certificate signing request for this key\n   * @param {string} subjectDN The X500Name for the certificate request in LDAP(RFC 2253) format\n   * @param {Object[]} [extensions] Additional X.509v3 extensions for the certificate signing request\n   * @returns {string} PEM-encoded PKCS#10 certificate signing request\n   * @throws Will throw an error if this is not a private key\n   * @throws Will throw an error if CSR generation fails for any other reason\n   */\n  generateCSR(subjectDN, extensions) {\n    // check to see if this is a private key\n    if (!this.isPrivate()) {\n      throw new Error('A CSR cannot be generated from a public key');\n    }\n    const extreq = Utils.mapCSRExtensions(extensions);\n    const csr = new asn1.csr.CertificationRequest({\n      subject: {\n        str: asn1.x509.X500Name.ldapToOneline(subjectDN)\n      },\n      sbjpubkey: this.getPublicKey()._key,\n      sigalg: 'SHA256withECDSA',\n      sbjprvkey: this._key,\n      extreq\n    });\n    return csr.getPEM();\n  }\n\n  /**\n   * Generates a self-signed X.509 certificate\n   * @param {string} [subjectDN] The subject to use for the X509 certificate\n   * @returns {string} PEM-encoded X.509 certificate\n   * @throws Will throw an error if this is not a private key\n   * @throws Will throw an error if X.509 certificate generation fails for any other reason\n   */\n  generateX509Certificate() {\n    let subjectDN = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/CN=self';\n    // check to see if this is a private key\n    if (!this.isPrivate()) {\n      throw new Error('An X509 certificate cannot be generated from a public key');\n    }\n    const certPEM = asn1.x509.X509Util.newCertPEM({\n      serial: {\n        int: 4\n      },\n      sigalg: {\n        name: 'SHA256withECDSA'\n      },\n      issuer: {\n        str: subjectDN\n      },\n      notbefore: {\n        'str': jws.IntDate.intDate2Zulu(jws.IntDate.getNow() - 5000)\n      },\n      notafter: {\n        'str': jws.IntDate.intDate2Zulu(jws.IntDate.getNow() + 60000)\n      },\n      subject: {\n        str: subjectDN\n      },\n      sbjpubkey: this.getPublicKey()._key,\n      ext: [{\n        extname: 'basicConstraints',\n        cA: false,\n        critical: true\n      }, {\n        extname: 'keyUsage',\n        bin: '11'\n      }, {\n        extname: 'extKeyUsage',\n        array: [{\n          name: 'clientAuth'\n        }]\n      }],\n      cakey: this._key\n    });\n    return certPEM;\n  }\n  toBytes() {\n    // this is specific to the private key format generated by\n    // npm module 'jsrsasign.KEYUTIL'\n    if (this.isPrivate()) {\n      return KEYUTIL.getPEM(this._key, 'PKCS8PRV');\n    } else {\n      return KEYUTIL.getPEM(this._key);\n    }\n  }\n}\nmodule.exports = ECDSA_KEY;","map":{"version":3,"names":["Key","require","HashPrimitives","jsrsa","Utils","asn1","KEYUTIL","ECDSA","jws","ECDSA_KEY","constructor","key","Error","type","pubKeyHex","_key","getSKI","buff","pointToOctet","byteLen","ecparams","keylen","newBuff","Buffer","allocUnsafe","xyhex","getPublicKeyXYHex","xBuffer","from","x","yBuffer","y","copy","length","isPublic","getPublicKey","SHA2_256","getHandle","isSymmetric","isPrivate","prvKeyHex","f","curve","curveName","setPublicKeyHex","generateCSR","subjectDN","extensions","extreq","mapCSRExtensions","csr","CertificationRequest","subject","str","x509","X500Name","ldapToOneline","sbjpubkey","sigalg","sbjprvkey","getPEM","generateX509Certificate","arguments","undefined","certPEM","X509Util","newCertPEM","serial","int","name","issuer","notbefore","IntDate","intDate2Zulu","getNow","notafter","ext","extname","cA","critical","bin","array","cakey","toBytes","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/impl/ecdsa/key.js"],"sourcesContent":["/*\n Copyright 2016, 2018 IBM All Rights Reserved.\n\n SPDX-License-Identifier: Apache-2.0\n\n*/\n\n'use strict';\n\nconst Key = require('../../Key');\nconst HashPrimitives = require('../../HashPrimitives');\nconst jsrsa = require('jsrsasign');\nconst Utils = require('../../Utils');\nconst asn1 = jsrsa.asn1;\nconst KEYUTIL = jsrsa.KEYUTIL;\nconst ECDSA = jsrsa.ECDSA;\nconst jws = jsrsa.jws;\n\n/**\n * This module implements the {@link module:api.Key} interface, for ECDSA.\n * @class ECDSA_KEY\n * @extends module:api.Key\n */\nclass ECDSA_KEY extends Key {\n\t/**\n\t * this class represents the private or public key of an ECDSA key pair.\n\t *\n\t * @param {Object} key This must be the \"privKeyObj\" or \"pubKeyObj\" part of the object generated by jsrsasign.KEYUTIL.generateKeypair()\n\t */\n\tconstructor(key) {\n\t\tif (!key) {\n\t\t\tthrow new Error('The key parameter is required by this key class implementation, whether this instance is for the public key or private key');\n\t\t}\n\n\t\tif (!key.type || key.type !== 'EC') {\n\t\t\tthrow new Error('This key implementation only supports keys generated by jsrsasign.KEYUTIL. It must have a \"type\" property of value \"EC\"');\n\t\t}\n\n\t\t// pubKeyHex must have a non-null value\n\t\tif (!key.pubKeyHex) {\n\t\t\tthrow new Error('This key implementation only supports keys generated by jsrsasign.KEYUTIL. It must have a \"pubKeyHex\" property');\n\t\t}\n\n\t\t// prvKeyHex value can be null for public keys\n\n\t\tsuper();\n\t\tthis._key = (typeof key === 'undefined') ? null : key;\n\t}\n\n\t/**\n\t * @returns {string} a string representation of the hash from a sequence based on the private key bytes\n\t */\n\tgetSKI() {\n\t\tlet buff;\n\n\t\tconst pointToOctet = function (key) {\n\t\t\tconst byteLen = (key.ecparams.keylen + 7) >> 3;\n\t\t\tconst newBuff = Buffer.allocUnsafe(1 + 2 * byteLen);\n\t\t\tnewBuff[0] = 4; // uncompressed point (https://www.security-audit.com/files/x9-62-09-20-98.pdf, section 4.3.6)\n\t\t\tconst xyhex = key.getPublicKeyXYHex();\n\t\t\tconst xBuffer = Buffer.from(xyhex.x, 'hex');\n\t\t\tconst yBuffer = Buffer.from(xyhex.y, 'hex');\n\t\t\txBuffer.copy(newBuff, 1 + byteLen - xBuffer.length);\n\t\t\tyBuffer.copy(newBuff, 1 + 2 * byteLen - yBuffer.length);\n\t\t\treturn newBuff;\n\t\t};\n\n\t\tif (this._key.isPublic) {\n\t\t\t// referencing implementation of the Marshal() method of https://golang.org/src/crypto/elliptic/elliptic.go\n\t\t\tbuff = pointToOctet(this._key);\n\t\t} else {\n\t\t\tbuff = pointToOctet(this.getPublicKey()._key);\n\t\t}\n\n\t\t// always use SHA256 regardless of the key size in effect\n\t\treturn HashPrimitives.SHA2_256(buff);\n\t}\n\n\t/**\n\t * Not supported by non PKCS11 keys.\n\t * Only PKCS11 keys have a handle used by the HSM internally to access the key.\n\t *\n\t * @throws Error\n\t */\n\tgetHandle() {\n\t\tthrow Error('This key does not have a PKCS11 handle');\n\t}\n\n\tisSymmetric() {\n\t\treturn false;\n\t}\n\n\tisPrivate() {\n\t\tif (typeof this._key.prvKeyHex !== 'undefined' && this._key.prvKeyHex === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tgetPublicKey() {\n\t\tif (this._key.isPublic) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst f = new ECDSA({curve: this._key.curveName});\n\t\t\tf.setPublicKeyHex(this._key.pubKeyHex);\n\t\t\tf.isPrivate = false;\n\t\t\tf.isPublic = true;\n\t\t\treturn new ECDSA_KEY(f);\n\t\t}\n\t}\n\n\t/**\n\t * Generates a CSR/PKCS#10 certificate signing request for this key\n\t * @param {string} subjectDN The X500Name for the certificate request in LDAP(RFC 2253) format\n\t * @param {Object[]} [extensions] Additional X.509v3 extensions for the certificate signing request\n\t * @returns {string} PEM-encoded PKCS#10 certificate signing request\n\t * @throws Will throw an error if this is not a private key\n\t * @throws Will throw an error if CSR generation fails for any other reason\n\t */\n\tgenerateCSR(subjectDN, extensions) {\n\t\t// check to see if this is a private key\n\t\tif (!this.isPrivate()) {\n\t\t\tthrow new Error('A CSR cannot be generated from a public key');\n\t\t}\n\n\t\tconst extreq = Utils.mapCSRExtensions(extensions);\n\t\tconst csr = new asn1.csr.CertificationRequest({\n\t\t\tsubject: {str: asn1.x509.X500Name.ldapToOneline(subjectDN)},\n\t\t\tsbjpubkey: this.getPublicKey()._key,\n\t\t\tsigalg: 'SHA256withECDSA',\n\t\t\tsbjprvkey: this._key,\n\t\t\textreq,\n\t\t});\n\t\treturn csr.getPEM();\n\t}\n\n\t/**\n\t * Generates a self-signed X.509 certificate\n\t * @param {string} [subjectDN] The subject to use for the X509 certificate\n\t * @returns {string} PEM-encoded X.509 certificate\n\t * @throws Will throw an error if this is not a private key\n\t * @throws Will throw an error if X.509 certificate generation fails for any other reason\n\t */\n\tgenerateX509Certificate(subjectDN = '/CN=self') {\n\n\t\t// check to see if this is a private key\n\t\tif (!this.isPrivate()) {\n\t\t\tthrow new Error('An X509 certificate cannot be generated from a public key');\n\t\t}\n\n\t\tconst certPEM = asn1.x509.X509Util.newCertPEM({\n\t\t\tserial: {int: 4},\n\t\t\tsigalg: {name: 'SHA256withECDSA'},\n\t\t\tissuer: {str: subjectDN},\n\t\t\tnotbefore: {'str': jws.IntDate.intDate2Zulu(jws.IntDate.getNow() - 5000)},\n\t\t\tnotafter: {'str': jws.IntDate.intDate2Zulu(jws.IntDate.getNow() + 60000)},\n\t\t\tsubject: {str: subjectDN},\n\t\t\tsbjpubkey: this.getPublicKey()._key,\n\t\t\text: [\n\t\t\t\t{\n\t\t\t\t\textname: 'basicConstraints',\n\t\t\t\t\tcA: false,\n\t\t\t\t\tcritical: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\textname: 'keyUsage',\n\t\t\t\t\tbin: '11'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\textname: 'extKeyUsage',\n\t\t\t\t\tarray: [{name: 'clientAuth'}]\n\t\t\t\t}\n\t\t\t],\n\t\t\tcakey: this._key\n\t\t});\n\t\treturn certPEM;\n\t}\n\n\ttoBytes() {\n\t\t// this is specific to the private key format generated by\n\t\t// npm module 'jsrsasign.KEYUTIL'\n\t\tif (this.isPrivate()) {\n\t\t\treturn KEYUTIL.getPEM(this._key, 'PKCS8PRV');\n\t\t} else {\n\t\t\treturn KEYUTIL.getPEM(this._key);\n\t\t}\n\t}\n}\n\nmodule.exports = ECDSA_KEY;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}