{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'Eventer';\nconst {\n  checkParameter,\n  getLogger\n} = require('./Utils.js');\nconst logger = getLogger(TYPE);\nconst ServiceEndpoint = require('./ServiceEndpoint.js');\nconst fabproto6 = require('fabric-protos');\nconst FILTERED_BLOCK = 'filtered';\nconst FULL_BLOCK = 'full';\nconst PRIVATE_BLOCK = 'private';\nlet eventerCount = 1;\n\n/**\n * Eventer is used to monitor for new blocks on a peer's ledger.\n * The class supports the connection to the service to the Peer's event service.\n * @class\n * @extends ServiceEndpoint\n */\n\nclass Eventer extends ServiceEndpoint {\n  /**\n   * Constructs a Eventer object\n   *\n   * @param {string} name\n   * @param {Client} client - An instance of the Client class\n   * @param mspid\n   * @returns {Eventer} An instance of this class\n   */\n\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('name');\n    let client = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('client');\n    let mspid = arguments.length > 2 ? arguments[2] : undefined;\n    logger.debug(`${TYPE}.constructor[${name}] - start `);\n    super(name, client);\n    this.type = TYPE;\n    this.mspid = mspid;\n    this.serviceClass = fabproto6.services.protos.Deliver;\n    // grpc chat streaming on the service\n    this.stream = null;\n    // debug check\n    this.myCount = eventerCount++;\n  }\n\n  /**\n   * Disconnects this Eventer from the fabric peer service and\n   * closes all services.\n   * The event listeners will be closed when EventService receives the \"end\"\n   * from the peer service.\n   */\n  disconnect() {\n    const method = `disconnect[${this.name}:${this.myCount}]`;\n    logger.debug(`${method} - start on Eventer`);\n    if (this.stream) {\n      logger.debug(`${method} - shutdown existing stream`);\n      this.stream.cancel();\n      if (this.stream) {\n        this.stream.end();\n        this.stream = null;\n      } else {\n        logger.debug('%s - no stream to end', method);\n      }\n    } else {\n      logger.debug(`${method} - no stream to close`);\n    }\n    super.disconnect();\n    logger.debug(`${method} - end on Eventer`);\n  }\n\n  /**\n   * Check the connection status\n   * @param {boolean} [reset] - Optional, attempt to reconnect if endpoint is not connected\n   */\n  async checkConnection() {\n    let reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const method = `checkConnection[${this.type}-${this.name}]`;\n    logger.debug('%s - start - connected:%s', method, this.connected);\n    if (reset && this.connected) {\n      try {\n        await this.waitForReady();\n      } catch (error) {\n        logger.error(`ServiceEndpoint ${this.endpoint.url} connection failed :: ${error}`);\n      }\n    }\n    if (reset && !this.connected && this.isConnectable()) {\n      try {\n        this.disconnect();\n        await this.resetConnection();\n      } catch (error) {\n        logger.error(`ServiceEndpoint ${this.endpoint.url} reset connection failed :: ${error}`);\n      }\n    }\n    logger.debug('%s - end - connected:%s', method, this.connected);\n    return this.connected;\n  }\n\n  /*\n   * internal utility method to check if the stream is ready.\n   * The stream must be readable, writeable and reading to be 'ready'\n   * and not paused.\n   */\n  isStreamReady() {\n    const method = `isStreamReady[[${this.name}:${this.myCount}]`;\n    logger.debug(`${method} - start`);\n    let ready = false;\n    if (this.stream) {\n      if (this.stream.isPaused()) {\n        logger.debug(`${method} - grpc stream isPaused`);\n        this.stream.resume();\n      }\n      ready = this.stream.readable && this.stream.writable;\n    } else {\n      logger.debug(`${method} - no stream to check`);\n    }\n    logger.debug(`${method} - stream ready ${ready}`);\n    return ready;\n  }\n\n  /*\n   * internal method to get a new stream based on block type\n   */\n  setStreamByType() {\n    let blockType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('blockType');\n    if (blockType === FILTERED_BLOCK) {\n      this.stream = this.service.deliverFiltered();\n    } else if (blockType === FULL_BLOCK) {\n      this.stream = this.service.deliver();\n    } else if (blockType === PRIVATE_BLOCK) {\n      this.stream = this.service.deliverWithPrivateData();\n    } else {\n      throw Error('Unknown block type');\n    }\n    return this;\n  }\n}\nmodule.exports = Eventer;","map":{"version":3,"names":["TYPE","checkParameter","getLogger","require","logger","ServiceEndpoint","fabproto6","FILTERED_BLOCK","FULL_BLOCK","PRIVATE_BLOCK","eventerCount","Eventer","constructor","name","arguments","length","undefined","client","mspid","debug","type","serviceClass","services","protos","Deliver","stream","myCount","disconnect","method","cancel","end","checkConnection","reset","connected","waitForReady","error","endpoint","url","isConnectable","resetConnection","isStreamReady","ready","isPaused","resume","readable","writable","setStreamByType","blockType","service","deliverFiltered","deliver","deliverWithPrivateData","Error","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/Eventer.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'Eventer';\n\nconst {checkParameter, getLogger} = require('./Utils.js');\nconst logger = getLogger(TYPE);\nconst ServiceEndpoint = require('./ServiceEndpoint.js');\n\nconst fabproto6 = require('fabric-protos');\n\nconst FILTERED_BLOCK = 'filtered';\nconst FULL_BLOCK = 'full';\nconst PRIVATE_BLOCK = 'private';\n\nlet eventerCount = 1;\n\n/**\n * Eventer is used to monitor for new blocks on a peer's ledger.\n * The class supports the connection to the service to the Peer's event service.\n * @class\n * @extends ServiceEndpoint\n */\n\nclass Eventer extends ServiceEndpoint {\n\n\t/**\n\t * Constructs a Eventer object\n\t *\n\t * @param {string} name\n\t * @param {Client} client - An instance of the Client class\n\t * @param mspid\n\t * @returns {Eventer} An instance of this class\n\t */\n\n\tconstructor(name = checkParameter('name'), client = checkParameter('client'), mspid) {\n\t\tlogger.debug(`${TYPE}.constructor[${name}] - start `);\n\t\tsuper(name, client);\n\t\tthis.type = TYPE;\n\t\tthis.mspid = mspid;\n\n\t\tthis.serviceClass = fabproto6.services.protos.Deliver;\n\t\t// grpc chat streaming on the service\n\t\tthis.stream = null;\n\t\t// debug check\n\t\tthis.myCount = eventerCount++;\n\t}\n\n\t/**\n\t * Disconnects this Eventer from the fabric peer service and\n\t * closes all services.\n\t * The event listeners will be closed when EventService receives the \"end\"\n\t * from the peer service.\n\t */\n\tdisconnect() {\n\t\tconst method = `disconnect[${this.name}:${this.myCount}]`;\n\t\tlogger.debug(`${method} - start on Eventer`);\n\n\t\tif (this.stream) {\n\t\t\tlogger.debug(`${method} - shutdown existing stream`);\n\t\t\tthis.stream.cancel();\n\t\t\tif (this.stream) {\n\t\t\t\tthis.stream.end();\n\t\t\t\tthis.stream = null;\n\t\t\t} else {\n\t\t\t\tlogger.debug('%s - no stream to end', method);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug(`${method} - no stream to close`);\n\t\t}\n\n\t\tsuper.disconnect();\n\t\tlogger.debug(`${method} - end on Eventer`);\n\t}\n\n\t/**\n\t * Check the connection status\n\t * @param {boolean} [reset] - Optional, attempt to reconnect if endpoint is not connected\n\t */\n\tasync checkConnection(reset = true) {\n\t\tconst method = `checkConnection[${this.type}-${this.name}]`;\n\t\tlogger.debug('%s - start - connected:%s', method, this.connected);\n\n\t\tif (reset && this.connected) {\n\t\t\ttry {\n\t\t\t\tawait this.waitForReady();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`ServiceEndpoint ${this.endpoint.url} connection failed :: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\tif (reset && !this.connected && this.isConnectable()) {\n\t\t\ttry {\n\t\t\t\tthis.disconnect();\n\t\t\t\tawait this.resetConnection();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`ServiceEndpoint ${this.endpoint.url} reset connection failed :: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - end - connected:%s', method, this.connected);\n\t\treturn this.connected;\n\t}\n\n\t/*\n\t * internal utility method to check if the stream is ready.\n\t * The stream must be readable, writeable and reading to be 'ready'\n\t * and not paused.\n\t */\n\tisStreamReady() {\n\t\tconst method = `isStreamReady[[${this.name}:${this.myCount}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tlet ready = false;\n\t\tif (this.stream) {\n\t\t\tif (this.stream.isPaused()) {\n\t\t\t\tlogger.debug(`${method} - grpc stream isPaused`);\n\t\t\t\tthis.stream.resume();\n\t\t\t}\n\t\t\tready = this.stream.readable && this.stream.writable;\n\t\t} else {\n\t\t\tlogger.debug(`${method} - no stream to check`);\n\t\t}\n\n\t\tlogger.debug(`${method} - stream ready ${ready}`);\n\t\treturn ready;\n\t}\n\n\t/*\n\t * internal method to get a new stream based on block type\n\t */\n\tsetStreamByType(blockType = checkParameter('blockType')) {\n\t\tif (blockType === FILTERED_BLOCK) {\n\t\t\tthis.stream = this.service.deliverFiltered();\n\t\t} else if (blockType === FULL_BLOCK) {\n\t\t\tthis.stream = this.service.deliver();\n\t\t} else if (blockType === PRIVATE_BLOCK) {\n\t\t\tthis.stream = this.service.deliverWithPrivateData();\n\t\t} else {\n\t\t\tthrow Error('Unknown block type');\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\nmodule.exports = Eventer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}