{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_stream_1 = require(\"./call-stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n    this.pendingHalfClose = false;\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n  var _a, _b;\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n  constructor(call,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    let serialized;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose() {\n    this.call.halfClose();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n  start(metadata, listener) {\n    var _a, _b;\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\nfunction getBottomInterceptingCall(channel, options,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\nfunction getInterceptingCall(interceptorArgs,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  let interceptors = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"names":["metadata_1","require","call_stream_1","constants_1","InterceptorConfigurationError","Error","constructor","message","name","captureStackTrace","exports","ListenerBuilder","metadata","undefined","status","withOnReceiveMetadata","onReceiveMetadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveStatus","onReceiveStatus","build","RequesterBuilder","start","halfClose","cancel","withStart","withSendMessage","sendMessage","withHalfClose","withCancel","defaultListener","next","defaultRequester","listener","InterceptingCall","nextCall","requester","processingMetadata","pendingMessageContext","processingMessage","pendingHalfClose","_a","_b","_c","_d","cancelWithStatus","details","getPeer","processPendingMessage","sendMessageWithContext","pendingMessage","processPendingHalfClose","interceptingListener","fullInterceptingListener","bind","_f","_e","md","finalInterceptingListener","isInterceptingListener","fullListener","InterceptingListenerImpl","context","finalMessage","startRead","setCredentials","credentials","getCall","channel","path","options","deadline","Infinity","host","parent","propagateFlags","propagate_flags","call","createCall","BaseInterceptingCall","methodDefinition","serialized","requestSerialize","e","Status","INTERNAL","readError","deserialized","responseDeserialize","code","Metadata","BaseUnaryInterceptingCall","receivedMessage","wrapperListener","BaseStreamingInterceptingCall","getBottomInterceptingCall","responseStream","getInterceptingCall","interceptorArgs","clientInterceptors","length","clientInterceptorProviders","callInterceptors","callInterceptorProviders","interceptors","concat","map","provider","filter","interceptor","interceptorOptions","Object","assign","method_definition","reduceRight","nextInterceptor","currentOptions","finalOptions"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/client-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-stream';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { CallCredentials } from './call-credentials';\nimport { ClientMethodDefinition } from './make-client';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: (next) => {\n    next();\n  },\n  cancel: (next) => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n\n  setCredentials(credentials: CallCredentials): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        ((metadata) => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        ((message) => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        ((status) => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, (finalMessage) => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.nextCall.setCredentials(credentials);\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${e.message}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: (metadata) => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: (message) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: (status) => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? ((metadata) => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,aAAA,GAAAD,OAAA;AAaA,MAAAE,WAAA,GAAAF,OAAA;AAMA;;;;AAIA,MAAaG,6BAA8B,SAAQC,KAAK;EACtDC,YAAYC,OAAe;IACzB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAG,+BAA+B;IAC3CH,KAAK,CAACI,iBAAiB,CAAC,IAAI,EAAEL,6BAA6B,CAAC;EAC9D;;AALFM,OAAA,CAAAN,6BAAA,GAAAA,6BAAA;AA4CA,MAAaO,eAAe;EAA5BL,YAAA;IACU,KAAAM,QAAQ,GAAiCC,SAAS;IAClD,KAAAN,OAAO,GAAgCM,SAAS;IAChD,KAAAC,MAAM,GAA+BD,SAAS;EAwBxD;EAtBEE,qBAAqBA,CAACC,iBAAmC;IACvD,IAAI,CAACJ,QAAQ,GAAGI,iBAAiB;IACjC,OAAO,IAAI;EACb;EAEAC,oBAAoBA,CAACC,gBAAiC;IACpD,IAAI,CAACX,OAAO,GAAGW,gBAAgB;IAC/B,OAAO,IAAI;EACb;EAEAC,mBAAmBA,CAACC,eAA+B;IACjD,IAAI,CAACN,MAAM,GAAGM,eAAe;IAC7B,OAAO,IAAI;EACb;EAEAC,KAAKA,CAAA;IACH,OAAO;MACLL,iBAAiB,EAAE,IAAI,CAACJ,QAAQ;MAChCM,gBAAgB,EAAE,IAAI,CAACX,OAAO;MAC9Ba,eAAe,EAAE,IAAI,CAACN;KACvB;EACH;;AA1BFJ,OAAA,CAAAC,eAAA,GAAAA,eAAA;AA6BA,MAAaW,gBAAgB;EAA7BhB,YAAA;IACU,KAAAiB,KAAK,GAAkCV,SAAS;IAChD,KAAAN,OAAO,GAAiCM,SAAS;IACjD,KAAAW,SAAS,GAA+BX,SAAS;IACjD,KAAAY,MAAM,GAAgCZ,SAAS;EA8BzD;EA5BEa,SAASA,CAACH,KAAwB;IAChC,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,OAAO,IAAI;EACb;EAEAI,eAAeA,CAACC,WAA6B;IAC3C,IAAI,CAACrB,OAAO,GAAGqB,WAAW;IAC1B,OAAO,IAAI;EACb;EAEAC,aAAaA,CAACL,SAAyB;IACrC,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,OAAO,IAAI;EACb;EAEAM,UAAUA,CAACL,MAAuB;IAChC,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,OAAO,IAAI;EACb;EAEAJ,KAAKA,CAAA;IACH,OAAO;MACLE,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBK,WAAW,EAAE,IAAI,CAACrB,OAAO;MACzBiB,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,MAAM,EAAE,IAAI,CAACA;KACd;EACH;;AAjCFf,OAAA,CAAAY,gBAAA,GAAAA,gBAAA;AAoCA;;;;AAIA,MAAMS,eAAe,GAAiB;EACpCf,iBAAiB,EAAEA,CAACJ,QAAQ,EAAEoB,IAAI,KAAI;IACpCA,IAAI,CAACpB,QAAQ,CAAC;EAChB,CAAC;EACDM,gBAAgB,EAAEA,CAACX,OAAO,EAAEyB,IAAI,KAAI;IAClCA,IAAI,CAACzB,OAAO,CAAC;EACf,CAAC;EACDa,eAAe,EAAEA,CAACN,MAAM,EAAEkB,IAAI,KAAI;IAChCA,IAAI,CAAClB,MAAM,CAAC;EACd;CACD;AAED;;;;AAIA,MAAMmB,gBAAgB,GAAkB;EACtCV,KAAK,EAAEA,CAACX,QAAQ,EAAEsB,QAAQ,EAAEF,IAAI,KAAI;IAClCA,IAAI,CAACpB,QAAQ,EAAEsB,QAAQ,CAAC;EAC1B,CAAC;EACDN,WAAW,EAAEA,CAACrB,OAAO,EAAEyB,IAAI,KAAI;IAC7BA,IAAI,CAACzB,OAAO,CAAC;EACf,CAAC;EACDiB,SAAS,EAAGQ,IAAI,IAAI;IAClBA,IAAI,EAAE;EACR,CAAC;EACDP,MAAM,EAAGO,IAAI,IAAI;IACfA,IAAI,EAAE;EACR;CACD;AAqBD,MAAaG,gBAAgB;EAyB3B7B,YACU8B,QAAmC,EAC3CC,SAAqB;;IADb,KAAAD,QAAQ,GAARA,QAAQ;IArBlB;;;;IAIQ,KAAAE,kBAAkB,GAAG,KAAK;IAClC;;;IAGQ,KAAAC,qBAAqB,GAA0B,IAAI;IAE3D;;;;IAIQ,KAAAC,iBAAiB,GAAG,KAAK;IACjC;;;;IAIQ,KAAAC,gBAAgB,GAAG,KAAK;IAK9B,IAAIJ,SAAS,EAAE;MACb,IAAI,CAACA,SAAS,GAAG;QACfd,KAAK,GAAAmB,EAAA,GAAEL,SAAS,CAACd,KAAK,cAAAmB,EAAA,cAAAA,EAAA,GAAIT,gBAAgB,CAACV,KAAK;QAChDK,WAAW,GAAAe,EAAA,GAAEN,SAAS,CAACT,WAAW,cAAAe,EAAA,cAAAA,EAAA,GAAIV,gBAAgB,CAACL,WAAW;QAClEJ,SAAS,GAAAoB,EAAA,GAAEP,SAAS,CAACb,SAAS,cAAAoB,EAAA,cAAAA,EAAA,GAAIX,gBAAgB,CAACT,SAAS;QAC5DC,MAAM,GAAAoB,EAAA,GAAER,SAAS,CAACZ,MAAM,cAAAoB,EAAA,cAAAA,EAAA,GAAIZ,gBAAgB,CAACR;OAC9C;KACF,MAAM;MACL,IAAI,CAACY,SAAS,GAAGJ,gBAAgB;;EAErC;EAEAa,gBAAgBA,CAAChC,MAAc,EAAEiC,OAAe;IAC9C,IAAI,CAACV,SAAS,CAACZ,MAAM,CAAC,MAAK;MACzB,IAAI,CAACW,QAAQ,CAACU,gBAAgB,CAAChC,MAAM,EAAEiC,OAAO,CAAC;IACjD,CAAC,CAAC;EACJ;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACZ,QAAQ,CAACY,OAAO,EAAE;EAChC;EAEQC,qBAAqBA,CAAA;IAC3B,IAAI,IAAI,CAACV,qBAAqB,EAAE;MAC9B,IAAI,CAACH,QAAQ,CAACc,sBAAsB,CAAC,IAAI,CAACX,qBAAqB,EAAE,IAAI,CAACY,cAAc,CAAC;MACrF,IAAI,CAACZ,qBAAqB,GAAG,IAAI;MACjC,IAAI,CAACY,cAAc,GAAG,IAAI;;EAE9B;EAEQC,uBAAuBA,CAAA;IAC7B,IAAI,IAAI,CAACX,gBAAgB,EAAE;MACzB,IAAI,CAACL,QAAQ,CAACZ,SAAS,EAAE;;EAE7B;EAEAD,KAAKA,CACHX,QAAkB,EAClByC,oBAAoD;;IAEpD,MAAMC,wBAAwB,GAAyB;MACrDtC,iBAAiB,GAAA2B,EAAA,IAAAD,EAAA,GACfW,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAErC,iBAAiB,cAAA0B,EAAA,uBAAAA,EAAA,CAAEa,IAAI,CAACF,oBAAoB,eAAAV,EAAA,cAAAA,EAAA,GAChE/B,QAAQ,IAAI,CAAE,CAAE;MACpBM,gBAAgB,GAAA2B,EAAA,IAAAD,EAAA,GACdS,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEnC,gBAAgB,cAAA0B,EAAA,uBAAAA,EAAA,CAAEW,IAAI,CAACF,oBAAoB,eAAAR,EAAA,cAAAA,EAAA,GAC/DtC,OAAO,IAAI,CAAE,CAAE;MACnBa,eAAe,GAAAoC,EAAA,IAAAC,EAAA,GACbJ,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEjC,eAAe,cAAAqC,EAAA,uBAAAA,EAAA,CAAEF,IAAI,CAACF,oBAAoB,eAAAG,EAAA,cAAAA,EAAA,GAC9D1C,MAAM,IAAI,CAAE;KACjB;IACD,IAAI,CAACwB,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACD,SAAS,CAACd,KAAK,CAACX,QAAQ,EAAE0C,wBAAwB,EAAE,CAACI,EAAE,EAAExB,QAAQ,KAAI;;MACxE,IAAI,CAACI,kBAAkB,GAAG,KAAK;MAC/B,IAAIqB,yBAA+C;MACnD,IAAIzD,aAAA,CAAA0D,sBAAsB,CAAC1B,QAAQ,CAAC,EAAE;QACpCyB,yBAAyB,GAAGzB,QAAQ;OACrC,MAAM;QACL,MAAM2B,YAAY,GAAiB;UACjC7C,iBAAiB,GAAA0B,EAAA,GACfR,QAAQ,CAAClB,iBAAiB,cAAA0B,EAAA,cAAAA,EAAA,GAAIX,eAAe,CAACf,iBAAiB;UACjEE,gBAAgB,GAAAyB,EAAA,GACdT,QAAQ,CAAChB,gBAAgB,cAAAyB,EAAA,cAAAA,EAAA,GAAIZ,eAAe,CAACb,gBAAgB;UAC/DE,eAAe,GAAAwB,EAAA,GACbV,QAAQ,CAACd,eAAe,cAAAwB,EAAA,cAAAA,EAAA,GAAIb,eAAe,CAACX;SAC/C;QACDuC,yBAAyB,GAAG,IAAIzD,aAAA,CAAA4D,wBAAwB,CACtDD,YAAY,EACZP,wBAAwB,CACzB;;MAEH,IAAI,CAAClB,QAAQ,CAACb,KAAK,CAACmC,EAAE,EAAEC,yBAAyB,CAAC;MAClD,IAAI,CAACV,qBAAqB,EAAE;MAC5B,IAAI,CAACG,uBAAuB,EAAE;IAChC,CAAC,CAAC;EACJ;EACA;EACAF,sBAAsBA,CAACa,OAAuB,EAAExD,OAAY;IAC1D,IAAI,CAACiC,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACH,SAAS,CAACT,WAAW,CAACrB,OAAO,EAAGyD,YAAY,IAAI;MACnD,IAAI,CAACxB,iBAAiB,GAAG,KAAK;MAC9B,IAAI,IAAI,CAACF,kBAAkB,EAAE;QAC3B,IAAI,CAACC,qBAAqB,GAAGwB,OAAO;QACpC,IAAI,CAACZ,cAAc,GAAG5C,OAAO;OAC9B,MAAM;QACL,IAAI,CAAC6B,QAAQ,CAACc,sBAAsB,CAACa,OAAO,EAAEC,YAAY,CAAC;QAC3D,IAAI,CAACZ,uBAAuB,EAAE;;IAElC,CAAC,CAAC;EACJ;EACA;EACAxB,WAAWA,CAACrB,OAAY;IACtB,IAAI,CAAC2C,sBAAsB,CAAC,EAAE,EAAE3C,OAAO,CAAC;EAC1C;EACA0D,SAASA,CAAA;IACP,IAAI,CAAC7B,QAAQ,CAAC6B,SAAS,EAAE;EAC3B;EACAzC,SAASA,CAAA;IACP,IAAI,CAACa,SAAS,CAACb,SAAS,CAAC,MAAK;MAC5B,IAAI,IAAI,CAACc,kBAAkB,IAAI,IAAI,CAACE,iBAAiB,EAAE;QACrD,IAAI,CAACC,gBAAgB,GAAG,IAAI;OAC7B,MAAM;QACL,IAAI,CAACL,QAAQ,CAACZ,SAAS,EAAE;;IAE7B,CAAC,CAAC;EACJ;EACA0C,cAAcA,CAACC,WAA4B;IACzC,IAAI,CAAC/B,QAAQ,CAAC8B,cAAc,CAACC,WAAW,CAAC;EAC3C;;AAzIFzD,OAAA,CAAAyB,gBAAA,GAAAA,gBAAA;AA4IA,SAASiC,OAAOA,CAACC,OAAgB,EAAEC,IAAY,EAAEC,OAAoB;;EACnE,MAAMC,QAAQ,IAAA9B,EAAA,GAAG6B,OAAO,CAACC,QAAQ,cAAA9B,EAAA,cAAAA,EAAA,GAAI+B,QAAQ;EAC7C,MAAMC,IAAI,GAAGH,OAAO,CAACG,IAAI;EACzB,MAAMC,MAAM,IAAAhC,EAAA,GAAG4B,OAAO,CAACI,MAAM,cAAAhC,EAAA,cAAAA,EAAA,GAAI,IAAI;EACrC,MAAMiC,cAAc,GAAGL,OAAO,CAACM,eAAe;EAC9C,MAAMV,WAAW,GAAGI,OAAO,CAACJ,WAAW;EACvC,MAAMW,IAAI,GAAGT,OAAO,CAACU,UAAU,CAACT,IAAI,EAAEE,QAAQ,EAAEE,IAAI,EAAEC,MAAM,EAAEC,cAAc,CAAC;EAC7E,IAAIT,WAAW,EAAE;IACfW,IAAI,CAACZ,cAAc,CAACC,WAAW,CAAC;;EAElC,OAAOW,IAAI;AACb;AAEA;;;;AAIA,MAAME,oBAAoB;EACxB1E,YACYwE,IAAU;EACpB;EACUG,gBAAkD;IAFlD,KAAAH,IAAI,GAAJA,IAAI;IAEJ,KAAAG,gBAAgB,GAAhBA,gBAAgB;EACzB;EACHnC,gBAAgBA,CAAChC,MAAc,EAAEiC,OAAe;IAC9C,IAAI,CAAC+B,IAAI,CAAChC,gBAAgB,CAAChC,MAAM,EAAEiC,OAAO,CAAC;EAC7C;EACAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAAC8B,IAAI,CAAC9B,OAAO,EAAE;EAC5B;EACAkB,cAAcA,CAACC,WAA4B;IACzC,IAAI,CAACW,IAAI,CAACZ,cAAc,CAACC,WAAW,CAAC;EACvC;EACA;EACAjB,sBAAsBA,CAACa,OAAuB,EAAExD,OAAY;IAC1D,IAAI2E,UAAkB;IACtB,IAAI;MACFA,UAAU,GAAG,IAAI,CAACD,gBAAgB,CAACE,gBAAgB,CAAC5E,OAAO,CAAC;KAC7D,CAAC,OAAO6E,CAAC,EAAE;MACV,IAAI,CAACN,IAAI,CAAChC,gBAAgB,CACxB3C,WAAA,CAAAkF,MAAM,CAACC,QAAQ,EACf,0CAA0CF,CAAC,CAAC7E,OAAO,EAAE,CACtD;MACD;;IAEF,IAAI,CAACuE,IAAI,CAAC5B,sBAAsB,CAACa,OAAO,EAAEmB,UAAU,CAAC;EACvD;EACA;EACAtD,WAAWA,CAACrB,OAAY;IACtB,IAAI,CAAC2C,sBAAsB,CAAC,EAAE,EAAE3C,OAAO,CAAC;EAC1C;EACAgB,KAAKA,CACHX,QAAkB,EAClByC,oBAAoD;IAEpD,IAAIkC,SAAS,GAAwB,IAAI;IACzC,IAAI,CAACT,IAAI,CAACvD,KAAK,CAACX,QAAQ,EAAE;MACxBI,iBAAiB,EAAGJ,QAAQ,IAAI;;QAC9B,CAAA8B,EAAA,GAAAW,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAErC,iBAAiB,cAAA0B,EAAA,uBAAAA,EAAA,CAAAoC,IAAA,CAAvCzB,oBAAoB,EAAsBzC,QAAQ;MACpD,CAAC;MACDM,gBAAgB,EAAGX,OAAO,IAAI;;QAC5B;QACA,IAAIiF,YAAiB;QACrB,IAAI;UACFA,YAAY,GAAG,IAAI,CAACP,gBAAgB,CAACQ,mBAAmB,CAAClF,OAAO,CAAC;SAClE,CAAC,OAAO6E,CAAC,EAAE;UACVG,SAAS,GAAG;YACVG,IAAI,EAAEvF,WAAA,CAAAkF,MAAM,CAACC,QAAQ;YACrBvC,OAAO,EAAE,mCAAmCqC,CAAC,CAAC7E,OAAO,EAAE;YACvDK,QAAQ,EAAE,IAAIZ,UAAA,CAAA2F,QAAQ;WACvB;UACD,IAAI,CAACb,IAAI,CAAChC,gBAAgB,CAACyC,SAAS,CAACG,IAAI,EAAEH,SAAS,CAACxC,OAAO,CAAC;UAC7D;;QAEF,CAAAL,EAAA,GAAAW,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEnC,gBAAgB,cAAAwB,EAAA,uBAAAA,EAAA,CAAAoC,IAAA,CAAtCzB,oBAAoB,EAAqBmC,YAAY;MACvD,CAAC;MACDpE,eAAe,EAAGN,MAAM,IAAI;;QAC1B,IAAIyE,SAAS,EAAE;UACb,CAAA7C,EAAA,GAAAW,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEjC,eAAe,cAAAsB,EAAA,uBAAAA,EAAA,CAAAoC,IAAA,CAArCzB,oBAAoB,EAAoBkC,SAAS;SAClD,MAAM;UACL,CAAA5C,EAAA,GAAAU,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEjC,eAAe,cAAAuB,EAAA,uBAAAA,EAAA,CAAAmC,IAAA,CAArCzB,oBAAoB,EAAoBvC,MAAM;;MAElD;KACD,CAAC;EACJ;EACAmD,SAASA,CAAA;IACP,IAAI,CAACa,IAAI,CAACb,SAAS,EAAE;EACvB;EACAzC,SAASA,CAAA;IACP,IAAI,CAACsD,IAAI,CAACtD,SAAS,EAAE;EACvB;;AAGF;;;;AAIA,MAAMoE,yBACJ,SAAQZ,oBAAoB;EAE5B;EACA1E,YAAYwE,IAAU,EAAEG,gBAAkD;IACxE,KAAK,CAACH,IAAI,EAAEG,gBAAgB,CAAC;EAC/B;EACA1D,KAAKA,CAACX,QAAkB,EAAEsB,QAAwC;;IAChE,IAAI2D,eAAe,GAAG,KAAK;IAC3B,MAAMC,eAAe,GAAyB;MAC5C9E,iBAAiB,GAAA2B,EAAA,IAAAD,EAAA,GACfR,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAElB,iBAAiB,cAAA0B,EAAA,uBAAAA,EAAA,CAAEa,IAAI,CAACrB,QAAQ,eAAAS,EAAA,cAAAA,EAAA,GAAO/B,QAAQ,IAAI,CAAE,CAAE;MACnE;MACAM,gBAAgB,EAAGX,OAAY,IAAI;;QACjCsF,eAAe,GAAG,IAAI;QACtB,CAAAnD,EAAA,GAAAR,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEhB,gBAAgB,cAAAwB,EAAA,uBAAAA,EAAA,CAAAoC,IAAA,CAA1B5C,QAAQ,EAAqB3B,OAAO;MACtC,CAAC;MACDa,eAAe,EAAGN,MAAoB,IAAI;;QACxC,IAAI,CAAC+E,eAAe,EAAE;UACpB,CAAAnD,EAAA,GAAAR,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEhB,gBAAgB,cAAAwB,EAAA,uBAAAA,EAAA,CAAAoC,IAAA,CAA1B5C,QAAQ,EAAqB,IAAI;;QAEnC,CAAAS,EAAA,GAAAT,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEd,eAAe,cAAAuB,EAAA,uBAAAA,EAAA,CAAAmC,IAAA,CAAzB5C,QAAQ,EAAoBpB,MAAM;MACpC;KACD;IACD,KAAK,CAACS,KAAK,CAACX,QAAQ,EAAEkF,eAAe,CAAC;IACtC,IAAI,CAAChB,IAAI,CAACb,SAAS,EAAE;EACvB;;AAGF;;;;AAIA,MAAM8B,6BACJ,SAAQf,oBAAoB;AAG9B,SAASgB,yBAAyBA,CAChC3B,OAAgB,EAChBE,OAA2B;AAC3B;AACAU,gBAAkD;EAElD,MAAMH,IAAI,GAAGV,OAAO,CAACC,OAAO,EAAEY,gBAAgB,CAACX,IAAI,EAAEC,OAAO,CAAC;EAC7D,IAAIU,gBAAgB,CAACgB,cAAc,EAAE;IACnC,OAAO,IAAIF,6BAA6B,CAACjB,IAAI,EAAEG,gBAAgB,CAAC;GACjE,MAAM;IACL,OAAO,IAAIW,yBAAyB,CAACd,IAAI,EAAEG,gBAAgB,CAAC;;AAEhE;AAsBA,SAAgBiB,mBAAmBA,CACjCC,eAAqC;AACrC;AACAlB,gBAAkD,EAClDV,OAAoB,EACpBF,OAAgB;EAEhB,IACE8B,eAAe,CAACC,kBAAkB,CAACC,MAAM,GAAG,CAAC,IAC7CF,eAAe,CAACG,0BAA0B,CAACD,MAAM,GAAG,CAAC,EACrD;IACA,MAAM,IAAIjG,6BAA6B,CACrC,qEAAqE,GACnE,0DAA0D,CAC7D;;EAEH,IACE+F,eAAe,CAACI,gBAAgB,CAACF,MAAM,GAAG,CAAC,IAC3CF,eAAe,CAACK,wBAAwB,CAACH,MAAM,GAAG,CAAC,EACnD;IACA,MAAM,IAAIjG,6BAA6B,CACrC,kEAAkE,GAChE,wCAAwC,CAC3C;;EAEH,IAAIqG,YAAY,GAAkB,EAAE;EACpC;EACA,IACEN,eAAe,CAACI,gBAAgB,CAACF,MAAM,GAAG,CAAC,IAC3CF,eAAe,CAACK,wBAAwB,CAACH,MAAM,GAAG,CAAC,EACnD;IACAI,YAAY,GAAI,EAAoB,CACjCC,MAAM,CACLP,eAAe,CAACI,gBAAgB,EAChCJ,eAAe,CAACK,wBAAwB,CAACG,GAAG,CAAEC,QAAQ,IACpDA,QAAQ,CAAC3B,gBAAgB,CAAC,CAC3B,CACF,CACA4B,MAAM,CAAEC,WAAW,IAAKA,WAAW,CAAC;IACvC;GACD,MAAM;IACLL,YAAY,GAAI,EAAoB,CACjCC,MAAM,CACLP,eAAe,CAACC,kBAAkB,EAClCD,eAAe,CAACG,0BAA0B,CAACK,GAAG,CAAEC,QAAQ,IACtDA,QAAQ,CAAC3B,gBAAgB,CAAC,CAC3B,CACF,CACA4B,MAAM,CAAEC,WAAW,IAAKA,WAAW,CAAC;IACvC;;;EAEF,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAE1C,OAAO,EAAE;IACpD2C,iBAAiB,EAAEjC;GACpB,CAAC;EACF;;;;;;;EAOA,MAAMb,OAAO,GAAaqC,YAAY,CAACU,WAAW,CAChD,CAAC/E,QAAkB,EAAEgF,eAA4B,KAAI;IACnD,OAAQC,cAAc,IAAKD,eAAe,CAACC,cAAc,EAAEjF,QAAQ,CAAC;EACtE,CAAC,EACAkF,YAAgC,IAC/BtB,yBAAyB,CAAC3B,OAAO,EAAEiD,YAAY,EAAErC,gBAAgB,CAAC,CACrE;EACD,OAAOb,OAAO,CAAC2C,kBAAkB,CAAC;AACpC;AArEArG,OAAA,CAAAwF,mBAAA,GAAAA,mBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}