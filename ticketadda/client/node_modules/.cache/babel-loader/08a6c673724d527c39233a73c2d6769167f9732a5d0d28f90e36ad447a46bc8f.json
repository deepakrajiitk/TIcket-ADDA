{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'DiscoveryService';\nconst {\n  checkParameter,\n  getLogger\n} = require('./Utils.js');\nconst ServiceAction = require('./ServiceAction.js');\nconst DiscoveryHandler = require('./DiscoveryHandler.js');\nconst logger = getLogger(TYPE);\nconst fabproto6 = require('fabric-protos');\nconst {\n  SYSTEMCHAINCODES\n} = require('./Endorser.js');\nconst DiscoveryResultsProcessor = require('./DiscoveryResultsProcessor.js');\n\n/**\n * The DiscoveryService class represents a peer in the target fabric network that\n * is providing the discovery service for the channel.\n *\n * @class\n * @extends ServiceAction\n */\nclass DiscoveryService extends ServiceAction {\n  /**\n   * Construct a DiscoveryService object with the name.\n   * Use the connect method with options to establish a\n   * connection with the fabric network endpoint.\n   *\n   * @param {string} name - The name of this discovery peer\n   * @param {Client} client - The client instance\n   * @param {Channel} channel\n   * @returns {DiscoveryService} The DiscoveryService instance.\n   */\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('name');\n    let channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('channel');\n    logger.debug(`${TYPE}.constructor[${name}] - start `);\n    super(name);\n    this.channel = channel;\n    this.client = channel.client;\n    this.type = TYPE;\n    this.refreshAge = 5 * 60 * 1000; // 5 minutes default\n    this.refreshRunning = false;\n    this.discoveryResults = null;\n    this.asLocalhost = false;\n    this.currentTarget = null;\n    this.targets = null; // will be used when targets are not provided\n  }\n\n  /**\n   * Use this method to set the ServiceEndpoint for this ServiceAction class\n   * The {@link Discoverer} a ServiceEndpoint must be connected before making\n   * this assignment.\n   * @property {Discoverer[]} targets - The connected Discoverer instances to\n   *  be used when no targets are provided on the send.\n   */\n  setTargets() {\n    let targets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('targets');\n    const method = `setTargets[${this.name}]`;\n    logger.debug('%s - start', method);\n    if (!Array.isArray(targets)) {\n      throw Error('targets parameter is not an array');\n    }\n    if (targets.length < 1) {\n      throw Error('No targets provided');\n    }\n    for (const discoverer of targets) {\n      if (discoverer.isConnectable()) {\n        logger.debug('%s - target is connectable%s', method, discoverer.name);\n      } else {\n        throw Error(`Discoverer ${discoverer.name} is not connectable`);\n      }\n    }\n    // must be all targets are connected\n    this.targets = targets;\n    return this;\n  }\n\n  /**\n   * Use this method to get a new handler that will use this\n   * instance of the DiscoveryService service.\n   *\n   * @returns {DiscoveryHandler} Discovery handler\n   */\n  newHandler() {\n    const method = `newHandler[${this.name}]`;\n    logger.debug(`${method} - start`);\n    return new DiscoveryHandler(this);\n  }\n\n  /**\n   * @typedef {Object} BuildDiscoveryRequest - This Discovery request\n   *  is a GRPC object to be signed and sent to the Discovery service\n   *  of the Peer. The request will be based on either the proposal\n   *  or the interests parameters. This request must be signed before\n   *  sending to the peer.\n   * @property {Endorsement} [endorsement] - Optional. Include the endorsement\n   *  instance to build the discovery request based on the proposal.\n   *  This will get the discovery interest (chaincode names, collections and \"no private reads\")\n   *  from the endorsement instance. Use the {@link Proposal#addCollectionInterest}\n   *  to add collections to the endorsement's chaincode.\n   *  Use the {@link Proposal#setNoPrivateReads} to set the proposals \"no private reads\"\n   *  setting of the discovery interest.\n   *  Use the {@link Proposal#addCollectionInterest} to add chaincodes,\n   *  collections, and no private reads that will be used to get an endorsement plan\n   *  from the peer's discovery service.\n   * @property {DiscoveryChaincode} [interest] - Optional. An\n   *  array of {@link DiscoveryChaincodeInterest} that have chaincodes, collections,\n   *  and \"no private reads\" to help the peer's discovery service calculate the\n   *  endorsement plan.\n   * @example <caption>\"single chaincode\"</caption>\n   *  [\n   *     { name: \"mychaincode\"}\n   *  ]\n   * @example <caption>\"chaincode to chaincode\"</caption>\n   *  [\n   *      { name: \"mychaincode\"}, { name: \"myotherchaincode\"}\n   *  ]\n   * @example <caption>\"single chaincode with a collection\"</caption>\n   *  [\n   *     { name: \"mychaincode\", collectionNames: [\"mycollection\"] }\n   *  ]\n   * @example <caption>\"single chaincode with a collection allowing no private data reads\"</caption>\n   *  [\n   *     { name: \"mychaincode\", collectionNames: [\"mycollection\"], noPrivateReads: true }\n   *  ]\n   * @example <caption>\"chaincode to chaincode with a collection\"</caption>\n   *  [\n   *     { name: \"mychaincode\", collectionNames: [\"mycollection\"] },\n   *     { name: \"myotherchaincode\", collectionNames: [\"mycollection\"] }}\n   *  ]\n   * @example <caption>\"chaincode to chaincode with collections\"</caption>\n   *  [\n   *     { name: \"mychaincode\", collectionNames: [\"mycollection\", \"myothercollection\"] },\n   *     { name: \"myotherchaincode\", collectionNames: [\"mycollection\", \"myothercollection\"] }}\n   *  ]\n   */\n\n  /**\n   * @typedef {Object} DiscoveryChaincodesInterest\n   * @property {DiscoveryChaincodeCall[]} interest - An array of\n   *  {@link DiscoveryChaincodeCall} objects.\n   */\n\n  /**\n   * @typedef {Object} DiscoveryChaincodeCall\n   * @property {string} name - The name of the chaincode\n   * @property {string[]} [collectionNames] - The names of the related collections\n   * @property {boolean} [noPrivateReads] - Indicates we do not need to read from private data\n   */\n\n  /**\n   * Use this method to build a discovery request.\n   *\n   * @param {IdentityContext} idContext - Contains the {@link User} object\n   * needed to build this request.\n   * @param {BuildDiscoveryRequest} request - The discovery settings of the request.\n   */\n  build() {\n    let idContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('idContext');\n    let request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = `build[${this.name}]`;\n    logger.debug(`${method} - start`);\n\n    // always get the config, we need the MSPs, do not need local\n    const {\n      config = true,\n      local = false,\n      interest,\n      endorsement\n    } = request;\n    this._reset();\n    const authentication = fabproto6.discovery.AuthInfo.create({\n      client_identity: idContext.serializeIdentity(),\n      client_tls_cert_hash: this.client.getClientCertHash()\n    });\n    let fullproposalInterest = null;\n    if (endorsement) {\n      fullproposalInterest = endorsement.buildProposalInterest();\n      logger.debug('%s - endorsement built interest: %j', method, fullproposalInterest);\n    } else if (interest) {\n      fullproposalInterest = interest;\n      logger.debug('%s - request interest: %j', method, fullproposalInterest);\n    }\n\n    // remove all legacy non endorsement policy system chaincodes\n    let proposalInterest = null;\n    if (fullproposalInterest) {\n      proposalInterest = [];\n      for (const fullinterest of fullproposalInterest) {\n        if (SYSTEMCHAINCODES.includes(fullinterest.name)) {\n          logger.debug('%s - not adding %s interest', method, fullinterest.name);\n        } else {\n          proposalInterest.push(fullinterest);\n        }\n      }\n    }\n\n    // be sure to add all entries to this array before setting into the grpc object\n    const queries = [];\n    if (config) {\n      const configQuery = fabproto6.discovery.Query.create({\n        channel: this.channel.name,\n        config_query: fabproto6.discovery.ConfigQuery.create()\n      });\n      logger.debug(`${method} - adding config query`);\n      queries.push(configQuery);\n      const membershipQuery = fabproto6.discovery.Query.create({\n        channel: this.channel.name,\n        peer_query: fabproto6.discovery.PeerMembershipQuery.create()\n      });\n      logger.debug(`${method} - adding peer membership query`);\n      queries.push(membershipQuery);\n    }\n    if (local) {\n      const localQuery = fabproto6.discovery.Query.create({\n        local_peers: fabproto6.discovery.LocalPeerQuery.create()\n      });\n      logger.debug(`${method} - adding local peers query`);\n      queries.push(localQuery);\n    }\n\n    // add a discovery chaincode query to get endorsement plans\n    if (proposalInterest && proposalInterest.length > 0) {\n      const interests = [];\n      const chaincodeInterest = this._buildProtoChaincodeInterest(proposalInterest);\n      interests.push(chaincodeInterest);\n      const ccQuery = fabproto6.discovery.ChaincodeQuery.create({\n        interests: interests\n      });\n      const query = fabproto6.discovery.Query.create({\n        channel: this.channel.name,\n        cc_query: ccQuery\n      });\n      logger.debug('%s - adding chaincodes/collections query', method);\n      queries.push(query);\n    } else {\n      logger.debug('%s - NOT adding chaincodes/collections query', method);\n    }\n    if (queries.length === 0) {\n      throw Error('No discovery interest provided');\n    }\n    this._action.request = fabproto6.discovery.Request.create({\n      queries: queries,\n      authentication: authentication\n    });\n    this._payload = fabproto6.discovery.Request.encode(this._action.request).finish();\n    logger.debug('%s - end', method);\n    return this._payload;\n  }\n\n  /**\n   * @typedef {Object} DiscoverRequest\n   * @property {boolean} [asLocalhost] - Optional. When discovery is running in a\n   *  virtual environment, the host name of peers and orderers created by this\n   *  service may have to converted to localhost for connections to be established.\n   * @property {number} [requestTimeout] - Optional. The request timeout\n   * @property {number} [refreshAge] - Optional. The milliseconds before the\n   *  discovery results will be refreshed automatically. When the {@link Discovery#getDiscoveryResults}\n   *  is called with refresh = true and the age of the discovery results\n   *  is older then 'refreshAge' the current signed request will be sent\n   *  to the peer's discovery service.\n   *  Default: 5 minutes.\n   * @property {Discoverer[]} targets - Optional. An array of {@link Discoverer}\n   *  instances. When not included the assigned discoverer will be used. The\n   *  discoverer may be assigned anytime before the {@link DiscoveryService#send} is called.\n   */\n\n  /**\n   * Send a signed transaction proposal to peer(s)\n   *\n   * @param {DiscoverRequest} request\n   * @returns {DiscoveryResults}\n   */\n  async send() {\n    let request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const method = `send[${this.name}]`;\n    logger.debug(`${method} - start`);\n    const {\n      requestTimeout,\n      asLocalhost,\n      refreshAge,\n      targets\n    } = request;\n    if (typeof asLocalhost === 'boolean') {\n      this.asLocalhost = asLocalhost;\n    }\n    this.refreshAge = refreshAge;\n    this.requestTimeout = requestTimeout;\n    if (targets && Array.isArray(targets) && targets.length > 0) {\n      this.targets = targets;\n    } else if (this.targets) {\n      logger.debug('%s - using preassigned targets', method);\n    } else {\n      checkParameter('targets');\n    }\n    const signedEnvelope = this.getSignedEnvelope();\n    let response;\n    for (const target of this.targets) {\n      logger.debug(`${method} - about to discover on ${target.endpoint.url}`);\n      try {\n        const isConnected = await target.checkConnection();\n        if (isConnected) {\n          response = await target.sendDiscovery(signedEnvelope, this.requestTimeout);\n          this.currentTarget = target;\n          break;\n        }\n      } catch (error) {\n        response = error;\n      }\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n\n    // -----\n    logger.debug(`${method} - processing discovery response`);\n    if (!response || !response.results) {\n      logger.error('%s - no discovery results', method);\n      throw new Error('DiscoveryService has failed to return results');\n    }\n    logger.debug(`${method} - parse discovery response.results`);\n    const processor = new DiscoveryResultsProcessor(this, response.results);\n    const results = await processor.parseDiscoveryResults();\n    results.timestamp = currentTimestamp();\n    this.discoveryResults = results;\n    return results;\n  }\n\n  /**\n   * Get the discovered results. The results are from the discovery service\n   * of the Peer and based on the discovery request of {@link DiscoveryService#BuildDiscoveryRequest}\n   * that was sent to the Peer with {@link Discover#discover}.\n   * @param {boolean} [refresh] - Optional. Refresh the discovery results if\n   *  results are older then the refresh age.\n   */\n  async getDiscoveryResults(refresh) {\n    const method = `getDiscoveryResults[${this.name}]`;\n    logger.debug(`${method} - start`);\n    if (!this.discoveryResults) {\n      throw Error('No discovery results found');\n    }\n    if (refresh && !this.refreshRunning && this._isRefreshRequired()) {\n      logger.debug(`${method} - will refresh`);\n      this.refreshRunning = true;\n      try {\n        await this.send({\n          asLocalhost: this.asLocalhost,\n          requestTimeout: this.requestTimeout,\n          targets: this.targets\n        });\n      } finally {\n        this.refreshRunning = false;\n      }\n    } else {\n      logger.debug(`${method} - not refreshing`);\n    }\n    return this.discoveryResults;\n  }\n  _isRefreshRequired() {\n    const resultsAge = currentTimestamp() - this.discoveryResults.timestamp;\n    return resultsAge > this.refreshAge;\n  }\n\n  /**\n   * Indicates if this discovery service has retreived results\n   */\n  hasDiscoveryResults() {\n    const method = `hasDiscoveryResults[${this.name}]`;\n    logger.debug(`${method} - start`);\n    return !!this.discoveryResults;\n  }\n  _buildUrl() {\n    let hostname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('hostname');\n    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('port');\n    const method = `_buildUrl[${this.name}]`;\n    logger.debug(`${method} - start`);\n    let t_hostname = hostname;\n    // endpoints may be running in containers on the local system\n    if (this.asLocalhost) {\n      t_hostname = 'localhost';\n    }\n\n    // If we connect to a discovery peer over TLS, any endpoints returned by\n    // discovery should also use TLS.\n    let protocol = null;\n    let isTLS = true;\n    if (this.currentTarget) {\n      isTLS = this.currentTarget.endpoint.isTLS();\n    }\n    protocol = isTLS ? 'grpcs' : 'grpc';\n    // but if not, use the following to override\n    const overrideProtocol = this.client.getConfigSetting('discovery-override-protocol');\n    if (overrideProtocol) {\n      protocol = overrideProtocol;\n    }\n    return `${protocol}://${t_hostname}:${port}`;\n  }\n\n  /* internal method\n   *  Takes an array of {@link DiscoveryChaincodeCall} that represent the\n   *  chaincodes and associated collections to build an interest.\n   *  The interest becomes part of the query object needed by the discovery\n   *  service to calculate the endorsement plan for an invocation.\n   */\n  _buildProtoChaincodeInterest() {\n    let interest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    logger.debug(`_buildProtoChaincodeInterest[${this.name}] - start`);\n    const chaincodeCalls = [];\n    for (const chaincode of interest) {\n      const chaincodeCall = fabproto6.discovery.ChaincodeCall.create();\n      if (typeof chaincode.name === 'string') {\n        chaincodeCall.name = chaincode.name;\n        if (chaincode.noPrivateReads) {\n          chaincodeCall.no_private_reads = chaincode.noPrivateReads;\n        }\n        // support both names\n        if (chaincode.collection_names) {\n          _getCollectionNames(chaincode.collection_names, chaincodeCall);\n        } else if (chaincode.collectionNames) {\n          _getCollectionNames(chaincode.collectionNames, chaincodeCall);\n        }\n        chaincodeCalls.push(chaincodeCall);\n      } else {\n        throw Error('Chaincode name must be a string');\n      }\n    }\n    const chaincodeInterest = fabproto6.discovery.ChaincodeInterest.create({\n      chaincodes: chaincodeCalls\n    });\n    return chaincodeInterest;\n  }\n\n  /**\n   * Close the connection of the discovery service.\n   */\n  close() {\n    const method = `close[${this.name}]`;\n    logger.debug(`${method} - start`);\n    if (this.targets) {\n      for (const target of this.targets) {\n        target.disconnect();\n      }\n    }\n  }\n\n  /**\n   * return a printable representation of this object\n   */\n  toString() {\n    return `DiscoveryService: {name: ${this.name}, channel: ${this.channel.name}}`;\n  }\n}\nfunction _getCollectionNames(names, chaincodeCall) {\n  if (Array.isArray(names)) {\n    const collection_names = [];\n    names.map(name => {\n      if (typeof name === 'string') {\n        collection_names.push(name);\n      } else {\n        throw Error('The collection name must be a string');\n      }\n    });\n    // this collection_names must be in snake case as it will\n    // be used by the gRPC create message\n    chaincodeCall.collection_names = collection_names;\n  } else {\n    throw Error('Collection names must be an array of strings');\n  }\n}\nfunction currentTimestamp() {\n  return new Date().getTime();\n}\nmodule.exports = DiscoveryService;","map":{"version":3,"names":["TYPE","checkParameter","getLogger","require","ServiceAction","DiscoveryHandler","logger","fabproto6","SYSTEMCHAINCODES","DiscoveryResultsProcessor","DiscoveryService","constructor","name","arguments","length","undefined","channel","debug","client","type","refreshAge","refreshRunning","discoveryResults","asLocalhost","currentTarget","targets","setTargets","method","Array","isArray","Error","discoverer","isConnectable","newHandler","build","idContext","request","config","local","interest","endorsement","_reset","authentication","discovery","AuthInfo","create","client_identity","serializeIdentity","client_tls_cert_hash","getClientCertHash","fullproposalInterest","buildProposalInterest","proposalInterest","fullinterest","includes","push","queries","configQuery","Query","config_query","ConfigQuery","membershipQuery","peer_query","PeerMembershipQuery","localQuery","local_peers","LocalPeerQuery","interests","chaincodeInterest","_buildProtoChaincodeInterest","ccQuery","ChaincodeQuery","query","cc_query","_action","Request","_payload","encode","finish","send","requestTimeout","signedEnvelope","getSignedEnvelope","response","target","endpoint","url","isConnected","checkConnection","sendDiscovery","error","results","processor","parseDiscoveryResults","timestamp","currentTimestamp","getDiscoveryResults","refresh","_isRefreshRequired","resultsAge","hasDiscoveryResults","_buildUrl","hostname","port","t_hostname","protocol","isTLS","overrideProtocol","getConfigSetting","chaincodeCalls","chaincode","chaincodeCall","ChaincodeCall","noPrivateReads","no_private_reads","collection_names","_getCollectionNames","collectionNames","ChaincodeInterest","chaincodes","close","disconnect","toString","names","map","Date","getTime","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/DiscoveryService.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'DiscoveryService';\n\nconst {checkParameter, getLogger} = require('./Utils.js');\nconst ServiceAction = require('./ServiceAction.js');\nconst DiscoveryHandler = require('./DiscoveryHandler.js');\n\nconst logger = getLogger(TYPE);\n\nconst fabproto6 = require('fabric-protos');\nconst {SYSTEMCHAINCODES} = require('./Endorser.js');\nconst DiscoveryResultsProcessor = require('./DiscoveryResultsProcessor.js');\n\n/**\n * The DiscoveryService class represents a peer in the target fabric network that\n * is providing the discovery service for the channel.\n *\n * @class\n * @extends ServiceAction\n */\nclass DiscoveryService extends ServiceAction {\n\n\t/**\n\t * Construct a DiscoveryService object with the name.\n\t * Use the connect method with options to establish a\n\t * connection with the fabric network endpoint.\n\t *\n\t * @param {string} name - The name of this discovery peer\n\t * @param {Client} client - The client instance\n\t * @param {Channel} channel\n\t * @returns {DiscoveryService} The DiscoveryService instance.\n\t */\n\tconstructor(name = checkParameter('name'), channel = checkParameter('channel')) {\n\t\tlogger.debug(`${TYPE}.constructor[${name}] - start `);\n\t\tsuper(name);\n\t\tthis.channel = channel;\n\t\tthis.client = channel.client;\n\t\tthis.type = TYPE;\n\t\tthis.refreshAge = 5 * 60 * 1000; // 5 minutes default\n\t\tthis.refreshRunning = false;\n\n\t\tthis.discoveryResults = null;\n\t\tthis.asLocalhost = false;\n\n\t\tthis.currentTarget = null;\n\t\tthis.targets = null; // will be used when targets are not provided\n\n\t}\n\n\t/**\n\t * Use this method to set the ServiceEndpoint for this ServiceAction class\n\t * The {@link Discoverer} a ServiceEndpoint must be connected before making\n\t * this assignment.\n\t * @property {Discoverer[]} targets - The connected Discoverer instances to\n\t *  be used when no targets are provided on the send.\n\t */\n\tsetTargets(targets = checkParameter('targets')) {\n\t\tconst method = `setTargets[${this.name}]`;\n\t\tlogger.debug('%s - start', method);\n\n\t\tif (!Array.isArray(targets)) {\n\t\t\tthrow Error('targets parameter is not an array');\n\t\t}\n\n\t\tif (targets.length < 1) {\n\t\t\tthrow Error('No targets provided');\n\t\t}\n\n\t\tfor (const discoverer of targets) {\n\t\t\tif (discoverer.isConnectable()) {\n\t\t\t\tlogger.debug('%s - target is connectable%s', method, discoverer.name);\n\t\t\t} else {\n\t\t\t\tthrow Error(`Discoverer ${discoverer.name} is not connectable`);\n\t\t\t}\n\t\t}\n\t\t// must be all targets are connected\n\t\tthis.targets = targets;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use this method to get a new handler that will use this\n\t * instance of the DiscoveryService service.\n\t *\n\t * @returns {DiscoveryHandler} Discovery handler\n\t */\n\tnewHandler() {\n\t\tconst method = `newHandler[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\treturn new DiscoveryHandler(this);\n\t}\n\n\t/**\n\t * @typedef {Object} BuildDiscoveryRequest - This Discovery request\n\t *  is a GRPC object to be signed and sent to the Discovery service\n\t *  of the Peer. The request will be based on either the proposal\n\t *  or the interests parameters. This request must be signed before\n\t *  sending to the peer.\n\t * @property {Endorsement} [endorsement] - Optional. Include the endorsement\n\t *  instance to build the discovery request based on the proposal.\n\t *  This will get the discovery interest (chaincode names, collections and \"no private reads\")\n\t *  from the endorsement instance. Use the {@link Proposal#addCollectionInterest}\n\t *  to add collections to the endorsement's chaincode.\n\t *  Use the {@link Proposal#setNoPrivateReads} to set the proposals \"no private reads\"\n\t *  setting of the discovery interest.\n\t *  Use the {@link Proposal#addCollectionInterest} to add chaincodes,\n\t *  collections, and no private reads that will be used to get an endorsement plan\n\t *  from the peer's discovery service.\n\t * @property {DiscoveryChaincode} [interest] - Optional. An\n\t *  array of {@link DiscoveryChaincodeInterest} that have chaincodes, collections,\n\t *  and \"no private reads\" to help the peer's discovery service calculate the\n\t *  endorsement plan.\n\t * @example <caption>\"single chaincode\"</caption>\n\t *  [\n\t *     { name: \"mychaincode\"}\n\t *  ]\n\t * @example <caption>\"chaincode to chaincode\"</caption>\n\t *  [\n\t *      { name: \"mychaincode\"}, { name: \"myotherchaincode\"}\n\t *  ]\n\t * @example <caption>\"single chaincode with a collection\"</caption>\n\t *  [\n\t *     { name: \"mychaincode\", collectionNames: [\"mycollection\"] }\n\t *  ]\n\t * @example <caption>\"single chaincode with a collection allowing no private data reads\"</caption>\n\t *  [\n\t *     { name: \"mychaincode\", collectionNames: [\"mycollection\"], noPrivateReads: true }\n\t *  ]\n\t * @example <caption>\"chaincode to chaincode with a collection\"</caption>\n\t *  [\n\t *     { name: \"mychaincode\", collectionNames: [\"mycollection\"] },\n\t *     { name: \"myotherchaincode\", collectionNames: [\"mycollection\"] }}\n\t *  ]\n\t * @example <caption>\"chaincode to chaincode with collections\"</caption>\n\t *  [\n\t *     { name: \"mychaincode\", collectionNames: [\"mycollection\", \"myothercollection\"] },\n\t *     { name: \"myotherchaincode\", collectionNames: [\"mycollection\", \"myothercollection\"] }}\n\t *  ]\n\t */\n\n\t/**\n\t * @typedef {Object} DiscoveryChaincodesInterest\n\t * @property {DiscoveryChaincodeCall[]} interest - An array of\n\t *  {@link DiscoveryChaincodeCall} objects.\n\t */\n\n\t/**\n\t * @typedef {Object} DiscoveryChaincodeCall\n\t * @property {string} name - The name of the chaincode\n\t * @property {string[]} [collectionNames] - The names of the related collections\n\t * @property {boolean} [noPrivateReads] - Indicates we do not need to read from private data\n\t */\n\n\t/**\n\t * Use this method to build a discovery request.\n\t *\n\t * @param {IdentityContext} idContext - Contains the {@link User} object\n\t * needed to build this request.\n\t * @param {BuildDiscoveryRequest} request - The discovery settings of the request.\n\t */\n\tbuild(idContext = checkParameter('idContext'), request = {}) {\n\t\tconst method = `build[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\t// always get the config, we need the MSPs, do not need local\n\t\tconst {config = true, local = false, interest, endorsement} = request;\n\t\tthis._reset();\n\n\t\tconst authentication = fabproto6.discovery.AuthInfo.create({\n\t\t\tclient_identity: idContext.serializeIdentity(),\n\t\t\tclient_tls_cert_hash: this.client.getClientCertHash(),\n\t\t});\n\n\t\tlet fullproposalInterest = null;\n\n\t\tif (endorsement) {\n\t\t\tfullproposalInterest = endorsement.buildProposalInterest();\n\t\t\tlogger.debug('%s - endorsement built interest: %j', method, fullproposalInterest);\n\t\t} else if (interest) {\n\t\t\tfullproposalInterest = interest;\n\t\t\tlogger.debug('%s - request interest: %j', method, fullproposalInterest);\n\t\t}\n\n\t\t// remove all legacy non endorsement policy system chaincodes\n\t\tlet proposalInterest = null;\n\t\tif (fullproposalInterest) {\n\t\t\tproposalInterest = [];\n\t\t\tfor (const fullinterest of fullproposalInterest) {\n\t\t\t\tif (SYSTEMCHAINCODES.includes(fullinterest.name)) {\n\t\t\t\t\tlogger.debug('%s - not adding %s interest', method, fullinterest.name);\n\t\t\t\t} else {\n\t\t\t\t\tproposalInterest.push(fullinterest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// be sure to add all entries to this array before setting into the grpc object\n\t\tconst queries = [];\n\n\t\tif (config) {\n\t\t\tconst configQuery = fabproto6.discovery.Query.create({\n\t\t\t\tchannel: this.channel.name,\n\t\t\t\tconfig_query: fabproto6.discovery.ConfigQuery.create()\n\t\t\t});\n\t\t\tlogger.debug(`${method} - adding config query`);\n\t\t\tqueries.push(configQuery);\n\n\t\t\tconst membershipQuery = fabproto6.discovery.Query.create({\n\t\t\t\tchannel: this.channel.name,\n\t\t\t\tpeer_query: fabproto6.discovery.PeerMembershipQuery.create()\n\t\t\t});\n\t\t\tlogger.debug(`${method} - adding peer membership query`);\n\t\t\tqueries.push(membershipQuery);\n\t\t}\n\n\t\tif (local) {\n\t\t\tconst localQuery = fabproto6.discovery.Query.create({\n\t\t\t\tlocal_peers: fabproto6.discovery.LocalPeerQuery.create()\n\t\t\t});\n\t\t\tlogger.debug(`${method} - adding local peers query`);\n\t\t\tqueries.push(localQuery);\n\t\t}\n\n\t\t// add a discovery chaincode query to get endorsement plans\n\t\tif (proposalInterest && proposalInterest.length > 0) {\n\t\t\tconst interests = [];\n\t\t\tconst chaincodeInterest = this._buildProtoChaincodeInterest(proposalInterest);\n\t\t\tinterests.push(chaincodeInterest);\n\n\t\t\tconst ccQuery = fabproto6.discovery.ChaincodeQuery.create({\n\t\t\t\tinterests: interests\n\t\t\t});\n\n\t\t\tconst query = fabproto6.discovery.Query.create({\n\t\t\t\tchannel: this.channel.name,\n\t\t\t\tcc_query: ccQuery\n\t\t\t});\n\t\t\tlogger.debug('%s - adding chaincodes/collections query', method);\n\t\t\tqueries.push(query);\n\t\t} else {\n\t\t\tlogger.debug('%s - NOT adding chaincodes/collections query', method);\n\t\t}\n\n\t\tif (queries.length === 0) {\n\t\t\tthrow Error('No discovery interest provided');\n\t\t}\n\n\t\tthis._action.request = fabproto6.discovery.Request.create({\n\t\t\tqueries: queries,\n\t\t\tauthentication: authentication,\n\n\t\t});\n\t\tthis._payload  = fabproto6.discovery.Request.encode(\n\t\t\tthis._action.request\n\t\t).finish();\n\n\t\tlogger.debug('%s - end', method);\n\t\treturn this._payload;\n\t}\n\n\t/**\n\t * @typedef {Object} DiscoverRequest\n\t * @property {boolean} [asLocalhost] - Optional. When discovery is running in a\n\t *  virtual environment, the host name of peers and orderers created by this\n\t *  service may have to converted to localhost for connections to be established.\n\t * @property {number} [requestTimeout] - Optional. The request timeout\n\t * @property {number} [refreshAge] - Optional. The milliseconds before the\n\t *  discovery results will be refreshed automatically. When the {@link Discovery#getDiscoveryResults}\n\t *  is called with refresh = true and the age of the discovery results\n\t *  is older then 'refreshAge' the current signed request will be sent\n\t *  to the peer's discovery service.\n\t *  Default: 5 minutes.\n\t * @property {Discoverer[]} targets - Optional. An array of {@link Discoverer}\n\t *  instances. When not included the assigned discoverer will be used. The\n\t *  discoverer may be assigned anytime before the {@link DiscoveryService#send} is called.\n\t */\n\n\t/**\n\t * Send a signed transaction proposal to peer(s)\n\t *\n\t * @param {DiscoverRequest} request\n\t * @returns {DiscoveryResults}\n\t */\n\tasync send(request = {}) {\n\t\tconst method = `send[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tconst {requestTimeout, asLocalhost, refreshAge, targets} = request;\n\n\t\tif (typeof asLocalhost === 'boolean') {\n\t\t\tthis.asLocalhost = asLocalhost;\n\t\t}\n\t\tthis.refreshAge = refreshAge;\n\t\tthis.requestTimeout = requestTimeout;\n\t\tif (targets && Array.isArray(targets) && targets.length > 0)  {\n\t\t\tthis.targets = targets;\n\t\t} else if (this.targets) {\n\t\t\tlogger.debug('%s - using preassigned targets', method);\n\t\t} else {\n\t\t\tcheckParameter('targets');\n\t\t}\n\n\t\tconst signedEnvelope = this.getSignedEnvelope();\n\n\t\tlet response;\n\t\tfor (const target of this.targets) {\n\t\t\tlogger.debug(`${method} - about to discover on ${target.endpoint.url}`);\n\t\t\ttry {\n\t\t\t\tconst isConnected = await target.checkConnection();\n\t\t\t\tif (isConnected) {\n\t\t\t\t\tresponse = await target.sendDiscovery(signedEnvelope, this.requestTimeout);\n\t\t\t\t\tthis.currentTarget = target;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tresponse = error;\n\t\t\t}\n\t\t}\n\n\t\tif (response instanceof Error) {\n\t\t\tthrow response;\n\t\t}\n\n\t\t// -----\n\t\tlogger.debug(`${method} - processing discovery response`);\n\t\tif (!response || !response.results) {\n\t\t\tlogger.error('%s - no discovery results', method);\n\t\t\tthrow new Error('DiscoveryService has failed to return results');\n\t\t}\n\n\t\tlogger.debug(`${method} - parse discovery response.results`);\n\n\t\tconst processor = new DiscoveryResultsProcessor(this, response.results);\n\t\tconst results = await processor.parseDiscoveryResults();\n\t\tresults.timestamp = currentTimestamp();\n\t\tthis.discoveryResults = results;\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get the discovered results. The results are from the discovery service\n\t * of the Peer and based on the discovery request of {@link DiscoveryService#BuildDiscoveryRequest}\n\t * that was sent to the Peer with {@link Discover#discover}.\n\t * @param {boolean} [refresh] - Optional. Refresh the discovery results if\n\t *  results are older then the refresh age.\n\t */\n\tasync getDiscoveryResults(refresh) {\n\t\tconst method = `getDiscoveryResults[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tif (!this.discoveryResults) {\n\t\t\tthrow Error('No discovery results found');\n\t\t}\n\n\t\tif (refresh && !this.refreshRunning && this._isRefreshRequired()) {\n\t\t\tlogger.debug(`${method} - will refresh`);\n\t\t\tthis.refreshRunning = true;\n\t\t\ttry {\n\t\t\t\tawait this.send({asLocalhost: this.asLocalhost, requestTimeout: this.requestTimeout, targets: this.targets});\n\t\t\t} finally {\n\t\t\t\tthis.refreshRunning = false;\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug(`${method} - not refreshing`);\n\t\t}\n\n\t\treturn this.discoveryResults;\n\t}\n\n\t_isRefreshRequired() {\n\t\tconst resultsAge = currentTimestamp() - this.discoveryResults.timestamp;\n\t\treturn resultsAge > this.refreshAge;\n\t}\n\n\t/**\n\t * Indicates if this discovery service has retreived results\n\t */\n\thasDiscoveryResults() {\n\t\tconst method = `hasDiscoveryResults[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\treturn !!this.discoveryResults;\n\t}\n\n\t_buildUrl(hostname = checkParameter('hostname'), port = checkParameter('port')) {\n\t\tconst method = `_buildUrl[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tlet t_hostname = hostname;\n\t\t// endpoints may be running in containers on the local system\n\t\tif (this.asLocalhost) {\n\t\t\tt_hostname = 'localhost';\n\t\t}\n\n\t\t// If we connect to a discovery peer over TLS, any endpoints returned by\n\t\t// discovery should also use TLS.\n\t\tlet protocol = null;\n\t\tlet isTLS = true;\n\t\tif (this.currentTarget) {\n\t\t\tisTLS = this.currentTarget.endpoint.isTLS();\n\t\t}\n\t\tprotocol = isTLS ? 'grpcs' : 'grpc';\n\t\t// but if not, use the following to override\n\t\tconst overrideProtocol = this.client.getConfigSetting('discovery-override-protocol');\n\t\tif (overrideProtocol) {\n\t\t\tprotocol = overrideProtocol;\n\t\t}\n\n\t\treturn `${protocol}://${t_hostname}:${port}`;\n\t}\n\n\t/* internal method\n\t *  Takes an array of {@link DiscoveryChaincodeCall} that represent the\n\t *  chaincodes and associated collections to build an interest.\n\t *  The interest becomes part of the query object needed by the discovery\n\t *  service to calculate the endorsement plan for an invocation.\n\t */\n\t_buildProtoChaincodeInterest(interest = []) {\n\t\tlogger.debug(`_buildProtoChaincodeInterest[${this.name}] - start`);\n\t\tconst chaincodeCalls = [];\n\t\tfor (const chaincode of interest) {\n\t\t\tconst chaincodeCall = fabproto6.discovery.ChaincodeCall.create();\n\t\t\tif (typeof chaincode.name === 'string') {\n\t\t\t\tchaincodeCall.name = chaincode.name;\n\t\t\t\tif (chaincode.noPrivateReads) {\n\t\t\t\t\tchaincodeCall.no_private_reads = chaincode.noPrivateReads;\n\t\t\t\t}\n\t\t\t\t// support both names\n\t\t\t\tif (chaincode.collection_names) {\n\t\t\t\t\t_getCollectionNames(chaincode.collection_names, chaincodeCall);\n\t\t\t\t} else if (chaincode.collectionNames) {\n\t\t\t\t\t_getCollectionNames(chaincode.collectionNames, chaincodeCall);\n\t\t\t\t}\n\t\t\t\tchaincodeCalls.push(chaincodeCall);\n\t\t\t} else {\n\t\t\t\tthrow Error('Chaincode name must be a string');\n\t\t\t}\n\t\t}\n\t\tconst chaincodeInterest = fabproto6.discovery.ChaincodeInterest.create({\n\t\t\tchaincodes: chaincodeCalls\n\t\t});\n\n\t\treturn chaincodeInterest;\n\t}\n\n\t/**\n\t * Close the connection of the discovery service.\n\t */\n\tclose() {\n\t\tconst method = `close[${this.name}]`;\n\t\tlogger.debug(`${method} - start`);\n\n\t\tif (this.targets) {\n\t\t\tfor (const target of this.targets) {\n\t\t\t\ttarget.disconnect();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * return a printable representation of this object\n\t */\n\ttoString() {\n\t\treturn `DiscoveryService: {name: ${this.name}, channel: ${this.channel.name}}`;\n\t}\n}\n\nfunction _getCollectionNames(names, chaincodeCall) {\n\tif (Array.isArray(names)) {\n\t\tconst collection_names = [];\n\t\tnames.map(name => {\n\t\t\tif (typeof name === 'string') {\n\t\t\t\tcollection_names.push(name);\n\t\t\t} else {\n\t\t\t\tthrow Error('The collection name must be a string');\n\t\t\t}\n\t\t});\n\t\t// this collection_names must be in snake case as it will\n\t\t// be used by the gRPC create message\n\t\tchaincodeCall.collection_names = collection_names;\n\t} else {\n\t\tthrow Error('Collection names must be an array of strings');\n\t}\n}\n\nfunction currentTimestamp() {\n\treturn new Date().getTime();\n}\n\nmodule.exports = DiscoveryService;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}