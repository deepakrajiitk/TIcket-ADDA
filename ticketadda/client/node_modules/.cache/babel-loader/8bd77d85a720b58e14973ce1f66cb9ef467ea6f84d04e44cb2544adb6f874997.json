{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n    this.call.resume();\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  _write(chunk, encoding,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n    callback();\n  }\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = null;\n    this.statusSent = false;\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: constants_1.Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null\n        });\n      }\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  getDecompressedMessage(message, encoding) {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n    return Promise.reject({\n      code: constants_1.Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`\n    });\n  }\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.metadataSent) {\n      return;\n    }\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    }\n    // TODO(cjihrig): Receive compression metadata.\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  receiveUnaryMessage(encoding, next) {\n    const {\n      stream\n    } = this;\n    let receivedLength = 0;\n    const call = this;\n    const body = [];\n    const limit = this.maxReceiveMessageSize;\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n    function onData(chunk) {\n      receivedLength += chunk.byteLength;\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`\n        });\n        return;\n      }\n      body.push(chunk);\n    }\n    function onEnd(err) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n      if (err !== undefined) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: err.message\n        });\n        return;\n      }\n      if (receivedLength === 0) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: 'received empty unary message'\n        });\n        return;\n      }\n      call.emit('receiveMessage');\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n      decompressedMessage.then(decompressed => call.safeDeserializeMessage(decompressed, next), err => next(err.code ? err : {\n        code: constants_1.Status.INTERNAL,\n        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n      }));\n    }\n  }\n  safeDeserializeMessage(buffer, next) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      next(err);\n    }\n  }\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value);\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n  async sendUnaryMessage(err, value, metadata, flags) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (metadata === undefined) {\n      metadata = null;\n    }\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n    try {\n      const response = this.serializeMessage(value);\n      this.write(response);\n      this.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata\n      });\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.sendError(err);\n    }\n  }\n  sendStatus(statusObj) {\n    var _a;\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        var _a;\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n        this.statusSent = true;\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : null\n    };\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n    this.sendStatus(status);\n  }\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n  resume() {\n    this.stream.resume();\n  }\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n  setupReadable(readable, encoding) {\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    };\n    this.stream.on('data', async data => {\n      const messages = decoder.write(data);\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n          this.sendError({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n        this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      maybePushEnd();\n    });\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n    return this.canPush;\n  }\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n  async pushMessage(readable, messageBytes) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n      return;\n    }\n    trace('Received message of length ' + messageBytes.length);\n    this.isPushPending = true;\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n        // The error code is not a valid gRPC code so its being overwritten.\n        error.code = constants_1.Status.INTERNAL;\n      }\n      readable.emit('error', error);\n    }\n    this.isPushPending = false;\n    if (this.bufferedMessages.length > 0) {\n      this.pushMessage(readable, this.bufferedMessages.shift());\n    }\n  }\n  getPeer() {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline() {\n    return this.deadline;\n  }\n  getPath() {\n    return this.handler.path;\n  }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"names":["events_1","require","http2","stream_1","zlib","util_1","constants_1","metadata_1","stream_decoder_1","logging","TRACER_NAME","unzip","promisify","inflate","trace","text","LogVerbosity","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultResponseHeaders","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","ServerUnaryCallImpl","EventEmitter","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","getPath","exports","ServerReadableStreamImpl","Readable","deserialize","encoding","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","ServerWritableStreamImpl","Writable","serialize","trailingMetadata","Metadata","on","err","sendError","end","_write","chunk","callback","response","serializeMessage","write","once","code","Status","INTERNAL","emit","_final","sendStatus","OK","details","ServerDuplexStreamImpl","Duplex","prototype","Http2ServerCallStream","stream","handler","options","deadlineTimer","statusSent","deadline","Infinity","wantTrailers","metadataSent","canPush","isPushPending","bufferedMessages","messagesToPush","maxSendMessageSize","DEFAULT_MAX_SEND_MESSAGE_LENGTH","maxReceiveMessageSize","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","_a","path","rstCode","CANCELLED","checkCancelled","destroyed","closed","getDecompressedMessage","message","subarray","Promise","reject","UNIMPLEMENTED","customMetadata","custom","toHttp2Headers","headers","Object","assign","respond","receiveMetadata","fromHttp2Headers","isTracerEnabled","JSON","stringify","toJSON","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","setMilliseconds","getMilliseconds","setTimeout","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","next","receivedLength","body","limit","onData","onEnd","byteLength","removeListener","RESOURCE_EXHAUSTED","push","undefined","requestBytes","Buffer","concat","compressed","readUInt8","compressedMessageEncoding","decompressedMessage","isBuffer","safeDeserializeMessage","then","decompressed","buffer","deserializeMessage","value","messageBuffer","output","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","sendUnaryMessage","flags","hasOwnProperty","statusObj","clearTimeout","trailersToSend","encodeURI","sendTrailers","error","status","UNKNOWN","Number","isInteger","reason","readable","decoder","StreamDecoder","readsDone","pendingMessageProcessing","pushedEnd","maybePushEnd","pushOrBufferMessage","data","messages","pause","nextMessage","shift","messageBytes","pushMessage","deserialized","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/server-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport * as http2 from 'http2';\nimport { Duplex, Readable, Writable } from 'stream';\nimport * as zlib from 'zlib';\nimport { promisify } from 'util';\n\nimport { Deadline, StatusObject, PartialStatusObject } from './call-stream';\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  LogVerbosity,\n} from './constants';\nimport { Deserialize, Serialize } from './make-client';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ObjectReadable, ObjectWritable } from './object-stream';\nimport { ChannelOptions } from './channel-options';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'server_call';\nconst unzip = promisify(zlib.unzip);\nconst inflate = promisify(zlib.inflate);\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\nexport type ServerStatusResponse = Partial<StatusObject>;\n\nexport type ServerErrorResponse = ServerStatusResponse & Error;\n\nexport type ServerSurfaceCall = {\n  cancelled: boolean;\n  readonly metadata: Metadata;\n  getPeer(): string;\n  sendMetadata(responseMetadata: Metadata): void;\n  getDeadline(): Deadline;\n  getPath(): string;\n} & EventEmitter;\n\nexport type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {\n  request: RequestType;\n};\nexport type ServerReadableStream<RequestType, ResponseType> =\n  ServerSurfaceCall & ObjectReadable<RequestType>;\nexport type ServerWritableStream<RequestType, ResponseType> =\n  ServerSurfaceCall &\n    ObjectWritable<ResponseType> & {\n      request: RequestType;\n      end: (metadata?: Metadata) => void;\n    };\nexport type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &\n  ObjectReadable<RequestType> &\n  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };\n\nexport class ServerUnaryCallImpl<RequestType, ResponseType>\n  extends EventEmitter\n  implements ServerUnaryCall<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public request: RequestType\n  ) {\n    super();\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerReadableStreamImpl<RequestType, ResponseType>\n  extends Readable\n  implements ServerReadableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size: number) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerWritableStreamImpl<RequestType, ResponseType>\n  extends Writable\n  implements ServerWritableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public request: RequestType\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  _write(\n    chunk: ResponseType,\n    encoding: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (...args: any[]) => void\n  ) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback: Function): void {\n    this.call.sendStatus({\n      code: Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata,\n    });\n    callback(null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nexport class ServerDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ServerDuplexStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nServerDuplexStreamImpl.prototype._read =\n  ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n  ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n  ServerWritableStreamImpl.prototype._final;\n\n// Unary response callback signature.\nexport type sendUnaryData<ResponseType> = (\n  error: ServerErrorResponse | ServerStatusResponse | null,\n  value?: ResponseType | null,\n  trailer?: Metadata,\n  flags?: number\n) => void;\n\n// User provided handler for unary calls.\nexport type handleUnaryCall<RequestType, ResponseType> = (\n  call: ServerUnaryCall<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for client streaming calls.\nexport type handleClientStreamingCall<RequestType, ResponseType> = (\n  call: ServerReadableStream<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for server streaming calls.\nexport type handleServerStreamingCall<RequestType, ResponseType> = (\n  call: ServerWritableStream<RequestType, ResponseType>\n) => void;\n\n// User provided handler for bidirectional streaming calls.\nexport type handleBidiStreamingCall<RequestType, ResponseType> = (\n  call: ServerDuplexStream<RequestType, ResponseType>\n) => void;\n\nexport type HandleCall<RequestType, ResponseType> =\n  | handleUnaryCall<RequestType, ResponseType>\n  | handleClientStreamingCall<RequestType, ResponseType>\n  | handleServerStreamingCall<RequestType, ResponseType>\n  | handleBidiStreamingCall<RequestType, ResponseType>;\n\nexport interface UnaryHandler<RequestType, ResponseType> {\n  func: handleUnaryCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ClientStreamingHandler<RequestType, ResponseType> {\n  func: handleClientStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ServerStreamingHandler<RequestType, ResponseType> {\n  func: handleServerStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface BidiStreamingHandler<RequestType, ResponseType> {\n  func: handleBidiStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport type Handler<RequestType, ResponseType> =\n  | UnaryHandler<RequestType, ResponseType>\n  | ClientStreamingHandler<RequestType, ResponseType>\n  | ServerStreamingHandler<RequestType, ResponseType>\n  | BidiStreamingHandler<RequestType, ResponseType>;\n\nexport type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';\n\n// Internal class that wraps the HTTP2 request.\nexport class Http2ServerCallStream<\n  RequestType,\n  ResponseType\n> extends EventEmitter {\n  cancelled = false;\n  deadlineTimer: NodeJS.Timer | null = null;\n  private statusSent = false;\n  private deadline: Deadline = Infinity;\n  private wantTrailers = false;\n  private metadataSent = false;\n  private canPush = false;\n  private isPushPending = false;\n  private bufferedMessages: Array<Buffer | null> = [];\n  private messagesToPush: Array<RequestType | null> = [];\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n  constructor(\n    private stream: http2.ServerHttp2Stream,\n    private handler: Handler<RequestType, ResponseType>,\n    private options: ChannelOptions\n  ) {\n    super();\n\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null,\n        });\n      }\n    });\n\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n\n  private getDecompressedMessage(\n    message: Buffer,\n    encoding: string\n  ): Buffer | Promise<Buffer> {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n\n    return Promise.reject({\n      code: Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n    });\n  }\n\n  sendMetadata(customMetadata?: Metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = { ...defaultResponseHeaders, ...custom };\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers: http2.IncomingHttpHeaders) {\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace(\n        'Request to ' +\n          this.handler.path +\n          ' received headers ' +\n          JSON.stringify(metadata.toJSON())\n      );\n    }\n\n    // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline') as ServerErrorResponse;\n        err.code = Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n\n    return metadata;\n  }\n\n  receiveUnaryMessage(\n    encoding: string,\n    next: (\n      err: Partial<ServerStatusResponse> | null,\n      request?: RequestType\n    ) => void\n  ): void {\n    const { stream } = this;\n\n    let receivedLength = 0;\n    const call = this;\n    const body: Buffer[] = [];\n    const limit = this.maxReceiveMessageSize;\n\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n\n    function onData(chunk: Buffer) {\n      receivedLength += chunk.byteLength;\n\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n        });\n        return;\n      }\n\n      body.push(chunk);\n    }\n\n    function onEnd(err?: Error) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n\n      if (err !== undefined) {\n        next({ code: Status.INTERNAL, details: err.message });\n        return;\n      }\n\n      if (receivedLength === 0) {\n        next({ code: Status.INTERNAL, details: 'received empty unary message' })\n        return;\n      }\n\n      call.emit('receiveMessage');\n\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(\n        requestBytes,\n        compressedMessageEncoding\n      );\n\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n\n      decompressedMessage.then(\n        (decompressed) => call.safeDeserializeMessage(decompressed, next),\n        (err: any) => next(\n          err.code\n            ? err\n            : {\n                code: Status.INTERNAL,\n                details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n              }\n        )\n      )\n    }\n  }\n\n  private safeDeserializeMessage(\n    buffer: Buffer,\n    next: (err: Partial<ServerStatusResponse> | null, request?: RequestType) => void\n  ) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      err.code = Status.INTERNAL;\n      next(err);\n    }\n  }\n\n  serializeMessage(value: ResponseType) {\n    const messageBuffer = this.handler.serialize(value);\n\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes: Buffer) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    metadata?: Metadata | null,\n    flags?: number\n  ) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (metadata === undefined) {\n      metadata = null;\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value!);\n\n      this.write(response);\n      this.sendStatus({ code: Status.OK, details: 'OK', metadata });\n    } catch (err) {\n      err.code = Status.INTERNAL;\n      this.sendError(err);\n    }\n  }\n\n  sendStatus(statusObj: PartialStatusObject) {\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[statusObj.code] +\n        ' details: ' +\n        statusObj.details\n    );\n\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        const trailersToSend = {\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n          ...statusObj.metadata?.toHttp2Headers(),\n        };\n\n        this.stream.sendTrailers(trailersToSend);\n        this.statusSent = true;\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error: ServerErrorResponse | ServerStatusResponse) {\n    const status: PartialStatusObject = {\n      code: Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata:\n        'metadata' in error && error.metadata !== undefined\n          ? error.metadata\n          : null,\n    };\n\n    if (\n      'code' in error &&\n      typeof error.code === 'number' &&\n      Number.isInteger(error.code)\n    ) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details!;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      chunk.length > this.maxSendMessageSize\n    ) {\n      this.sendError({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call: ServerSurfaceCall) {\n    this.once('cancelled', (reason) => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n\n    this.once('callEnd', (status) => call.emit('callEnd', status));\n  }\n\n  setupReadable(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    encoding: string\n  ) {\n    const decoder = new StreamDecoder();\n\n    let readsDone = false;\n\n    let pendingMessageProcessing = false;\n\n    let pushedEnd = false;\n\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', async (data: Buffer) => {\n      const messages = decoder.write(data);\n\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (\n          this.maxReceiveMessageSize !== -1 &&\n          message.length > this.maxReceiveMessageSize\n        ) {\n          this.sendError({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(\n          message,\n          compressedMessageEncoding\n        );\n\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n\n        this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      maybePushEnd();\n    });\n\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>\n  ): boolean {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  private pushOrBufferMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ): void {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  private async pushMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n\n      if (\n        !(\n          'code' in error &&\n          typeof error.code === 'number' &&\n          Number.isInteger(error.code) &&\n          error.code >= Status.OK &&\n          error.code <= Status.UNAUTHENTICATED\n        )\n      ) {\n        // The error code is not a valid gRPC code so its being overwritten.\n        error.code = Status.INTERNAL;\n      }\n\n      readable.emit('error', error);\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      this.pushMessage(\n        readable,\n        this.bufferedMessages.shift() as Buffer | null\n      );\n    }\n  }\n\n  getPeer(): string {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n\n  getPath(): string {\n    return this.handler.path;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedServerCall = Http2ServerCallStream<any, any>;\n\nfunction handleExpiredDeadline(call: UntypedServerCall) {\n  const err = new Error('Deadline exceeded') as ServerErrorResponse;\n  err.code = Status.DEADLINE_EXCEEDED;\n\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}