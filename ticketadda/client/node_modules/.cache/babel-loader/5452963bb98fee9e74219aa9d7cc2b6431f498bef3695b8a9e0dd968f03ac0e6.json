{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\nconst stream = require('stream');\nconst EVENT_BATCH = 'batch';\nconst EVENT_CHANGE = 'change';\nconst EVENT_SEQ = 'seq';\nconst EVENT_ERROR = 'error';\n\n// streaming line breaker\nconst liner = () => {\n  const liner = new stream.Transform({\n    objectMode: true\n  });\n  liner._transform = function (chunk, encoding, done) {\n    let data = chunk.toString('utf8');\n    if (this._lastLineData) {\n      data = this._lastLineData + data;\n      this._lastLineData = null;\n    }\n    const lines = data.split(/\\s*\\n/);\n    this._lastLineData = lines.splice(lines.length - 1, 1)[0];\n    lines.forEach(this.push.bind(this));\n    done();\n  };\n  liner._flush = function (done) {\n    this.push(this._lastLineData);\n    this._lastLineData = null;\n    done();\n  };\n  return liner;\n};\n\n// streaming change processor\nconst changeProcessor = (ee, batchSize) => {\n  const changeProcessor = new stream.Transform({\n    objectMode: true\n  });\n  const buffer = [];\n  changeProcessor.lastSeq = '0';\n  changeProcessor._transform = function (chunk, encoding, done) {\n    // remove last char from string\n    if (chunk[chunk.length - 1] === ',') {\n      chunk = chunk.slice(0, -1);\n    }\n    try {\n      const j = JSON.parse(chunk);\n      buffer.push(j);\n      if (buffer.length >= batchSize) {\n        ee.emit(EVENT_BATCH, buffer.splice(0, batchSize));\n      }\n      done();\n    } catch (e) {\n      // look for last_seq\n      const match = chunk.match(/\"last_seq\":(.+?)[},]/);\n      if (match) {\n        changeProcessor.lastSeq = JSON.parse(match[1]);\n      }\n      done();\n    }\n  };\n  changeProcessor._flush = function (done) {\n    if (buffer.length > 0) {\n      ee.emit(EVENT_BATCH, buffer.splice(0, buffer.length));\n    }\n    done();\n  };\n  return changeProcessor;\n};\n\n/**\n * Monitors the changes feed (after calling .start()/.get()) and emits events\n *  - EVENT_CHANGE - per change\n *  - EVENT_BATCH - per batch of changes\n *  - EVENT_SEQ - per change of sequence number\n *  - EVENT_ERROR - per 4xx error (except 429)\n *\n * @param {String} db - Name of the database.\n * @param {Function} request - Nano.relax\n */\nclass ChangesReader {\n  // constructor\n  constructor(db, request) {\n    this.db = db;\n    this.setDefaults();\n    this.request = request;\n  }\n\n  // set defaults\n  setDefaults() {\n    this.ee = new EventEmitter();\n    this.batchSize = 100;\n    this.fastChanges = false;\n    this.since = 'now';\n    this.includeDocs = false;\n    this.timeout = 60000;\n    this.started = false;\n    this.wait = false;\n    this.stopOnEmptyChanges = false; // whether to stop polling if we get an empty set of changes back\n    this.continue = true; // whether to poll again\n    this.qs = {}; // extra querystring parameters\n    this.selector = null;\n    this.paused = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    this.paused = false;\n  }\n\n  // prevent another poll happening\n  stop() {\n    this.continue = false;\n  }\n\n  // sleep, promise style\n  async sleep(t) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, t);\n    });\n  }\n\n  // called to start listening to the changes feed. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the the sequence token to start from (defaults to 'now')\n  start(opts) {\n    const self = this;\n\n    // if we're already listening for changes\n    if (self.started) {\n      // return the existing event emitter\n      return self.ee;\n    }\n    self.started = true;\n\n    // handle overidden defaults\n    opts = opts || {};\n    Object.assign(self, opts);\n\n    // the work function is async and runs in the background\n    // with a big do/while loop\n    let delay = 0;\n    const work = async () => {\n      do {\n        if (!self.paused) {\n          // formulate changes feed longpoll HTTP request\n          const req = {\n            method: 'post',\n            db: self.db,\n            path: '_changes',\n            qs: {\n              feed: 'longpoll',\n              timeout: self.timeout,\n              since: self.since,\n              limit: self.batchSize,\n              include_docs: self.includeDocs\n            },\n            body: {}\n          };\n          if (self.fastChanges) {\n            req.qs.seq_interval = self.batchSize;\n          }\n          if (self.selector) {\n            req.qs.filter = '_selector';\n            req.body.selector = self.selector;\n          }\n          Object.assign(req.qs, opts.qs);\n\n          // make HTTP request to get up to batchSize changes from the feed\n          try {\n            const data = await self.request(req);\n            delay = 0;\n\n            // update the since state\n            if (data && data.last_seq && data.last_seq !== self.since) {\n              self.since = data.last_seq;\n              self.ee.emit(EVENT_SEQ, self.since);\n            }\n\n            // stop on empty batch\n            if (self.stopOnEmptyChanges && data && typeof data.results !== 'undefined' && data.results.length === 0) {\n              self.continue = false;\n            }\n\n            // if we have data\n            if (data && data.results && data.results.length > 0) {\n              // emit EVENT_CHANGE events\n              for (const i in data.results) {\n                self.ee.emit(EVENT_CHANGE, data.results[i]);\n              }\n\n              // in 'wait' mode, we need to wait until the user calls .resume()\n              if (self.wait) {\n                // so call pause() to prevent further API calls until .resume() is called\n                self.pause();\n              }\n\n              // emit EVENT_BATCH event\n              self.ee.emit(EVENT_BATCH, data.results);\n            }\n          } catch (err) {\n            // error (wrong password, bad since value etc)\n            // if the error is fatal\n            if (err && err.statusCode && err.statusCode >= 400 && err.statusCode !== 429 && err.statusCode < 500) {\n              self.continue = false;\n            } else {\n              // don't immediately retry on error - exponential back-off\n              delay = delay ? Math.min(60000, delay * 2) : 5000; // up to and no more than one minute\n            }\n\n            self.ee.emit(EVENT_ERROR, err);\n          }\n        }\n\n        // if in pause mode, wait 100ms before checking again\n        if (self.paused && delay === 0) {\n          delay = 100;\n        }\n\n        // delay before next request?\n        if (self.continue && delay > 0) {\n          await self.sleep(delay);\n        }\n      } while (self.continue);\n\n      // reset\n      self.ee.emit('end', self.since);\n      self.setDefaults();\n    };\n    work();\n\n    // return the event emitter to the caller\n    return self.ee;\n  }\n\n  // called to start listening to the changes feed for a finite number of changes. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the sequence token to start from (defaults to 'now')\n  get(opts) {\n    this.stopOnEmptyChanges = true;\n    return this.start(opts);\n  }\n\n  // called to spool through changes to \"now\" in one long HTTP request\n  spool(opts) {\n    const self = this;\n    self.setDefaults();\n    opts = opts || {};\n    Object.assign(self, opts);\n    const req = {\n      method: 'post',\n      db: self.db,\n      path: '_changes',\n      qs: {\n        since: self.since,\n        include_docs: self.includeDocs,\n        seq_interval: self.batchSize\n      },\n      stream: true,\n      body: {}\n    };\n    if (self.selector) {\n      req.qs.filter = '_selector';\n      req.body.selector = self.selector;\n    }\n    const lin = liner();\n    const cp = changeProcessor(self.ee, self.batchSize);\n    self.request(req).pipe(lin).pipe(cp).on('finish', lastSeq => {\n      // the 'end' event was triggering before the last data event\n      setTimeout(() => {\n        self.ee.emit('end', cp.lastSeq);\n      }, 10);\n    }).on(EVENT_ERROR, e => {\n      self.ee.emit(EVENT_ERROR, e);\n    });\n    return self.ee;\n  }\n}\nmodule.exports = ChangesReader;","map":{"version":3,"names":["EventEmitter","require","stream","EVENT_BATCH","EVENT_CHANGE","EVENT_SEQ","EVENT_ERROR","liner","Transform","objectMode","_transform","chunk","encoding","done","data","toString","_lastLineData","lines","split","splice","length","forEach","push","bind","_flush","changeProcessor","ee","batchSize","buffer","lastSeq","slice","j","JSON","parse","emit","e","match","ChangesReader","constructor","db","request","setDefaults","fastChanges","since","includeDocs","timeout","started","wait","stopOnEmptyChanges","continue","qs","selector","paused","pause","resume","stop","sleep","t","Promise","resolve","reject","setTimeout","start","opts","self","Object","assign","delay","work","req","method","path","feed","limit","include_docs","body","seq_interval","filter","last_seq","results","i","err","statusCode","Math","min","get","spool","lin","cp","pipe","on","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/nano/lib/changesreader.js"],"sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst stream = require('stream')\nconst EVENT_BATCH = 'batch'\nconst EVENT_CHANGE = 'change'\nconst EVENT_SEQ = 'seq'\nconst EVENT_ERROR = 'error'\n\n// streaming line breaker\nconst liner = () => {\n  const liner = new stream.Transform({ objectMode: true })\n\n  liner._transform = function (chunk, encoding, done) {\n    let data = chunk.toString('utf8')\n    if (this._lastLineData) {\n      data = this._lastLineData + data\n      this._lastLineData = null\n    }\n\n    const lines = data.split(/\\s*\\n/)\n    this._lastLineData = lines.splice(lines.length - 1, 1)[0]\n    lines.forEach(this.push.bind(this))\n    done()\n  }\n\n  liner._flush = function (done) {\n    this.push(this._lastLineData)\n    this._lastLineData = null\n    done()\n  }\n\n  return liner\n}\n\n// streaming change processor\nconst changeProcessor = (ee, batchSize) => {\n  const changeProcessor = new stream.Transform({ objectMode: true })\n  const buffer = []\n  changeProcessor.lastSeq = '0'\n\n  changeProcessor._transform = function (chunk, encoding, done) {\n    // remove last char from string\n    if (chunk[chunk.length - 1] === ',') {\n      chunk = chunk.slice(0, -1)\n    }\n\n    try {\n      const j = JSON.parse(chunk)\n      buffer.push(j)\n      if (buffer.length >= batchSize) {\n        ee.emit(EVENT_BATCH, buffer.splice(0, batchSize))\n      }\n      done()\n    } catch (e) {\n      // look for last_seq\n      const match = chunk.match(/\"last_seq\":(.+?)[},]/)\n      if (match) {\n        changeProcessor.lastSeq = JSON.parse(match[1])\n      }\n      done()\n    }\n  }\n\n  changeProcessor._flush = function (done) {\n    if (buffer.length > 0) {\n      ee.emit(EVENT_BATCH, buffer.splice(0, buffer.length))\n    }\n    done()\n  }\n\n  return changeProcessor\n}\n\n/**\n * Monitors the changes feed (after calling .start()/.get()) and emits events\n *  - EVENT_CHANGE - per change\n *  - EVENT_BATCH - per batch of changes\n *  - EVENT_SEQ - per change of sequence number\n *  - EVENT_ERROR - per 4xx error (except 429)\n *\n * @param {String} db - Name of the database.\n * @param {Function} request - Nano.relax\n */\nclass ChangesReader {\n  // constructor\n  constructor (db, request) {\n    this.db = db\n    this.setDefaults()\n    this.request = request\n  }\n\n  // set defaults\n  setDefaults () {\n    this.ee = new EventEmitter()\n    this.batchSize = 100\n    this.fastChanges = false\n    this.since = 'now'\n    this.includeDocs = false\n    this.timeout = 60000\n    this.started = false\n    this.wait = false\n    this.stopOnEmptyChanges = false // whether to stop polling if we get an empty set of changes back\n    this.continue = true // whether to poll again\n    this.qs = {} // extra querystring parameters\n    this.selector = null\n    this.paused = false\n  }\n\n  pause () {\n    this.paused = true\n  }\n\n  resume () {\n    this.paused = false\n  }\n\n  // prevent another poll happening\n  stop () {\n    this.continue = false\n  }\n\n  // sleep, promise style\n  async sleep (t) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, t)\n    })\n  }\n\n  // called to start listening to the changes feed. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the the sequence token to start from (defaults to 'now')\n  start (opts) {\n    const self = this\n\n    // if we're already listening for changes\n    if (self.started) {\n      // return the existing event emitter\n      return self.ee\n    }\n    self.started = true\n\n    // handle overidden defaults\n    opts = opts || {}\n    Object.assign(self, opts)\n\n    // the work function is async and runs in the background\n    // with a big do/while loop\n    let delay = 0\n    const work = async () => {\n      do {\n        if (!self.paused) {\n          // formulate changes feed longpoll HTTP request\n          const req = {\n            method: 'post',\n            db: self.db,\n            path: '_changes',\n            qs: {\n              feed: 'longpoll',\n              timeout: self.timeout,\n              since: self.since,\n              limit: self.batchSize,\n              include_docs: self.includeDocs\n            },\n            body: {}\n          }\n          if (self.fastChanges) {\n            req.qs.seq_interval = self.batchSize\n          }\n          if (self.selector) {\n            req.qs.filter = '_selector'\n            req.body.selector = self.selector\n          }\n          Object.assign(req.qs, opts.qs)\n\n          // make HTTP request to get up to batchSize changes from the feed\n          try {\n            const data = await self.request(req)\n            delay = 0\n\n            // update the since state\n            if (data && data.last_seq && data.last_seq !== self.since) {\n              self.since = data.last_seq\n              self.ee.emit(EVENT_SEQ, self.since)\n            }\n\n            // stop on empty batch\n            if (self.stopOnEmptyChanges && data && typeof data.results !== 'undefined' && data.results.length === 0) {\n              self.continue = false\n            }\n\n            // if we have data\n            if (data && data.results && data.results.length > 0) {\n              // emit EVENT_CHANGE events\n              for (const i in data.results) {\n                self.ee.emit(EVENT_CHANGE, data.results[i])\n              }\n\n              // in 'wait' mode, we need to wait until the user calls .resume()\n              if (self.wait) {\n                // so call pause() to prevent further API calls until .resume() is called\n                self.pause()\n              }\n\n              // emit EVENT_BATCH event\n              self.ee.emit(EVENT_BATCH, data.results)\n            }\n          } catch (err) {\n            // error (wrong password, bad since value etc)\n            // if the error is fatal\n            if (err && err.statusCode && err.statusCode >= 400 && err.statusCode !== 429 && err.statusCode < 500) {\n              self.continue = false\n            } else {\n              // don't immediately retry on error - exponential back-off\n              delay = delay ? Math.min(60000, delay * 2) : 5000 // up to and no more than one minute\n            }\n\n            self.ee.emit(EVENT_ERROR, err)\n          }\n        }\n\n        // if in pause mode, wait 100ms before checking again\n        if (self.paused && delay === 0) {\n          delay = 100\n        }\n\n        // delay before next request?\n        if (self.continue && delay > 0) {\n          await self.sleep(delay)\n        }\n      } while (self.continue)\n\n      // reset\n      self.ee.emit('end', self.since)\n      self.setDefaults()\n    }\n    work()\n\n    // return the event emitter to the caller\n    return self.ee\n  }\n\n  // called to start listening to the changes feed for a finite number of changes. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the sequence token to start from (defaults to 'now')\n  get (opts) {\n    this.stopOnEmptyChanges = true\n    return this.start(opts)\n  }\n\n  // called to spool through changes to \"now\" in one long HTTP request\n  spool (opts) {\n    const self = this\n    self.setDefaults()\n    opts = opts || {}\n    Object.assign(self, opts)\n    const req = {\n      method: 'post',\n      db: self.db,\n      path: '_changes',\n      qs: {\n        since: self.since,\n        include_docs: self.includeDocs,\n        seq_interval: self.batchSize\n      },\n      stream: true,\n      body: {}\n    }\n    if (self.selector) {\n      req.qs.filter = '_selector'\n      req.body.selector = self.selector\n    }\n    const lin = liner()\n    const cp = changeProcessor(self.ee, self.batchSize)\n    self.request(req)\n      .pipe(lin)\n      .pipe(cp)\n      .on('finish', (lastSeq) => {\n        // the 'end' event was triggering before the last data event\n        setTimeout(() => {\n          self.ee.emit('end', cp.lastSeq)\n        }, 10)\n      })\n      .on(EVENT_ERROR, (e) => {\n        self.ee.emit(EVENT_ERROR, e)\n      })\n\n    return self.ee\n  }\n}\n\nmodule.exports = ChangesReader\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}