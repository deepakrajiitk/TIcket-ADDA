{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [constants_1.Status.OK, constants_1.Status.INVALID_ARGUMENT, constants_1.Status.NOT_FOUND, constants_1.Status.ALREADY_EXISTS, constants_1.Status.FAILED_PRECONDITION, constants_1.Status.ABORTED, constants_1.Status.OUT_OF_RANGE, constants_1.Status.DATA_LOSS];\nfunction restrictControlPlaneStatusCode(code, details) {\n  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n    return {\n      code: constants_1.Status.INTERNAL,\n      details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n    };\n  } else {\n    return {\n      code,\n      details\n    };\n  }\n}\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c, _d;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n    /**\n     * This is the error from the name resolver if it failed most recently. It\n     * is only used to end calls that start while there is no config selector\n     * and the name resolver is in backoff, so it should be nulled if\n     * configSelector becomes set or the channel state becomes anything other\n     * than TRANSIENT_FAILURE.\n     */\n    this.currentResolutionError = null;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = uri_parser_1.parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig,\n          dynamicFilters\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n      this.configSelector = configSelector;\n      this.currentResolutionError = null;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n      if (this.configSelector === null) {\n        this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), {\n          metadata: status.metadata\n        });\n      }\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf('\\n') + 1)));\n  }\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n  trace(text, verbosityOverride) {\n    logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n  }\n  callRefTimerRef() {\n    var _a, _b, _c, _d;\n    // If the hasRef function does not exist, always run the code\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n  callRefTimerUnref() {\n    var _a, _b;\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig,\n      dynamicFilters\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    var _a, _b;\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result for call [' + callStream.getCallNumber() + ']: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n              try {\n                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                const errorCode = error.code;\n                if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' || errorCode === 'ERR_HTTP2_INVALID_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message + '. Retrying pick', constants_1.LogVerbosity.INFO);\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                  this.trace('Failed to start call on picked subchanel ' + subchannelString + ' with error ' + error.message + '. Ending call', constants_1.LogVerbosity.INFO);\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            const {\n              code,\n              details\n            } = restrictControlPlaneStatusCode(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n            callStream.cancelWithStatus(code, details);\n          });\n        }\n        break;\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          const {\n            code,\n            details\n          } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n          callStream.cancelWithStatus(code, details);\n        }\n        break;\n      case picker_1.PickResultType.DROP:\n        const {\n          code,\n          details\n        } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n        callStream.cancelWithStatus(code, details);\n        break;\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n  tryGetConfig(stream, metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n      } else {\n        this.configSelectionQueue.push({\n          callStream: stream,\n          callMetadata: metadata\n        });\n        this.callRefTimerRef();\n      }\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === constants_1.Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n          deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name\n           * resolution and load balancing\".\n           *\n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        const {\n          code,\n          details\n        } = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n        stream.cancelWithStatus(code, details);\n      }\n    }\n  }\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace('createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"names":["call_stream_1","require","channel_credentials_1","resolving_load_balancer_1","subchannel_pool_1","picker_1","constants_1","filter_stack_1","call_credentials_filter_1","deadline_filter_1","compression_filter_1","resolver_1","logging_1","max_message_size_filter_1","http_proxy_1","uri_parser_1","connectivity_state_1","channelz_1","MAX_TIMEOUT_TIME","nextCallNumber","getNewCallNumber","callNumber","Number","MAX_SAFE_INTEGER","INAPPROPRIATE_CONTROL_PLANE_CODES","Status","OK","INVALID_ARGUMENT","NOT_FOUND","ALREADY_EXISTS","FAILED_PRECONDITION","ABORTED","OUT_OF_RANGE","DATA_LOSS","restrictControlPlaneStatusCode","code","details","includes","INTERNAL","ChannelImplementation","constructor","target","credentials","options","connectivityState","ConnectivityState","IDLE","currentPicker","UnavailablePicker","configSelectionQueue","pickQueue","connectivityStateWatchers","configSelector","currentResolutionError","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","TypeError","ChannelCredentials","originalTarget","originalTargetUri","parseUri","Error","defaultSchemeMapResult","mapUriDefaultScheme","callRefTimer","setInterval","_b","_a","unref","call","channelzTrace","ChannelzTrace","channelzRef","registerChannelzChannel","getChannelzInfo","addTrace","defaultAuthority","getDefaultAuthority","proxyMapResult","mapProxyName","Object","assign","extraOptions","subchannelPool","getSubchannelPool","_c","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","subchannel","getOrCreateSubchannel","getChannelzRef","updateState","picker","queueCopy","slice","callRefTimerUnref","callStream","callMetadata","callConfig","dynamicFilters","tryPick","requestReresolution","addChannelzChild","child","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","ResolvingLoadBalancer","process","nextTick","localQueue","tryGetConfig","status","length","trace","metadata","getOptions","waitForReady","callRefTimerRef","push","cancelWithStatus","filterStackFactory","FilterStackFactory","CallCredentialsFilterFactory","DeadlineFilterFactory","MaxMessageSizeFilterFactory","CompressionFilterFactory","JSON","stringify","undefined","error","LogVerbosity","DEBUG","id","_d","stack","substring","indexOf","state","children","getChildLists","text","verbosityOverride","uriToString","hasRef","ref","pushPick","pickResult","pick","extraPickInfo","pickInformation","subchannelString","getAddress","getCallNumber","PickResultType","pickResultType","COMPLETE","UNAVAILABLE","getConnectivityState","READY","log","ERROR","filterStack","sendMetadata","Promise","resolve","clone","then","finalMetadata","subchannelState","pickExtraFilters","extraFilterFactories","map","factory","createFilter","getRealSubchannel","startCallStream","onCommitted","onCallStarted","errorCode","message","INFO","UNKNOWN","QUEUE","TRANSIENT_FAILURE","DROP","removeConnectivityStateWatcher","watcherObject","watcherIndex","findIndex","value","splice","newState","watchersCopy","currentState","timer","clearTimeout","callback","stream","getStatus","exitIdle","getMethod","methodConfig","timeout","deadline","Date","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","setConfigDeadline","refresh","dynamicFilterFactories","dynamicFilterStackFactory","dynamicFilterStack","filteredMetadata","getFilters","_startCallStream","close","destroy","SHUTDOWN","clearInterval","unregisterChannelzRef","unrefUnusedSubchannels","getTarget","tryToConnect","watchConnectivityState","Infinity","deadlineDate","now","setTimeout","getTime","createCall","method","host","parentCall","propagateFlags","finalOptions","flags","Propagate","DEFAULTS","Http2CallStream","_getCallCredentials","addCallStarted","addStatusWatcher","addCallSucceeded","addCallFailed","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  Deadline,\n  Call,\n  Http2CallStream,\n  CallStreamOptions,\n  StatusObject,\n} from './call-stream';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CallCredentialsFilterFactory } from './call-credentials-filter';\nimport { DeadlineFilterFactory } from './deadline-filter';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, log } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { MaxMessageSizeFilterFactory } from './max-message-size-filter';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\nimport { Filter } from './filter';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';\nimport { Subchannel } from './subchannel';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber(): number {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\n\nconst INAPPROPRIATE_CONTROL_PLANE_CODES: Status[] = [\n  Status.OK,\n  Status.INVALID_ARGUMENT,\n  Status.NOT_FOUND,\n  Status.ALREADY_EXISTS,\n  Status.FAILED_PRECONDITION,\n  Status.ABORTED,\n  Status.OUT_OF_RANGE,\n  Status.DATA_LOSS\n]\n\nfunction restrictControlPlaneStatusCode(code: Status, details: string): {code: Status, details: string} {\n  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n    return {\n      code: Status.INTERNAL,\n      details: `Invalid status from control plane: ${code} ${Status[code]} ${details}`\n    }\n  } else {\n    return {code, details};\n  }\n}\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\nexport class ChannelImplementation implements Channel {\n  private resolvingLoadBalancer: ResolvingLoadBalancer;\n  private subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n  }> = [];\n  private pickQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n    callConfig: CallConfig;\n    dynamicFilters: Filter[];\n  }> = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private defaultAuthority: string;\n  private filterStackFactory: FilterStackFactory;\n  private target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private callRefTimer: NodeJS.Timer;\n  private configSelector: ConfigSelector | null = null;\n  /**\n   * This is the error from the name resolver if it failed most recently. It\n   * is only used to end calls that start while there is no config selector\n   * and the name resolver is in backoff, so it should be nulled if\n   * configSelector becomes set or the channel state becomes anything other\n   * than TRANSIENT_FAILURE.\n   */\n  private currentResolutionError: StatusObject | null = null;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private originalTarget: string;\n  private channelzRef: ChannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (configSelector) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n        }\n        this.configSelector = configSelector;\n        this.currentResolutionError = null;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          this.callRefTimerUnref();\n          for (const { callStream, callMetadata } of localQueue) {\n            this.tryGetConfig(callStream, callMetadata);\n          }\n          this.configSelectionQueue = [];\n        });\n      },\n      (status) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace('Name resolution failed with calls queued for config selection');\n        }\n        if (this.configSelector === null) {\n          this.currentResolutionError = {...restrictControlPlaneStatusCode(status.code, status.details), metadata: status.metadata};\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata } of localQueue) {\n          if (callMetadata.getOptions().waitForReady) {\n            this.callRefTimerRef();\n            this.configSelectionQueue.push({ callStream, callMetadata });\n          } else {\n            callStream.cancelWithStatus(status.code, status.details);\n          }\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CallCredentialsFilterFactory(this),\n      new DeadlineFilterFactory(this),\n      new MaxMessageSizeFilterFactory(this.options),\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    trace(LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + error.stack?.substring(error.stack.indexOf('\\n')+1));\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private pushPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n    this.callRefTimerRef();\n  }\n\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  private tryPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation,\n    });\n    const subchannelString = pickResult.subchannel ? \n      '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : \n      '' + pickResult.subchannel; \n    this.trace(\n      'Pick result for call [' + \n        callStream.getCallNumber() + \n        ']: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(\n            Status.UNAVAILABLE,\n            'Request dropped by load balancing policy'\n          );\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (\n            pickResult.subchannel!.getConnectivityState() !==\n            ConnectivityState.READY\n          ) {\n            log(\n              LogVerbosity.ERROR,\n              'Error: COMPLETE pick result subchannel ' +\n                subchannelString +\n                ' has state ' +\n                ConnectivityState[pickResult.subchannel!.getConnectivityState()]\n            );\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack\n            .sendMetadata(Promise.resolve(callMetadata.clone()))\n            .then(\n              (finalMetadata) => {\n                const subchannelState: ConnectivityState = pickResult.subchannel!.getConnectivityState();\n                if (subchannelState === ConnectivityState.READY) {\n                  try {\n                    const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                    pickResult.subchannel?.getRealSubchannel().startCallStream(\n                      finalMetadata,\n                      callStream,\n                      [...dynamicFilters, ...pickExtraFilters]\n                    );\n                    /* If we reach this point, the call stream has started\n                     * successfully */\n                    callConfig.onCommitted?.();\n                    pickResult.onCallStarted?.();\n                  } catch (error) {\n                    const errorCode = (error as NodeJS.ErrnoException).code;\n                    if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' ||\n                        errorCode === 'ERR_HTTP2_INVALID_SESSION'\n                    ) {\n                      /* An error here indicates that something went wrong with\n                       * the picked subchannel's http2 stream right before we\n                       * tried to start the stream. We are handling a promise\n                       * result here, so this is asynchronous with respect to the\n                       * original tryPick call, so calling it again is not\n                       * recursive. We call tryPick immediately instead of\n                       * queueing this pick again because handling the queue is\n                       * triggered by state changes, and we want to immediately\n                       * check if the state has already changed since the\n                       * previous tryPick call. We do this instead of cancelling\n                       * the stream because the correct behavior may be\n                       * re-queueing instead, based on the logic in the rest of\n                       * tryPick */\n                      this.trace(\n                        'Failed to start call on picked subchannel ' +\n                          subchannelString +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Retrying pick',\n                          LogVerbosity.INFO\n                      );\n                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                    } else {\n                      this.trace(\n                        'Failed to start call on picked subchanel ' +\n                          subchannelString +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Ending call',\n                          LogVerbosity.INFO\n                      );\n                      callStream.cancelWithStatus(\n                        Status.INTERNAL,\n                        `Failed to start HTTP/2 stream with error: ${\n                          (error as Error).message\n                        }`\n                      );\n                    }\n                  }\n                } else {\n                  /* The logic for doing this here is the same as in the catch\n                   * block above */\n                  this.trace(\n                    'Picked subchannel ' +\n                      subchannelString +\n                      ' has state ' +\n                      ConnectivityState[subchannelState] +\n                      ' after metadata filters. Retrying pick',\n                      LogVerbosity.INFO\n                  );\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n              },\n              (error: Error & { code: number }) => {\n                // We assume the error code isn't 0 (Status.OK)\n                const {code, details} = restrictControlPlaneStatusCode(\n                  typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                  `Getting metadata from plugin failed with error: ${error.message}`\n                )\n                callStream.cancelWithStatus(code, details);\n              }\n            );\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n          callStream.cancelWithStatus(code, details);\n        }\n        break;\n      case PickResultType.DROP:\n        const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n        callStream.cancelWithStatus(code, details);\n        break;\n      default:\n        throw new Error(\n          `Invalid state: unknown pickResultType ${pickResult.pickResultType}`\n        );\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      (value) => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' + this.channelzRef.id + ') ' + \n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  private tryGetConfig(stream: Http2CallStream, metadata: Metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n      } else {\n        this.configSelectionQueue.push({\n          callStream: stream,\n          callMetadata: metadata,\n        });\n        this.callRefTimerRef();\n      }\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(\n            deadline.getSeconds() + callConfig.methodConfig.timeout.seconds\n          );\n          deadline.setMilliseconds(\n            deadline.getMilliseconds() +\n              callConfig.methodConfig.timeout.nanos / 1_000_000\n          );\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name \n           * resolution and load balancing\".\n           * \n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        const {code, details} = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n        stream.cancelWithStatus(code, details);\n      }\n    }\n  }\n\n  _startCallStream(stream: Http2CallStream, metadata: Metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace(\n      'createCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadline\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n    const stream: Http2CallStream = new Http2CallStream(\n      method,\n      this,\n      finalOptions,\n      this.filterStackFactory,\n      this.credentials._getCallCredentials(),\n      callNumber\n    );\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}