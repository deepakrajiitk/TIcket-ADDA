{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n  constructor(channel, stream) {\n    var _a, _b;\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n  async sendMetadata(metadata) {\n    const credentials = this.stream.getCredentials();\n    const credsMetadata = credentials.generateMetadata({\n      service_url: this.serviceUrl\n    });\n    const resultMetadata = await metadata;\n    try {\n      resultMetadata.merge(await credsMetadata);\n    } catch (error) {\n      this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n      return Promise.reject('Failed to retrieve auth metadata');\n    }\n    if (resultMetadata.get('authorization').length > 1) {\n      this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n      return Promise.reject('\"authorization\" metadata cannot have multiple values');\n    }\n    return resultMetadata;\n  }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;","map":{"version":3,"names":["filter_1","require","constants_1","uri_parser_1","CallCredentialsFilter","BaseFilter","constructor","channel","stream","splitPath","getMethod","split","serviceName","length","hostname","_b","_a","splitHostPort","getHost","host","serviceUrl","sendMetadata","metadata","credentials","getCredentials","credsMetadata","generateMetadata","service_url","resultMetadata","merge","error","cancelWithStatus","Status","UNAUTHENTICATED","message","Promise","reject","get","INTERNAL","exports","CallCredentialsFilterFactory","createFilter","callStream"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/call-credentials-filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Call } from './call-stream';\nimport { Channel } from './channel';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { splitHostPort } from './uri-parser';\nimport { ServiceError } from './call';\n\nexport class CallCredentialsFilter extends BaseFilter implements Filter {\n  private serviceUrl: string;\n  constructor(\n    private readonly channel: Channel,\n    private readonly stream: Call\n  ) {\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath: string[] = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = splitHostPort(stream.getHost())?.host ?? 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    const credentials = this.stream.getCredentials();\n    const credsMetadata = credentials.generateMetadata({\n      service_url: this.serviceUrl,\n    });\n    const resultMetadata = await metadata;\n    try {\n      resultMetadata.merge(await credsMetadata);\n    } catch (error) {\n      this.stream.cancelWithStatus(\n        Status.UNAUTHENTICATED,\n        `Failed to retrieve auth metadata with error: ${error.message}`\n      );\n      return Promise.reject<Metadata>('Failed to retrieve auth metadata');\n    }\n    if (resultMetadata.get('authorization').length > 1) {\n      this.stream.cancelWithStatus(\n        Status.INTERNAL,\n        '\"authorization\" metadata cannot have multiple values'\n      );\n      return Promise.reject<Metadata>(\n        '\"authorization\" metadata cannot have multiple values'\n      );\n    }\n    return resultMetadata;\n  }\n}\n\nexport class CallCredentialsFilterFactory\n  implements FilterFactory<CallCredentialsFilter> {\n  constructor(private readonly channel: Channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream: Call): CallCredentialsFilter {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAmBA,MAAAA,QAAA,GAAAC,OAAA;AAEA,MAAAC,WAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AAGA,MAAaG,qBAAsB,SAAQJ,QAAA,CAAAK,UAAU;EAEnDC,YACmBC,OAAgB,EAChBC,MAAY;;IAE7B,KAAK,EAAE;IAHU,KAAAD,OAAO,GAAPA,OAAO;IACP,KAAAC,MAAM,GAANA,MAAM;IAGvB,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,MAAMC,SAAS,GAAaD,MAAM,CAACE,SAAS,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;IACzD,IAAIC,WAAW,GAAG,EAAE;IACpB;;;IAGA,IAAIH,SAAS,CAACI,MAAM,IAAI,CAAC,EAAE;MACzBD,WAAW,GAAGH,SAAS,CAAC,CAAC,CAAC;;IAE5B,MAAMK,QAAQ,IAAAC,EAAA,IAAAC,EAAA,GAAGb,YAAA,CAAAc,aAAa,CAACT,MAAM,CAACU,OAAO,EAAE,CAAC,cAAAF,EAAA,uBAAAA,EAAA,CAAEG,IAAI,cAAAJ,EAAA,cAAAA,EAAA,GAAI,WAAW;IACrE;;IAEA,IAAI,CAACK,UAAU,GAAG,WAAWN,QAAQ,IAAIF,WAAW,EAAE;EACxD;EAEA,MAAMS,YAAYA,CAACC,QAA2B;IAC5C,MAAMC,WAAW,GAAG,IAAI,CAACf,MAAM,CAACgB,cAAc,EAAE;IAChD,MAAMC,aAAa,GAAGF,WAAW,CAACG,gBAAgB,CAAC;MACjDC,WAAW,EAAE,IAAI,CAACP;KACnB,CAAC;IACF,MAAMQ,cAAc,GAAG,MAAMN,QAAQ;IACrC,IAAI;MACFM,cAAc,CAACC,KAAK,CAAC,MAAMJ,aAAa,CAAC;KAC1C,CAAC,OAAOK,KAAK,EAAE;MACd,IAAI,CAACtB,MAAM,CAACuB,gBAAgB,CAC1B7B,WAAA,CAAA8B,MAAM,CAACC,eAAe,EACtB,gDAAgDH,KAAK,CAACI,OAAO,EAAE,CAChE;MACD,OAAOC,OAAO,CAACC,MAAM,CAAW,kCAAkC,CAAC;;IAErE,IAAIR,cAAc,CAACS,GAAG,CAAC,eAAe,CAAC,CAACxB,MAAM,GAAG,CAAC,EAAE;MAClD,IAAI,CAACL,MAAM,CAACuB,gBAAgB,CAC1B7B,WAAA,CAAA8B,MAAM,CAACM,QAAQ,EACf,sDAAsD,CACvD;MACD,OAAOH,OAAO,CAACC,MAAM,CACnB,sDAAsD,CACvD;;IAEH,OAAOR,cAAc;EACvB;;AAhDFW,OAAA,CAAAnC,qBAAA,GAAAA,qBAAA;AAmDA,MAAaoC,4BAA4B;EAEvClC,YAA6BC,OAAgB;IAAhB,KAAAA,OAAO,GAAPA,OAAO;IAClC,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EAEAkC,YAAYA,CAACC,UAAgB;IAC3B,OAAO,IAAItC,qBAAqB,CAAC,IAAI,CAACG,OAAO,EAAEmC,UAAU,CAAC;EAC5D;;AARFH,OAAA,CAAAC,4BAAA,GAAAA,4BAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}