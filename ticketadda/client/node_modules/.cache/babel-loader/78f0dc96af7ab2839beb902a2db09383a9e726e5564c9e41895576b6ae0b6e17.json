{"ast":null,"code":"/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n  common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options = options || {};\n  this.stores = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? {\n      file: key\n    } : key;\n    key = 'file';\n  } else {\n    options = typeof options === 'string' ? {\n      file: options\n    } : options;\n  }\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options = options || {};\n  function sameOptions(store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n  var store = this.stores[name],\n    update = store && !sameOptions(store);\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n    this.add(name, options);\n  }\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options = options || {};\n  var type = options.type || name;\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n  this.stores[name] = this.create(type, options, usage);\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  } else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  } else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  } else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n    names = Object.keys(this.stores),\n    self = this,\n    response,\n    mergeObjs = [];\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n        next();\n      });\n    }\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n//\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\nProvider.prototype.any = function (keys, callback) {\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  }\n\n  //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n  if (!callback) {\n    var val;\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n  var keyIndex = 0,\n    result,\n    self = this;\n  async.whilst(function (cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function (next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n    self.get(key, function (err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function (err) {\n    return err ? callback(err) : callback(null, result);\n  });\n};\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n  var missing = [];\n  keys.forEach(function (key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n    args = Array.prototype.slice.call(arguments),\n    callback = typeof args[args.length - 1] === 'function' && args.pop(),\n    value = args.pop(),\n    key = args.pop();\n  function mergeProperty(prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () {});\n  }\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n  function getStores() {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n    return store.loadSync();\n  }\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n    return store.loadSync ? next(null, store.loadSync()) : store.load(next);\n  }\n  function loadBatch(targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n  function mergeSources(data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n  function loadSources() {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n  return self.sources.length ? loadSources() : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n  var self = this,\n    names = Object.keys(this.stores);\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n        next(null, memo);\n      });\n    } else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n    callback = typeof args[args.length - 1] === 'function' && args.pop(),\n    destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n    self = this,\n    response,\n    mergeObjs = [],\n    keys = Object.keys(this.stores);\n  function runAction(name, next) {\n    var store = self.stores[name];\n    if (destructive && store.readOnly) {\n      return next();\n    }\n    return store[action].length > syncLength ? store[action].apply(store, args.concat(next)) : next(null, store[action].apply(store, args));\n  }\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n      if (destructive && store.readOnly) {\n        return;\n      }\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n  return response;\n};\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n  throw err;\n}","map":{"version":3,"names":["async","require","common","Provider","exports","options","stores","sources","init","forEach","type","prototype","args","concat","Array","slice","call","arguments","add","apply","file","key","length","use","name","sameOptions","store","Object","keys","every","update","remove","usage","capitalize","Error","create","loadSync","toLowerCase","self","source","push","get","callback","_execute","current","names","response","mergeObjs","whilst","cb","next","err","value","isArray","undefined","merge","reverse","any","pop","val","i","keyIndex","result","v","set","required","missing","join","reset","clear","mergeProperty","prop","onError","load","getStores","map","loadStoreSync","loadStore","loadBatch","targets","done","objs","mergeSources","data","loadSources","sourceHierarchy","splice","save","saveStoreSync","memo","saveSync","ret","saveStore","reduce","action","syncLength","destructive","indexOf","runAction","readOnly"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/nconf/lib/nconf/provider.js"],"sourcesContent":["/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n    common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options       = options || {};\n  this.stores  = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? { file: key } : key;\n    key = 'file';\n  }\n  else {\n    options = typeof options === 'string'\n      ? { file: options }\n      : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options  = options      || {};\n\n  function sameOptions (store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  }\n  else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  }\n  else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  }\n  else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n\n//\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\nProvider.prototype.any = function (keys, callback) {\n\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  }\n\n  //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n  if (!callback) {\n    var val;\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n\n  var keyIndex = 0,\n      result,\n      self = this;\n  \n  async.whilst(function(cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function(next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n\n    self.get(key, function(err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function(err) {\n    return err ? callback(err) : callback(null, result);\n  });\n};\n\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function(key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty (prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () { })\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores () {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync\n      ? next(null, store.loadSync())\n      : store.load(next);\n  }\n\n  function loadBatch (targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources (data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources () {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length\n    ? loadSources()\n    : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    }\n    else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n\n  function runAction (name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength\n      ? store[action].apply(store, args.concat(next))\n      : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}