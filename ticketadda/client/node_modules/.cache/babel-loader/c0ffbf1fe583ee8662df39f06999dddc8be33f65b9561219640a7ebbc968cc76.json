{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\nfunction getDeadline(deadline) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n  throw new Error('Deadline is too far in the future');\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n  constructor(channel, callStream) {\n    super();\n    this.channel = channel;\n    this.callStream = callStream;\n    this.timer = null;\n    this.deadline = Infinity;\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n  retreiveDeadline() {\n    const callDeadline = this.callStream.getDeadline();\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n  }\n  runTimer() {\n    var _a, _b;\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    const now = new Date().getTime();\n    const timeout = this.deadline - now;\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  refresh() {\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n  async sendMetadata(metadata) {\n    if (this.deadline === Infinity) {\n      return metadata;\n    }\n    /* The input metadata promise depends on the original channel.connect()\n     * promise, so when it is complete that implies that the channel is\n     * connected */\n    const finalMetadata = await metadata;\n    const timeoutString = getDeadline(this.deadline);\n    finalMetadata.set('grpc-timeout', timeoutString);\n    return finalMetadata;\n  }\n  receiveTrailers(status) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    return status;\n  }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory;","map":{"version":3,"names":["constants_1","require","filter_1","units","getDeadline","deadline","now","Date","getTime","timeoutMs","Math","max","unit","factor","amount","String","ceil","Error","DeadlineFilter","BaseFilter","constructor","channel","callStream","timer","Infinity","retreiveDeadline","runTimer","callDeadline","clearTimeout","timeout","process","nextTick","cancelWithStatus","Status","DEADLINE_EXCEEDED","setTimeout","_b","_a","unref","call","refresh","sendMetadata","metadata","finalMetadata","timeoutString","set","receiveTrailers","status","exports","DeadlineFilterFactory","createFilter"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/deadline-filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Call, StatusObject } from './call-stream';\nimport { Channel } from './channel';\nimport { Status } from './constants';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport { Metadata } from './metadata';\n\nconst units: Array<[string, number]> = [\n  ['m', 1],\n  ['S', 1000],\n  ['M', 60 * 1000],\n  ['H', 60 * 60 * 1000],\n];\n\nfunction getDeadline(deadline: number) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n  throw new Error('Deadline is too far in the future');\n}\n\nexport class DeadlineFilter extends BaseFilter implements Filter {\n  private timer: NodeJS.Timer | null = null;\n  private deadline = Infinity;\n  constructor(\n    private readonly channel: Channel,\n    private readonly callStream: Call\n  ) {\n    super();\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  private retreiveDeadline() {\n    const callDeadline = this.callStream.getDeadline();\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n  }\n\n  private runTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    const now: number = new Date().getTime();\n    const timeout = this.deadline - now;\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        this.callStream.cancelWithStatus(\n          Status.DEADLINE_EXCEEDED,\n          'Deadline exceeded'\n        );\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.callStream.cancelWithStatus(\n          Status.DEADLINE_EXCEEDED,\n          'Deadline exceeded'\n        );\n      }, timeout);\n      this.timer.unref?.();\n    }\n  }\n\n  refresh() {\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>) {\n    if (this.deadline === Infinity) {\n      return metadata;\n    }\n    /* The input metadata promise depends on the original channel.connect()\n     * promise, so when it is complete that implies that the channel is\n     * connected */\n    const finalMetadata = await metadata;\n    const timeoutString = getDeadline(this.deadline);\n    finalMetadata.set('grpc-timeout', timeoutString);\n    return finalMetadata;\n  }\n\n  receiveTrailers(status: StatusObject) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    return status;\n  }\n}\n\nexport class DeadlineFilterFactory implements FilterFactory<DeadlineFilter> {\n  constructor(private readonly channel: Channel) {}\n\n  createFilter(callStream: Call): DeadlineFilter {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}