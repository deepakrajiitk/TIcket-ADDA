{"ast":null,"code":"/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'ServiceEndpoint';\nconst {\n  checkParameter,\n  getLogger\n} = require('./Utils.js');\nconst logger = getLogger(TYPE);\n\n/**\n * The ServiceEndpoint class represents a the base class for all Service nodes (Endorser, Committer, Discoverer, and Eventer).\n *\n * @class\n */\nclass ServiceEndpoint {\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('name');\n    let client = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : checkParameter('client');\n    let mspid = arguments.length > 2 ? arguments[2] : undefined;\n    this.name = name;\n    this.mspid = mspid;\n    this.client = client;\n    this.connected = false;\n    this.connectAttempted = false;\n    this.endpoint = null;\n    this.service = null;\n    this.serviceClass = null;\n    this.type = TYPE; // will be overridden by subclass\n    this.options = {};\n  }\n\n  /**\n   * Use this method to give this service endpoint an endpoint and\n   * options that it may connect to at a later time. Use the {@link ServiceEndpoint#connect}\n   * method without a endpoint or options to connect using the setting provided here.\n   *\n   * @param {Endpoint} endpoint - Service connection options including the url.\n   * @param {ConnectionOptions} options - Any specific options for this instance\n   *  of the connection to the peer. These will override options from the\n   *  endpoint service connection options.\n   */\n  setEndpoint() {\n    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : checkParameter('endpoint');\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = `setEndpoint[${this.type}-${this.name}]`;\n    logger.debug(`${method} - start `);\n    if (this.endpoint && this.connected) {\n      const message = `This service endpoint ${this.name}-${this.endpoint.url} is connected`;\n      logger.error(message);\n      throw Error(message);\n    }\n    this.endpoint = endpoint;\n    this.connectAttempted = false;\n    this.options = Object.assign({}, endpoint.options, options);\n    logger.debug(`${method} - endpoint has been set for ${this.name}-${this.endpoint.url}`);\n  }\n\n  /**\n   * Check that this ServiceEndpoint could be connected, even if it has\n   * failed a previous attempt.\n   */\n  isConnectable() {\n    const method = `isConnectable[${this.type}-${this.name}]`;\n    logger.debug(`${method} - start `);\n    let result = false;\n    if (this.connected) {\n      logger.debug(`${method} - this servive endpoint has been connected`);\n      result = true;\n    } else if (this.endpoint && this.serviceClass) {\n      logger.debug(`${method} - this service endpoint has been assigned an endpoint, connect may be run`);\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Connects this ServiceEndpoint with the given url and opts.\n   * If a connect exist an error will be thrown. The application must\n   * disconnect the connection before re-connecting to the service.\n   *\n   * @param {Endpoint} [endpoint] - Service connection options including the url.\n   * When an endpoint is not provided, the setEndpoint() must have been called\n   * previously. If  setEndpoint was previously call and a endpoint is provided\n   * here then it will replace the existing endpoint.\n   * @param {ConnectionOptions} [options] - Any specific options for this instance\n   *  of the connection to the peer. These will override options from the\n   *  endpoint service connection options. Endpoint options and option provided\n   *  here will replace options from the setEndpoint() if previously called.\n   */\n  async connect(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = `connect[${this.type}-${this.name}]`;\n    logger.debug(`${method} - start `);\n    if (this.connected) {\n      const message = `This service endpoint ${this.name}-${this.endpoint.url} is connected`;\n      logger.error(message);\n      throw Error(message);\n    }\n    if (this.service) {\n      const message = `This service endpoint ${this.name}-${this.endpoint.url} has an active grpc service connection`;\n      logger.error(message);\n      throw Error(message);\n    }\n    if (!endpoint && !this.endpoint) {\n      checkParameter('endpoint');\n    }\n    if (endpoint) {\n      this.endpoint = endpoint;\n    }\n    this.options = Object.assign({}, this.endpoint.options, options);\n    this.connectAttempted = true;\n    logger.debug(`${method} - create the grpc service for ${this.name}`);\n    this.service = new this.serviceClass(this.endpoint.addr, this.endpoint.creds, this.options);\n    await this.waitForReady(this.service);\n    logger.debug(`${method} - end - completed the waitForReady for ${this.name}`);\n  }\n\n  /**\n   * disconnect the service connection.\n   */\n  disconnect() {\n    const method = `disconnect[${this.type}-${this.name}]`;\n    logger.debug(`${method} - start on ServiceEndpoint`);\n    if (this.service) {\n      logger.debug(`${method} ${this.type} ${this.name} - closing grpc service connection ${this.endpoint.addr}`);\n      this.service.close();\n      this.service = null;\n      this.connected = false;\n      this.connectAttempted = false;\n    }\n    logger.debug(`${method} - end on ServiceEndpoint`);\n  }\n\n  /**\n   * Check the connection status\n   * @param {boolean} [reset] - Optional, attempt to reconnect if endpoint is not connected\n   */\n  async checkConnection() {\n    let reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const method = `checkConnection[${this.type}-${this.name}]`;\n    logger.debug('%s - start - connected:%s', method, this.connected);\n    if (reset && this.connected) {\n      try {\n        await this.waitForReady();\n      } catch (error) {\n        logger.error(`ServiceEndpoint ${this.endpoint.url} connection failed :: ${error}`);\n      }\n    }\n    if (reset && !this.connected && this.isConnectable()) {\n      try {\n        await this.resetConnection();\n      } catch (error) {\n        logger.error(`ServiceEndpoint ${this.endpoint.url} reset connection failed :: ${error}`);\n      }\n    }\n    logger.debug('%s - end - connected:%s', method, this.connected);\n    return this.connected;\n  }\n\n  /**\n   * Reset the connection\n   */\n  async resetConnection() {\n    const method = `resetConnection[${this.type}-${this.name}]`;\n    logger.debug('%s - start - connected:%s', method, this.connected);\n    this.disconnect(); // clean up possible old service\n    this.connectAttempted = true;\n    logger.debug(`${method} - create the grpc service for ${this.name}`);\n    if (this.endpoint && this.serviceClass) {\n      this.service = new this.serviceClass(this.endpoint.addr, this.endpoint.creds, this.options);\n      await this.waitForReady(this.service);\n    } else {\n      throw Error(`ServiceEndpoint ${this.name} is missing endpoint information`);\n    }\n    logger.debug('%s - end - connected:%s', method, this.connected);\n  }\n  waitForReady() {\n    const method = 'waitForReady';\n    logger.debug(`${method} - start ${this.type}-${this.name} - ${this.endpoint.url}`);\n    return new Promise((resolve, reject) => {\n      logger.debug(`${method} - promise running ${this.name} - ${this.endpoint.url}`);\n      const wait_ready_timeout = this.options['grpc-wait-for-ready-timeout'];\n      const timeout = new Date().getTime() + wait_ready_timeout;\n      if (!this.service) {\n        reject(new Error(`ServiceEndpoint ${this.type}-${this.name} grpc service has not been started`));\n      }\n      this.service.waitForReady(timeout, err => {\n        if (err) {\n          if (err.message) {\n            err.message = err.message + ' on ' + this.toString();\n          }\n          err.connectFailed = true;\n          this.connected = false;\n          logger.error(err);\n          logger.error(`${method} - Failed to connect to remote gRPC server ${this.name} url:${this.endpoint.url} timeout:${wait_ready_timeout}`);\n          reject(err);\n        } else {\n          this.connected = true;\n          logger.debug(`${method} - Successfully connected to remote gRPC server ${this.name} url:${this.endpoint.url}`);\n          resolve();\n        }\n      });\n    });\n  }\n\n  /*\n   * Get this remote endpoints characteristics\n   */\n  getCharacteristics(results) {\n    results.connection = {\n      type: this.type,\n      name: this.name,\n      url: this.endpoint && this.endpoint.url || '',\n      options: this.endpoint && this.endpoint.options || {}\n    };\n    results.peer = this.name;\n\n    // remove private key\n    if (results.connection.options.clientKey) {\n      delete results.connection.options.clientKey;\n    }\n    return results;\n  }\n\n  /**\n   * Determine whether or not this remote endpoint uses TLS.\n   * @returns {boolean} True if this endpoint uses TLS, false otherwise.\n   * @throws {Error} if the Service Endpoint has not been connected to an\n   *  endpoint.\n   */\n  isTLS() {\n    if (this.endpoint) {\n      return this.endpoint.isTLS();\n    } else {\n      throw Error(`${this.type} is not connected`);\n    }\n  }\n\n  /**\n   * return a printable representation of this object\n   */\n  toString() {\n    let url = '<not connected>';\n    if (this.endpoint) {\n      url = this.endpoint.url;\n    }\n    return `${this.type}- name: ${this.name}, url:${url}, connected:${this.connected}, connectAttempted:${this.connectAttempted}`;\n  }\n}\nmodule.exports = ServiceEndpoint;","map":{"version":3,"names":["TYPE","checkParameter","getLogger","require","logger","ServiceEndpoint","constructor","name","arguments","length","undefined","client","mspid","connected","connectAttempted","endpoint","service","serviceClass","type","options","setEndpoint","method","debug","message","url","error","Error","Object","assign","isConnectable","result","connect","addr","creds","waitForReady","disconnect","close","checkConnection","reset","resetConnection","Promise","resolve","reject","wait_ready_timeout","timeout","Date","getTime","err","toString","connectFailed","getCharacteristics","results","connection","peer","clientKey","isTLS","module","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/fabric-common/lib/ServiceEndpoint.js"],"sourcesContent":["/*\n * Copyright 2019 IBM All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst TYPE = 'ServiceEndpoint';\n\nconst {checkParameter, getLogger} = require('./Utils.js');\nconst logger = getLogger(TYPE);\n\n/**\n * The ServiceEndpoint class represents a the base class for all Service nodes (Endorser, Committer, Discoverer, and Eventer).\n *\n * @class\n */\nclass ServiceEndpoint {\n\n\tconstructor(name = checkParameter('name'), client = checkParameter('client'), mspid) {\n\t\tthis.name = name;\n\t\tthis.mspid = mspid;\n\t\tthis.client = client;\n\t\tthis.connected = false;\n\t\tthis.connectAttempted = false;\n\t\tthis.endpoint = null;\n\t\tthis.service = null;\n\t\tthis.serviceClass = null;\n\t\tthis.type = TYPE; // will be overridden by subclass\n\t\tthis.options = {};\n\t}\n\n\t/**\n\t * Use this method to give this service endpoint an endpoint and\n\t * options that it may connect to at a later time. Use the {@link ServiceEndpoint#connect}\n\t * method without a endpoint or options to connect using the setting provided here.\n\t *\n\t * @param {Endpoint} endpoint - Service connection options including the url.\n\t * @param {ConnectionOptions} options - Any specific options for this instance\n\t *  of the connection to the peer. These will override options from the\n\t *  endpoint service connection options.\n\t */\n\tsetEndpoint(endpoint = checkParameter('endpoint'), options = {}) {\n\t\tconst method = `setEndpoint[${this.type}-${this.name}]`;\n\t\tlogger.debug(`${method} - start `);\n\n\t\tif (this.endpoint && this.connected) {\n\t\t\tconst message = `This service endpoint ${this.name}-${this.endpoint.url} is connected`;\n\t\t\tlogger.error(message);\n\t\t\tthrow Error(message);\n\t\t}\n\n\t\tthis.endpoint = endpoint;\n\t\tthis.connectAttempted = false;\n\t\tthis.options = Object.assign({}, endpoint.options, options);\n\t\tlogger.debug(`${method} - endpoint has been set for ${this.name}-${this.endpoint.url}`);\n\t}\n\n\t/**\n\t * Check that this ServiceEndpoint could be connected, even if it has\n\t * failed a previous attempt.\n\t */\n\tisConnectable() {\n\t\tconst method = `isConnectable[${this.type}-${this.name}]`;\n\t\tlogger.debug(`${method} - start `);\n\n\t\tlet result = false;\n\t\tif (this.connected) {\n\t\t\tlogger.debug(`${method} - this servive endpoint has been connected`);\n\t\t\tresult = true;\n\t\t} else if (this.endpoint && this.serviceClass) {\n\t\t\tlogger.debug(`${method} - this service endpoint has been assigned an endpoint, connect may be run`);\n\t\t\tresult = true;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Connects this ServiceEndpoint with the given url and opts.\n\t * If a connect exist an error will be thrown. The application must\n\t * disconnect the connection before re-connecting to the service.\n\t *\n\t * @param {Endpoint} [endpoint] - Service connection options including the url.\n\t * When an endpoint is not provided, the setEndpoint() must have been called\n\t * previously. If  setEndpoint was previously call and a endpoint is provided\n\t * here then it will replace the existing endpoint.\n\t * @param {ConnectionOptions} [options] - Any specific options for this instance\n\t *  of the connection to the peer. These will override options from the\n\t *  endpoint service connection options. Endpoint options and option provided\n\t *  here will replace options from the setEndpoint() if previously called.\n\t */\n\tasync connect(endpoint, options = {}) {\n\t\tconst method = `connect[${this.type}-${this.name}]`;\n\t\tlogger.debug(`${method} - start `);\n\n\t\tif (this.connected) {\n\t\t\tconst message = `This service endpoint ${this.name}-${this.endpoint.url} is connected`;\n\t\t\tlogger.error(message);\n\t\t\tthrow Error(message);\n\t\t}\n\n\t\tif (this.service) {\n\t\t\tconst message = `This service endpoint ${this.name}-${this.endpoint.url} has an active grpc service connection`;\n\t\t\tlogger.error(message);\n\t\t\tthrow Error(message);\n\t\t}\n\n\t\tif (!endpoint && !this.endpoint) {\n\t\t\tcheckParameter('endpoint');\n\t\t}\n\n\t\tif (endpoint) {\n\t\t\tthis.endpoint = endpoint;\n\t\t}\n\n\t\tthis.options = Object.assign({}, this.endpoint.options, options);\n\n\t\tthis.connectAttempted = true;\n\t\tlogger.debug(`${method} - create the grpc service for ${this.name}`);\n\t\tthis.service = new this.serviceClass(this.endpoint.addr, this.endpoint.creds, this.options);\n\t\tawait this.waitForReady(this.service);\n\t\tlogger.debug(`${method} - end - completed the waitForReady for ${this.name}`);\n\t}\n\n\t/**\n\t * disconnect the service connection.\n\t */\n\tdisconnect() {\n\t\tconst method = `disconnect[${this.type}-${this.name}]`;\n\t\tlogger.debug(`${method} - start on ServiceEndpoint`);\n\n\t\tif (this.service) {\n\t\t\tlogger.debug(`${method} ${this.type} ${this.name} - closing grpc service connection ${this.endpoint.addr}`);\n\t\t\tthis.service.close();\n\t\t\tthis.service = null;\n\t\t\tthis.connected = false;\n\t\t\tthis.connectAttempted = false;\n\t\t}\n\n\t\tlogger.debug(`${method} - end on ServiceEndpoint`);\n\t}\n\n\t/**\n\t * Check the connection status\n\t * @param {boolean} [reset] - Optional, attempt to reconnect if endpoint is not connected\n\t */\n\tasync checkConnection(reset = true) {\n\t\tconst method = `checkConnection[${this.type}-${this.name}]`;\n\t\tlogger.debug('%s - start - connected:%s', method, this.connected);\n\n\t\tif (reset && this.connected) {\n\t\t\ttry {\n\t\t\t\tawait this.waitForReady();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`ServiceEndpoint ${this.endpoint.url} connection failed :: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\tif (reset && !this.connected && this.isConnectable()) {\n\t\t\ttry {\n\t\t\t\tawait this.resetConnection();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`ServiceEndpoint ${this.endpoint.url} reset connection failed :: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('%s - end - connected:%s', method, this.connected);\n\t\treturn this.connected;\n\t}\n\n\t/**\n\t * Reset the connection\n\t */\n\tasync resetConnection() {\n\t\tconst method = `resetConnection[${this.type}-${this.name}]`;\n\t\tlogger.debug('%s - start - connected:%s', method, this.connected);\n\n\t\tthis.disconnect(); // clean up possible old service\n\t\tthis.connectAttempted = true;\n\t\tlogger.debug(`${method} - create the grpc service for ${this.name}`);\n\t\tif (this.endpoint && this.serviceClass) {\n\t\t\tthis.service = new this.serviceClass(this.endpoint.addr, this.endpoint.creds, this.options);\n\t\t\tawait this.waitForReady(this.service);\n\t\t} else {\n\t\t\tthrow Error(`ServiceEndpoint ${this.name} is missing endpoint information`);\n\t\t}\n\n\t\tlogger.debug('%s - end - connected:%s', method, this.connected);\n\t}\n\n\twaitForReady() {\n\t\tconst method = 'waitForReady';\n\t\tlogger.debug(`${method} - start ${this.type}-${this.name} - ${this.endpoint.url}`);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlogger.debug(`${method} - promise running ${this.name} - ${this.endpoint.url}`);\n\t\t\tconst wait_ready_timeout = this.options['grpc-wait-for-ready-timeout'];\n\t\t\tconst timeout = new Date().getTime() + wait_ready_timeout;\n\t\t\tif (!this.service) {\n\t\t\t\treject(new Error(`ServiceEndpoint ${this.type}-${this.name} grpc service has not been started`));\n\t\t\t}\n\t\t\tthis.service.waitForReady(timeout, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.message) {\n\t\t\t\t\t\terr.message = err.message + ' on ' + this.toString();\n\t\t\t\t\t}\n\t\t\t\t\terr.connectFailed = true;\n\t\t\t\t\tthis.connected = false;\n\t\t\t\t\tlogger.error(err);\n\t\t\t\t\tlogger.error(`${method} - Failed to connect to remote gRPC server ${this.name} url:${this.endpoint.url} timeout:${wait_ready_timeout}`);\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tlogger.debug(`${method} - Successfully connected to remote gRPC server ${this.name} url:${this.endpoint.url}`);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/*\n\t * Get this remote endpoints characteristics\n\t */\n\tgetCharacteristics(results) {\n\t\tresults.connection = {\n\t\t\ttype: this.type,\n\t\t\tname: this.name,\n\t\t\turl: this.endpoint && this.endpoint.url || '',\n\t\t\toptions: this.endpoint && this.endpoint.options || {}\n\t\t};\n\t\tresults.peer = this.name;\n\n\t\t// remove private key\n\t\tif (results.connection.options.clientKey) {\n\t\t\tdelete results.connection.options.clientKey;\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Determine whether or not this remote endpoint uses TLS.\n\t * @returns {boolean} True if this endpoint uses TLS, false otherwise.\n\t * @throws {Error} if the Service Endpoint has not been connected to an\n\t *  endpoint.\n\t */\n\tisTLS() {\n\t\tif (this.endpoint) {\n\n\t\t\treturn this.endpoint.isTLS();\n\t\t} else {\n\t\t\tthrow Error(`${this.type} is not connected`);\n\t\t}\n\t}\n\n\t/**\n\t * return a printable representation of this object\n\t */\n\ttoString() {\n\t\tlet url = '<not connected>';\n\t\tif (this.endpoint) {\n\t\t\turl = this.endpoint.url;\n\t\t}\n\n\t\treturn `${this.type}- name: ${this.name}, url:${url}, connected:${this.connected}, connectAttempted:${this.connectAttempted}`;\n\t}\n\n}\n\nmodule.exports = ServiceEndpoint;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}