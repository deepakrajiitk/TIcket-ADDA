{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst net = require(\"net\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst clientVersion = require('../../package.json').version;\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n    this.disconnectListeners = new Set();\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        clearTimeout(this.keepaliveTimeoutId);\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n    this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  handleDisconnect() {\n    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.add(listener);\n  }\n  removeDisconnectListener(listener) {\n    this.disconnectListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["http2","require","tls_1","connectivity_state_1","backoff_timeout_1","resolver_1","logging","constants_1","http_proxy_1","net","uri_parser_1","subchannel_address_1","channelz_1","clientVersion","version","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","MIN_CONNECT_TIMEOUT_MS","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","uniformRandom","min","max","Math","random","tooManyPingsData","Buffer","from","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connectivityState","ConnectivityState","IDLE","session","continueConnecting","stateListeners","disconnectListeners","Set","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","callRefcount","refcount","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","channelzSocketRef","remoteName","streamTracker","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","userAgent","filter","e","join","keepaliveIntervalId","setTimeout","clearTimeout","keepaliveTimeoutId","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","subchannelAddressString","subchannelAddressToString","channelzTrace","ChannelzTrace","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","children","getChildLists","target","getChannelzSocketInfo","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","_a","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","_b","localWindowSize","remoteFlowControlWindow","_c","remoteWindowSize","resetChannelzSocketInfo","unregisterChannelzRef","unrefChild","text","LogVerbosity","DEBUG","id","refTrace","flowControlTrace","internalsTrace","keepaliveTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","sendPing","handleDisconnect","unref","call","ping","err","duration","payload","READY","startKeepalivePings","setInterval","stopKeepalivePings","clearInterval","createSession","proxyConnectionResult","realTarget","uriToString","targetAuthority","getDefaultAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","host","cert","servername","authorityHostname","splitHostPort","createConnection","authority","option","connect","Object","assign","registerChannelzSocket","refChild","once","errorCode","lastStreamID","opaqueData","NGHTTP2_ENHANCE_YOUR_CALM","equals","log","ERROR","error","message","isTracerEnabled","on","settings","startConnectingInternal","ALPNProtocols","targetPath","parseUri","path","hostPort","getProxiedConnection","then","result","reason","listener","values","oldStates","newState","indexOf","previousState","close","isRunning","process","nextTick","Error","checkBothRefcounts","callRef","ref","callUnref","unrefIfOneRef","startCallStream","metadata","callStream","extraFilters","headers","toHttp2Headers","getHost","getMethod","http2Stream","request","headersString","header","keys","getCallNumber","streamSession","closed","destroyed","statsTracker","addCallStarted","addStatusWatcher","status","code","Status","OK","addCallSucceeded","addCallFailed","addStreamEndWatcher","success","addMessageSent","Date","addMessageReceived","attachHttp2Stream","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","addDisconnectListener","add","removeDisconnectListener","delete","resetBackoff","getAddress","getChannelzRef","getRealSubchannel","exports"],"sources":["/home/deepakraj/Desktop/Ticket-ADDA/ticketadda/client/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { Call, Http2CallStream, WriteObject } from './call-stream';\nimport { ChannelOptions } from './channel-options';\nimport { PeerCertificate, checkServerIdentity, TLSSocket, CipherNameAndProtocol } from 'tls';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport { getDefaultAuthority } from './resolver';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as net from 'net';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ConnectionOptions } from 'tls';\nimport { FilterFactory, Filter, BaseFilter } from './filter';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, SocketInfo, SocketRef, unregisterChannelzRef, registerChannelzSocket, TlsInfo } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface SubchannelCallStatsTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n}\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private session: http2.ClientHttp2Session | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  /**\n   * A list of listener functions that will be called when the underlying\n   * socket disconnects. Used for ending active calls with an UNAVAILABLE\n   * status.\n   */\n  private disconnectListeners: Set<() => void> = new Set();\n\n  private backoffTimeout: BackoffTimeout;\n\n  /**\n   * The complete user agent string constructed using channel args.\n   */\n  private userAgent: string;\n\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = KEEPALIVE_MAX_TIME_MS;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  /**\n   * Tracks calls with references to this subchannel\n   */\n  private callRefcount = 0;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private channelzSocketRef: SocketRef | null = null;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private getChannelzSocketInfo(): SocketInfo | null {\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimeoutId.unref?.();\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.keepaliveTrace('Received ping response');\n          clearTimeout(this.keepaliveTimeoutId);\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n    }\n  }\n\n  private startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  private createSession(proxyConnectionResult: ProxyConnectionResult) {\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = getDefaultAuthority(\n      proxyConnectionResult.realTarget ?? this.channelTarget\n    );\n    let connectionOptions: http2.SecureClientSessionOptions =\n      this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname =\n          splitHostPort(targetAuthority)?.host ?? 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket!;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = {\n      ...connectionOptions,\n      ...this.subchannelAddress,\n    };\n\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(\n      addressScheme + targetAuthority,\n      connectionOptions\n    );\n    this.session = session;\n    this.channelzSocketRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo()!, this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.READY\n        );\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState(\n          [ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      }\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        if (this.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (\n            errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n            opaqueData.equals(tooManyPingsData)\n          ) {\n            this.keepaliveTimeMs = Math.min(\n              2 * this.keepaliveTimeMs,\n              KEEPALIVE_MAX_TIME_MS\n            );\n            logging.log(\n              LogVerbosity.ERROR,\n              `Connection to ${uriToString(this.channelTarget)} at ${\n                this.subchannelAddressString\n              } rejected by server because of excess pings. Increasing ping interval to ${\n                this.keepaliveTimeMs\n              } ms`\n            );\n          }\n          this.trace(\n            'connection closed by GOAWAY with code ' +\n              errorCode\n          );\n          this.transitionToState(\n            [ConnectivityState.CONNECTING, ConnectivityState.READY],\n            ConnectivityState.IDLE\n          );\n        }\n      }\n    );\n    session.once('error', (error) => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private startConnectingInternal() {\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(this.options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    getProxiedConnection(\n      this.subchannelAddress,\n      this.options,\n      connectionOptions\n    ).then(\n      (result) => {\n        this.createSession(result);\n      },\n      (reason) => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n      }\n    );\n  }\n\n  private handleDisconnect() {\n    this.transitionToState(\n      [ConnectivityState.READY],\n      ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session!;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  private checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.IDLE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount + 1)\n    );\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount - 1)\n    );\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(\n    metadata: Metadata,\n    callStream: Http2CallStream,\n    extraFilters: Filter[]\n  ) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'call_stream',\n      'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +\n        '(' + this.channelzRef.id + ') ' +\n        this.subchannelAddressString +\n        ' with headers\\n' +\n        headersString\n    );\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session!.state.localWindowSize +\n        ' remote window size: ' +\n        this.session!.state.remoteWindowSize\n    );\n    const streamSession = this.session;\n    this.internalsTrace(\n      'session.closed=' + \n      streamSession!.closed + \n      ' session.destroyed=' + \n      streamSession!.destroyed + \n      ' session.socket.destroyed=' + \n      streamSession!.socket.destroyed);\n    let statsTracker: SubchannelCallStatsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      }\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      }\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener: () => void) {\n    this.disconnectListeners.add(listener);\n  }\n\n  removeDisconnectListener(listener: () => void) {\n    this.disconnectListeners.delete(listener);\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}